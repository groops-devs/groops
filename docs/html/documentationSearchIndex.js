var documents = {
'general.configFiles': { 'name': 'general.configFiles', 'key': 'general.configFiles', 'description': 'GROOPS is controlled by XML configuration files. One or more configuration files must be passed as arguments to GROOPS:     groops config1.xml config2.xml [...]   These files can be created with the graphical user interface program  groopsGui  in a convenient way (see section  GUI ). A complete formal (computer readable) description of a configuration file in the form of an XSD schema file can be created with the command     groops --xsd groops.xsd  A configuration file consists of a list of  programs  that are executed in sequential order. Each program comes with its own config options and they work independently without any internal communication between programs. Data flow between programs is realized via files. An  outputfile  of one program can serve as an  inputfile  for the next program. Most programs are deliberately kept small and focused on a specific task. This modularity combined with the general purpose design of many programs enables the creation of complex workflows with little effort. Including  loops and conditions  in a config file provides even more flexibility. Individual programs (and also other optional config elements) can be disabled and are ignored during execution. Mandatory config elements are indicated by a star ( * ). Empty optional elements are ignored or a meaningful default value is assumed. The elements of a configuration file can be one of the following basic data types:    int : integer number  uint : unsigned integer number  double : floating point number  angle : given in degree  time : given in modified Julian date (MJD)  boolean : 0: false, 1: true  string : text  filename : absolute path to a file or path relative to the working directory  expression : numerical expression evaluated during execution  doodson : Doodson number or Darwin\'s name of a tidal frequency  gnssType : GNSS observation type according to the RINEX 3 definition   The first 5 data types also allow numerical expressions as input in addition to pure numbers. Next to these basic types there are a number of complex data types called classes, which are described in section  Classes .  In addition to programs a config file can also include multiple global elements. These elements are comparable to read-only global variables in programming and can be referenced from any program. This can be done by either linking an element directly to a global element or by using the name of the global element as a variable in an input field (see section  Parsers and variables ). While elements can only be directly linked to global elements of the same type, this also supports complex data types such as  section . Thus it is possible to, for example, define a reference gravity field once in the global section and use it multiple times in different programs. One special global element is  groopsDataDir , which is used as a variable in most default file paths throughout many GROOPS programs. Since this global element is going to be needed in most config files, it is recommended to define it in a template file that is used when creating new config files in the GUI. See section  Graphical User Interface (GUI)  for details on how to set up a template file. Global elements can be manipulated when running a config file by passing the argument  --global &lt;name>=&lt;value> . For example, running the command     groops --global timeStart=58849 --global satellite=swarm config.xml   runs the config file  config.xml  but replaces the values of the global elements  timeStart  and  satellite  with  58849  and  swarm , respectively. If a global element passed as an argument does not already exist in the config file, it will be added with the type  string . Only the basic data types listed above are supported. This feature can be useful when running GROOPS from the command line or from an external script file.', 'config_table': '', 'display_text': 'GROOPS is controlled by XML configuration files. One or more configuration files must be passed as arguments to GROOPS: <pre>   groops config1.xml config2.xml [...] </pre> These files can be created with the graphical user interface program <code>groopsGui</code> in a convenient way (see section <a class="groops-ref" href="general.gui.html">GUI</a>). A complete formal (computer readable) description of a configuration file in the form of an XSD schema file can be created with the command <pre>   groops --xsd groops.xsd </pre></p><p>A configuration file consists of a list of <a class="groops-ref" href="programType.html">programs</a> that are executed in sequential order. Each program comes with its own config options and they work independently without any internal communication between programs. Data flow between programs is realized via files. An <strong class="groops-config-element">outputfile</strong> of one program can serve as an <strong class="groops-config-element">inputfile</strong> for the next program. Most programs are deliberately kept small and focused on a specific task. This modularity combined with the general purpose design of many programs enables the creation of complex workflows with little effort. Including <a class="groops-ref" href="general.loopsAndConditions.html">loops and conditions</a> in a config file provides even more flexibility.</p><p>Individual programs (and also other optional config elements) can be disabled and are ignored during execution. Mandatory config elements are indicated by a star (<code>*</code>). Empty optional elements are ignored or a meaningful default value is assumed.</p><p>The elements of a configuration file can be one of the following basic data types: <ul>  <li><code>int</code>: integer number </li><li> <code>uint</code>: unsigned integer number </li><li> <code>double</code>: floating point number </li><li> <code>angle</code>: given in degree </li><li> <code>time</code>: given in modified Julian date (MJD) </li><li> <code>boolean</code>: 0: false, 1: true </li><li> <code>string</code>: text </li><li> <code>filename</code>: absolute path to a file or path relative to the working directory </li><li> <code>expression</code>: numerical expression evaluated during execution </li><li> <code>doodson</code>: Doodson number or Darwin\'s name of a tidal frequency </li><li> <code>gnssType</code>: GNSS observation type according to the RINEX 3 definition </li></ul>  The first 5 data types also allow numerical expressions as input in addition to pure numbers. Next to these basic types there are a number of complex data types called classes, which are described in section <a class="groops-ref" href="classes.html">Classes</a>.</p><p><h2 id="globalSection">Global section</h2><p> In addition to programs a config file can also include multiple global elements. These elements are comparable to read-only global variables in programming and can be referenced from any program. This can be done by either linking an element directly to a global element or by using the name of the global element as a variable in an input field (see section <a class="groops-ref" href="general.parser.html">Parsers and variables</a>). While elements can only be directly linked to global elements of the same type, this also supports complex data types such as <a class="groops-class" href="gravityfieldType.html">gravityfield</a>. Thus it is possible to, for example, define a reference gravity field once in the global section and use it multiple times in different programs.</p><p>One special global element is <code>groopsDataDir</code>, which is used as a variable in most default file paths throughout many GROOPS programs. Since this global element is going to be needed in most config files, it is recommended to define it in a template file that is used when creating new config files in the GUI. See section <a class="groops-ref" href="general.gui.html">Graphical User Interface (GUI)</a> for details on how to set up a template file.</p><p>Global elements can be manipulated when running a config file by passing the argument <code>--global &lt;name>=&lt;value></code>. For example, running the command <pre>   groops --global timeStart=58849 --global satellite=swarm config.xml </pre> runs the config file <code>config.xml</code> but replaces the values of the global elements <code>timeStart</code> and <code>satellite</code> with <code>58849</code> and <code>swarm</code>, respectively. If a global element passed as an argument does not already exist in the config file, it will be added with the type <code>string</code>. Only the basic data types listed above are supported. This feature can be useful when running GROOPS from the command line or from an external script file.'},
'general.parser': { 'name': 'general.parser', 'key': 'general.parser', 'description': 'In all input fields that accept numbers (int, uint, double, angle, time) numerical expressions are also allowed. Values from the global section can be used as variables. The following operations and functions are defined:    Constants:     pi() ,  rho()=180/pi() ,  nan() ,  c() : light velocity,                      G() : gravitational constant,  GM() : gravitational constant of the Earth,  R() : reference radius of the Earth  Mathematical:  + ,  - ,  * ,  / ,  ^   Comparison:    == ,  != ,  &lt; ,  &lt;= ,  > ,  >= , result is 1 or 0  Logical:      not  ! , and  && ,  || , or  isnan(x) , result is 1 or 0  Functions:     sqrt(x) ,  exp(x) ,                      sin(x) ,   cos(x) ,  tan(x) ,                      asin(x) ,   acos(x) ,   atan(x) ,                      abs(x) ,   round(x) ,   ceil(x) ,   floor(x) ,                      deg2rad(x) ,  rad2deg(x)   Functions with 2 arguments:  atan2(y,x) ,  min(x,y) ,  max(x,y) ,  mod(x,y)   Time functions:  now() : local time in MJD,  date2mjd(year, month, day) ,  gps2utc(mjd) ,  utc2gps(mjd) ,  dayofyear(mjd) ,  decimalyear(mjd)   Condition:  if(c,x,y) : If the first argument is true (not 0), the second argument is evaluated, otherwise the third.     Before the mathematical expression parser evaluates the expression, a simple text parser is applied. The text parser is used for all input fields (also file names). It scans the text for terms like  {variable}  and replaces it by the text content of the  variable  defined in the global section. A literal \' { \' character must be escaped with \' #{ \'. The text parser allows regex replacements in the form  {text/regex/replace} . All matches of  regex  in the  text  are replaced by  replace . Possible  {variables}  in the three parts are evaluated beforehand. Capturing groups  ()  can be accessed by  $1 ,  $2 ,  in the replacement ( $0  is the complete match). Additional escape sequences are:    \\l  lowercase next char,  \\u  uppercase next char,  \\L  lowercase until  \\E ,  \\U  uppercase until  \\E ,  \\Q  quote (disable) pattern metacharacters until  \\E ,  \\E  end either case modification or quoted section.  Examples:    {{variable}/test/text}  replaces all occurrences of  test  by  text .  {TEXT/.+/\\L$0}  converts text to lower case.  {012345/.#{2}(.#{3}).*/$1}  extracts the substring at index 2 and length 3 resulting in  234 .       Note the escaping  #{ .  The text parser also evaluates terms in the form  {expression:format}  and replaces it by a formatted output. The  format  contains the text to be written as output. It can contain embedded format specifiers that are replaced by the value of the expression and formatted as requested (also multiple times). In the following, the resulting formatted output is given in the brackets for an expression with the example value of 57493.8:    %i : Integer [57494]  %f : Decimal floating point [57493.800000]  %e : Scientific notation [5.749380e+04]  %g : Use the shortest representation:  %e  or  %f  [57493.8]  %c : Interpret number as ASCII character  %% : Write a single literal  %  character   The following specifiers interpret the value of the expression as MJD (modified Julian date):    %y : Four digit year [2016]  %Y : Two digit year [16]  %m : Month [04]  %d : Day of month [15]  %H : Hour [19]  %M : Minute [12]  %S : Second [00]  %D : Date (same as  %y-%m-%d ) [2016-04-15]  %T : Time (same as  %H-%M-%S ) [19-12-00]  %W : GPS week [1892]  %w : Day of GPS week (0..6) [5]  %O : Day of year (1..366)   The format can be specified further with  %[width][.precision]specifier , where  [width]  is the minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces (or zeros if  [width]  starts with a zero). The  [.precision]  defines the number of digits after the period (for  %g  the number of significant digits instead). Example: Two variables  time = 57493+19/24+12/1440  and  satellite = swarm  are set in the global section. The  inputfile = data/{time:%y}/{satellite}_{time:%D}.dat  is expanded to  "data/2016/swarm_2016-04-15.dat" . Example: The variable  x = 3+5  is set in the global section. The expression  number = 2*x  is evaluated by the expression parser to  =16 . In contrast if we use brackets like in  number = 2*{x}  the expression is first evaluated by the text parser to  "2*3+5"  and the expression parser now gives the result  =11 .    Some programs (e.g.  FunctionsCalculate ,  InstrumentArcCalculate ,  GriddedDataCalculate , or the plot programs) read data ( matrix ) or  gridded data  and evaluate input/output expressions for each data row. For these kind of expressions additional variables are automatically defined for each data column ( X  stands for the data column number:  ):    index : the row number, starting with zero  dataX : the value itself  dataXcount : number of rows  dataXmin   dataXmax   dataXsum   dataXmean   dataXrms : root mean square  dataXstd : standard deviation  dataXmedian   dataXmad : median absolute deviation  dataXstep : the minimal difference between two neighboring data points in the column   For  gridded data  input the following variables are additionally defined for each data point:    longitude  in degrees  latitude  in degrees  height  in meters  cartesianX  coordinate in meters  cartesianY  coordinate in meters  cartesianZ  coordinate in meters  area  of the unit sphere  dataXwmean : area-weighted mean  dataXwrms : area-weighted root mean square  dataXwstd : area-weighted standard deviation    The XML configuration input is evaluated by two parsers. In a first step a text parser is applied. In the second step mathematical expressions are resolved to a number. Basic data types in the global section serve as input variables for the parsers.', 'config_table': '', 'display_text': 'The XML configuration input is evaluated by two parsers. In a first step a text parser is applied. In the second step mathematical expressions are resolved to a number. Basic data types in the global section serve as input variables for the parsers.</p><p><h2 id="expression">Mathematical expression parser</h2><p> In all input fields that accept numbers (int, uint, double, angle, time) numerical expressions are also allowed. Values from the global section can be used as variables. The following operations and functions are defined: <ul>  <li>Constants:    <code>pi()</code>, <code>rho()=180/pi()</code>, <code>nan()</code>, <code>c()</code>: light velocity,                     <code>G()</code>: gravitational constant, <code>GM()</code>: gravitational constant of the Earth, <code>R()</code>: reference radius of the Earth </li><li> Mathematical: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>^</code> </li><li> Comparison:   <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>></code>, <code>>=</code>, result is 1 or 0 </li><li> Logical:      not <code>!</code>, and <code>&&</code>, <code>||</code>, or <code>isnan(x)</code>, result is 1 or 0 </li><li> Functions:    <code>sqrt(x)</code>, <code>exp(x)</code>,                     <code>sin(x)</code>,  <code>cos(x)</code>, <code>tan(x)</code>,                     <code>asin(x)</code>,  <code>acos(x)</code>,  <code>atan(x)</code>,                     <code>abs(x)</code>,  <code>round(x)</code>,  <code>ceil(x)</code>,  <code>floor(x)</code>,                     <code>deg2rad(x)</code>, <code>rad2deg(x)</code> </li><li> Functions with 2 arguments: <code>atan2(y,x)</code>, <code>min(x,y)</code>, <code>max(x,y)</code>, <code>mod(x,y)</code> </li><li> Time functions: <code>now()</code>: local time in MJD, <code>date2mjd(year, month, day)</code>, <code>gps2utc(mjd)</code>, <code>utc2gps(mjd)</code>, <code>dayofyear(mjd)</code>, <code>decimalyear(mjd)</code> </li><li> Condition: <code>if(c,x,y)</code>: If the first argument is true (not 0), the second argument is evaluated, otherwise the third. </li></ul> </p><p> <h2 id="text">Text parser</h2><p> Before the mathematical expression parser evaluates the expression, a simple text parser is applied. The text parser is used for all input fields (also file names). It scans the text for terms like <code>{variable}</code> and replaces it by the text content of the <code>variable</code> defined in the global section. A literal \'<code>{</code>\' character must be escaped with \'<code>#{</code>\'.</p><p>The text parser allows regex replacements in the form <code>{text/regex/replace}</code>. All matches of <code>regex</code> in the <code>text</code> are replaced by <code>replace</code>. Possible <code>{variables}</code> in the three parts are evaluated beforehand. Capturing groups <code>()</code> can be accessed by <code>$1</code>, <code>$2</code>, in the replacement (<code>$0</code> is the complete match). Additional escape sequences are: <ul>  <li><code>\\l</code> lowercase next char, </li><li> <code>\\u</code> uppercase next char, </li><li> <code>\\L</code> lowercase until <code>\\E</code>, </li><li> <code>\\U</code> uppercase until <code>\\E</code>, </li><li> <code>\\Q</code> quote (disable) pattern metacharacters until <code>\\E</code>, </li><li> <code>\\E</code> end either case modification or quoted section. </li></ul> </p><p>Examples: <ul>  <li><code>{{variable}/test/text}</code> replaces all occurrences of <code>test</code> by <code>text</code>. </li><li> <code>{TEXT/.+/\\L$0}</code> converts text to lower case. </li><li> <code>{012345/.#{2}(.#{3}).*/$1}</code> extracts the substring at index 2 and length 3 resulting in <code>234</code>.       Note the escaping <code>#{</code>. </li></ul> </p><p>The text parser also evaluates terms in the form <code>{expression:format}</code> and replaces it by a formatted output. The <code>format</code> contains the text to be written as output. It can contain embedded format specifiers that are replaced by the value of the expression and formatted as requested (also multiple times). In the following, the resulting formatted output is given in the brackets for an expression with the example value of 57493.8: <ul>  <li><code>%i</code>: Integer [57494] </li><li> <code>%f</code>: Decimal floating point [57493.800000] </li><li> <code>%e</code>: Scientific notation [5.749380e+04] </li><li> <code>%g</code>: Use the shortest representation: <code>%e</code> or <code>%f</code> [57493.8] </li><li> <code>%c</code>: Interpret number as ASCII character </li><li> <code>%%</code>: Write a single literal <code>%</code> character </li></ul>  The following specifiers interpret the value of the expression as MJD (modified Julian date): <ul>  <li><code>%y</code>: Four digit year [2016] </li><li> <code>%Y</code>: Two digit year [16] </li><li> <code>%m</code>: Month [04] </li><li> <code>%d</code>: Day of month [15] </li><li> <code>%H</code>: Hour [19] </li><li> <code>%M</code>: Minute [12] </li><li> <code>%S</code>: Second [00] </li><li> <code>%D</code>: Date (same as <code>%y-%m-%d</code>) [2016-04-15] </li><li> <code>%T</code>: Time (same as <code>%H-%M-%S</code>) [19-12-00] </li><li> <code>%W</code>: GPS week [1892] </li><li> <code>%w</code>: Day of GPS week (0..6) [5] </li><li> <code>%O</code>: Day of year (1..366) </li></ul>  The format can be specified further with <code>%[width][.precision]specifier</code>, where <code>[width]</code> is the minimum number of characters to be printed. If the value to be printed is shorter than this number, the result is padded with blank spaces (or zeros if <code>[width]</code> starts with a zero). The <code>[.precision]</code> defines the number of digits after the period (for <code>%g</code> the number of significant digits instead).</p><p>Example: Two variables <strong class="groops-config-element">time</strong>=<code>57493+19/24+12/1440</code> and <strong class="groops-config-element">satellite</strong>=<code>swarm</code> are set in the global section. The <strong class="groops-config-element">inputfile</strong>=<code>data/{time:%y}/{satellite}_{time:%D}.dat</code> is expanded to <code>"data/2016/swarm_2016-04-15.dat"</code>.</p><p>Example: The variable <strong class="groops-config-element">x</strong>=<code>3+5</code> is set in the global section. The expression <strong class="groops-config-element">number</strong>=<code>2*x</code> is evaluated by the expression parser to <code>=16</code>. In contrast if we use brackets like in <strong class="groops-config-element">number</strong>=<code>2*{x}</code> the expression is first evaluated by the text parser to <code>"2*3+5"</code> and the expression parser now gives the result <code>=11</code>.</p><p> <h2 id="dataVariables">Variables for data</h2><p> Some programs (e.g. <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a>, <a class="groops-program" href="InstrumentArcCalculate.html">InstrumentArcCalculate</a>, <a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a>, or the plot programs) read data (<a class="groops-file" href="fileFormat_matrix.html">matrix</a>) or <a class="groops-file" href="fileFormat_griddedData.html">gridded data</a> and evaluate input/output expressions for each data row. For these kind of expressions additional variables are automatically defined for each data column (<code>X</code> stands for the data column number: $0\\ldots n$): <ul>  <li><code>index</code>: the row number, starting with zero </li><li> <code>dataX</code>: the value itself </li><li> <code>dataXcount</code>: number of rows </li><li> <code>dataXmin</code> </li><li> <code>dataXmax</code> </li><li> <code>dataXsum</code> </li><li> <code>dataXmean</code> </li><li> <code>dataXrms</code>: root mean square </li><li> <code>dataXstd</code>: standard deviation </li><li> <code>dataXmedian</code> </li><li> <code>dataXmad</code>: median absolute deviation </li><li> <code>dataXstep</code>: the minimal difference between two neighboring data points in the column </li></ul>  For <a class="groops-file" href="fileFormat_griddedData.html">gridded data</a> input the following variables are additionally defined for each data point: <ul>  <li><code>longitude</code> in degrees </li><li> <code>latitude</code> in degrees </li><li> <code>height</code> in meters </li><li> <code>cartesianX</code> coordinate in meters </li><li> <code>cartesianY</code> coordinate in meters </li><li> <code>cartesianZ</code> coordinate in meters </li><li> <code>area</code> of the unit sphere </li><li> <code>dataXwmean</code>: area-weighted mean </li><li> <code>dataXwrms</code>: area-weighted root mean square </li><li> <code>dataXwstd</code>: area-weighted standard deviation </li></ul> </p><p>'},
'general.loopsAndConditions': { 'name': 'general.loopsAndConditions', 'key': 'general.loopsAndConditions', 'description': 'The program flow within a config file can be controlled by the classes  section  and  section . The easiest way to access these classes is with the programs  LoopPrograms  and  IfPrograms . The programs defined in  IfPrograms  are only executed if the defined  section  is met. A typical example is to check whether a file that should have been created in previous programs actually exists. Further options are string comparisons and checking the result of a numerical expression or the return value of an external command. With  LoopPrograms  it is possible to repeat the programs defined inside within a loop. The class  section  creates a sequence to loop over and defines  variables  that contain the index and element for the current iteration. If  section  and  section  are defined in the global section (see section  Config files ) they become powerful tools as the they can be attributed to single config elements (including programs). Config elements with an assigned loop are repeated, with the loop variables being evaluated for each element. If a  section  is attributed to a config element in addition to a loop, each element within the loop is only created if the condition is met. Conditions can also be attributed to optional elements without an associated loop. If the condition is not met, the optional element will be treated as if it was not provided. Example: A program needs all files in a download directory as input. All the  inputfile s can be selected manually of course, but it is much easier to assign a loop variable with  inputfile = {loopFile}  and attribute a  section  from the global section. The loop lists the content of the download directory and assigns each file name to the  variableLoopFile = loopFile .', 'config_table': '', 'display_text': 'The program flow within a config file can be controlled by the classes <a class="groops-class" href="loopType.html">loop</a> and <a class="groops-class" href="conditionType.html">condition</a>. The easiest way to access these classes is with the programs <a class="groops-program" href="LoopPrograms.html">LoopPrograms</a> and <a class="groops-program" href="IfPrograms.html">IfPrograms</a>.</p><p>The programs defined in <a class="groops-program" href="IfPrograms.html">IfPrograms</a> are only executed if the defined <a class="groops-class" href="conditionType.html">condition</a> is met. A typical example is to check whether a file that should have been created in previous programs actually exists. Further options are string comparisons and checking the result of a numerical expression or the return value of an external command.</p><p>With <a class="groops-program" href="LoopPrograms.html">LoopPrograms</a> it is possible to repeat the programs defined inside within a loop. The class <a class="groops-class" href="loopType.html">loop</a> creates a sequence to loop over and defines <a class="groops-ref" href="general.parser.html">variables</a> that contain the index and element for the current iteration.</p><p>If <a class="groops-class" href="loopType.html">loop</a> and <a class="groops-class" href="conditionType.html">condition</a> are defined in the global section (see section <a class="groops-ref" href="general.configFiles.html">Config files</a>) they become powerful tools as the they can be attributed to single config elements (including programs). Config elements with an assigned loop are repeated, with the loop variables being evaluated for each element. If a <a class="groops-class" href="conditionType.html">condition</a> is attributed to a config element in addition to a loop, each element within the loop is only created if the condition is met. Conditions can also be attributed to optional elements without an associated loop. If the condition is not met, the optional element will be treated as if it was not provided.</p><p>Example: A program needs all files in a download directory as input. All the <strong class="groops-config-element">inputfile</strong>s can be selected manually of course, but it is much easier to assign a loop variable with <strong class="groops-config-element">inputfile</strong>=<code>{loopFile}</code> and attribute a <a class="groops-class" href="loopType.html#directoryListing">loop:directoryListing</a> from the global section. The loop lists the content of the download directory and assigns each file name to the <strong class="groops-config-element">variableLoopFile</strong>=<code>loopFile</code>.'},
'general.gui': { 'name': 'general.gui', 'key': 'general.gui', 'description': 'The graphical user interface program  groopsGui  enables the convenient creation of GROOPS config files. It uses the   for cross-platform support. The GUI depends on an XSD schema file containing the complete formal (computer readable) description of a GROOPS config file. This schema file can be created with the command:     groops --xsd &lt;groopsDir>/groops.xsd   At least one schema file has to be set via the menu  Settings - Default Paths and Files . Setting more than one schema files enables the  schema selector  in the toolbar. The selected schema will be used when (re-)opening or creating a config file. This feature is useful when working with different versions of GROOPS at the same time. It is possible to set a  template file  via the menu  Settings - Default Paths and Files . This can be any GROOPS config file. Whenever a new config file is created via the GUI, all global elements and programs defined in the template file are automatically created in the new config file. It is highly recommended to create a template file containing at least the global element  groopsDataDir  of type  filename . This element is used as a  variable  in most default file paths throughout many GROOPS programs. Thus, setting the path to the base directory containing all GROOPS data once in the template file, for example as  groopsDataDir = /home/&lt;user>/groops/data , is the most convenient way to handle default paths in GROOPS. The template file can also contain other often-used global elements, for example  tmpDir  or   timeStart  and   timeEnd . A  working directory  can be set via  Settings - Default Paths and Files . This directory is used as the default directory in the save dialog of new config files. The GUI offers the option to open the GROOPS documentation for a selected program. To use this feature, the GROOPS documentation must be generated (if not already present) with the command:     groops --doc &lt;groopsDir>/docs/   In the menu  Settings - Default Paths and Files  the path to the HTML version of the documentation must be set (i.e.  &lt;groopsDir>/docs/html ). Selecting any program and pressing  F1  opens the documentation for this program in an external browser. Pressing  F1  without having any program selected opens the main page of the GROOPS documentation. Executing a config file from the GUI requires the setup of a run command in the menu  Settings - Commands . It is recommended for this command to open a new terminal in which GROOPS is executed with the config file given as an argument. The placeholders  %w  and  %f  are replaced by the directory and file name of the selected config file, respectively. Multiple commands can be set up, with the option to choose one of them in the run dialog. Example commands:   	 Windows:  cd /d %w && groops.exe %f  	 Linux (KDE):  konsole --workdir %w -e bash -ic "groops %f; bash"  	 Linux (GNOME):  gnome-terminal --working-directory=%w -x bash -ic "groops %f; bash"  	 Windows, MPI with 4 processes:  cd /d %w && mpiexec -n 4 groopsMPI.exe %f  	 Linux (KDE), MPI with 4 processes:  konsole --workdir %w -e bash -ic "mpiexec -n 4 groopsMPI %f; bash"  	 Linux (GNOME), MPI with 4 processes:  gnome-terminal --working-directory=%w -x bash -ic "mpiexec -n 4 groopsMPI %f; bash"   Most basic features used to manipulate a config element are accessible via the context menu, for example attributing  loops and conditions  or setting an element global. Global elements automatically appear in the dropdown value list of config elements of the same type. Selecting a global element from the dropdown list as a value links this config element to the global element. In case the global element is removed, all linked elements\' values are replaced by the value of the deleted global element. The sidebar features three widgets:   	 Open Files : An overview of all open config files (select to change current tree) 	 Program List : A list of all programs defined in the schema of the active tree (filterable, supports drag and drop to tree, double click appends program) 	 Undo Stack : Tracks all changes in a config file (select to change state of tree)  In case the names of programs or config elements change over time, the GUI offers a rename feature to update outdated config files. The changes must be documented in the schema using GROOPS\' rename feature. Affected elements will be marked with an icon and the context menu item  Update name  will be available to change the element to the new name defined in the schema.  	 Tree navigation: 	  		 Enter : Switch focus from tree to input field of selected row 		 Escape : Switch focus from input field back to tree 		 Tab : Next sibling element (or next sibling of parent if there is no next sibling, or next child otherwise) 		 Shift+Tab : Previous sibling element (or parent if there is no previous sibling) 		 Ctrl+Tab : Next tab/tree 		 Ctrl+Shift+Tab : Previous tab/tree 		 Ctrl+Space : Interact with the element (e.g. filename/program: open dialog; time: switch focus between input fields) 		 Ctrl+Up/Down : Next/previous sibling element 		 Ctrl+Left/Right : Fold/expand (complex) element 	  	 Tree manipulation: 	  		 Ctrl+Shift+Up/Down : Move unbounded list element (e.g. program, layer) up/down 	  	 Drag and Drop of tabs to other programs (i.e. text editors) or other GUI windows: 	  		 Drag : Copy tab (= keep in source window) 		 Shift+Drag : Move tab (= remove from source window) 	  	 Drag and Drop GROOPS config file(s) into GUI: 	  		 Drag : Open file(s) in new tab(s) 		 Shift+Drag : Open file in current tab (replaces current tab, only works with a single file)', 'config_table': '', 'display_text': '</p><p>The graphical user interface program <code>groopsGui</code> enables the convenient creation of GROOPS config files. It uses the <a href="https://qt.io">Qt5 framework</a> for cross-platform support.</p><p></p><p><h2>Settings and first-time setup</h2><p></p><p>The GUI depends on an XSD schema file containing the complete formal (computer readable) description of a GROOPS config file. This schema file can be created with the command: <pre>   groops --xsd &lt;groopsDir>/groops.xsd </pre> At least one schema file has to be set via the menu <code>Settings - Default Paths and Files</code>. Setting more than one schema files enables the <em>schema selector</em> in the toolbar. The selected schema will be used when (re-)opening or creating a config file. This feature is useful when working with different versions of GROOPS at the same time.</p><p>It is possible to set a <em>template file</em> via the menu <code>Settings - Default Paths and Files</code>. This can be any GROOPS config file. Whenever a new config file is created via the GUI, all global elements and programs defined in the template file are automatically created in the new config file. It is highly recommended to create a template file containing at least the global element <code>groopsDataDir</code> of type <code>filename</code>. This element is used as a <a class="groops-ref" href="general.parser.html">variable</a> in most default file paths throughout many GROOPS programs. Thus, setting the path to the base directory containing all GROOPS data once in the template file, for example as <strong class="groops-config-element">groopsDataDir</strong>=<code>/home/&lt;user>/groops/data</code>, is the most convenient way to handle default paths in GROOPS. The template file can also contain other often-used global elements, for example <code>tmpDir</code> or  <code>timeStart</code> and  <code>timeEnd</code>.</p><p>A <em>working directory</em> can be set via <code>Settings - Default Paths and Files</code>. This directory is used as the default directory in the save dialog of new config files.</p><p>The GUI offers the option to open the GROOPS documentation for a selected program. To use this feature, the GROOPS documentation must be generated (if not already present) with the command: <pre>   groops --doc &lt;groopsDir>/docs/ </pre> In the menu <code>Settings - Default Paths and Files</code> the path to the HTML version of the documentation must be set (i.e. <code>&lt;groopsDir>/docs/html</code>). Selecting any program and pressing <code>F1</code> opens the documentation for this program in an external browser. Pressing <code>F1</code> without having any program selected opens the main page of the GROOPS documentation.</p><p>Executing a config file from the GUI requires the setup of a run command in the menu <code>Settings - Commands</code>. It is recommended for this command to open a new terminal in which GROOPS is executed with the config file given as an argument. The placeholders <code>%w</code> and <code>%f</code> are replaced by the directory and file name of the selected config file, respectively. Multiple commands can be set up, with the option to choose one of them in the run dialog.</p><p>Example commands: <ul>  	<li>Windows: <code>cd /d %w && groops.exe %f</code> 	</li><li> Linux (KDE): <code>konsole --workdir %w -e bash -ic "groops %f; bash"</code> 	</li><li> Linux (GNOME): <code>gnome-terminal --working-directory=%w -x bash -ic "groops %f; bash"</code> 	</li><li> Windows, MPI with 4 processes: <code>cd /d %w && mpiexec -n 4 groopsMPI.exe %f</code> 	</li><li> Linux (KDE), MPI with 4 processes: <code>konsole --workdir %w -e bash -ic "mpiexec -n 4 groopsMPI %f; bash"</code> 	</li><li> Linux (GNOME), MPI with 4 processes: <code>gnome-terminal --working-directory=%w -x bash -ic "mpiexec -n 4 groopsMPI %f; bash"</code> </li></ul> </p><p><h2>Basic features</h2><p></p><p>Most basic features used to manipulate a config element are accessible via the context menu, for example attributing <a class="groops-ref" href="general.loopsAndConditions.html">loops and conditions</a> or setting an element global. Global elements automatically appear in the dropdown value list of config elements of the same type. Selecting a global element from the dropdown list as a value links this config element to the global element. In case the global element is removed, all linked elements\' values are replaced by the value of the deleted global element.</p><p>The sidebar features three widgets: <ul>  	<li><code>Open Files</code>: An overview of all open config files (select to change current tree) 	</li><li> <code>Program List</code>: A list of all programs defined in the schema of the active tree (filterable, supports drag and drop to tree, double click appends program) 	</li><li> <code>Undo Stack</code>: Tracks all changes in a config file (select to change state of tree) </li></ul> </p><p>In case the names of programs or config elements change over time, the GUI offers a rename feature to update outdated config files. The changes must be documented in the schema using GROOPS\' rename feature. Affected elements will be marked with an icon and the context menu item <code>Update name</code> will be available to change the element to the new name defined in the schema.</p><p><h2>Additional keyboard shortcuts</h2><p></p><p><ul>  	<li>Tree navigation: 	<ul>  		</li><li> <code>Enter</code>: Switch focus from tree to input field of selected row 		</li><li> <code>Escape</code>: Switch focus from input field back to tree 		</li><li> <code>Tab</code>: Next sibling element (or next sibling of parent if there is no next sibling, or next child otherwise) 		</li><li> <code>Shift+Tab</code>: Previous sibling element (or parent if there is no previous sibling) 		</li><li> <code>Ctrl+Tab</code>: Next tab/tree 		</li><li> <code>Ctrl+Shift+Tab</code>: Previous tab/tree 		</li><li> <code>Ctrl+Space</code>: Interact with the element (e.g. filename/program: open dialog; time: switch focus between input fields) 		</li><li> <code>Ctrl+Up/Down</code>: Next/previous sibling element 		</li><li> <code>Ctrl+Left/Right</code>: Fold/expand (complex) element 	</li></ul>  	<li>Tree manipulation: 	<ul>  		</li><li> <code>Ctrl+Shift+Up/Down</code>: Move unbounded list element (e.g. program, layer) up/down 	</li></ul>  	<li>Drag and Drop of tabs to other programs (i.e. text editors) or other GUI windows: 	<ul>  		</li><li> <code>Drag</code>: Copy tab (= keep in source window) 		</li><li> <code>Shift+Drag</code>: Move tab (= remove from source window) 	</li></ul>  	<li>Drag and Drop GROOPS config file(s) into GUI: 	<ul>  		</li><li> <code>Drag</code>: Open file(s) in new tab(s) 		</li><li> <code>Shift+Drag</code>: Open file in current tab (replaces current tab, only works with a single file) 	</li></ul>  </ul>'},
'general.constants': { 'name': 'general.constants', 'key': 'general.constants', 'description': 'GROOPS uses some built-in constants like  DEFAULT_GM  or the definition of leap seconds, which are defined in   source/base/constants.cpp . A complete list of the constants can be written to an XML file with:     groops --write-settings &lt;groopsDefaults.xml>  The built-in constants can be overwritten by a  groopsDefaults.xml  file in the working directory or by explicitly passing the file as an argument at execution:     groops --settings &lt;groopsDefaults.xml> &lt;config.xml>  It might also be useful to adjust the default values in the schema file used by the  GUI :     groops --settings &lt;groopsDefaults.xml> --xsd &lt;groops.xsd>  Example file:   &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops>   &lt;LIGHT_VELOCITY>299792458&lt;/LIGHT_VELOCITY>   &lt;DEFAULT_GM>3.986004415e+14&lt;/DEFAULT_GM>   &lt;DEFAULT_R>6378136.3&lt;/DEFAULT_R>   &lt;GRS80_a>6378137.0&lt;/GRS80_a>   &lt;GRS80_f>298.2572221010&lt;/GRS80_f>   &lt;GRAVITATIONALCONSTANT>6.6730e-11&lt;/GRAVITATIONALCONSTANT>   &lt;R_Earth>6.37813630000000e+06&lt;/R_Earth>   &lt;R_Moon>1.73800000000000e+06&lt;/R_Moon>   &lt;GM_Earth>3.98600441500000e+14&lt;/GM_Earth>   &lt;GM_Sun>1.32712442076000e+20&lt;/GM_Sun>   &lt;GM_Moon>4.90280105600000e+12&lt;/GM_Moon>   &lt;GM_MERCURY>2.20320808280762e+13&lt;/GM_MERCURY>   &lt;GM_VENUS>3.24858603864143e+14&lt;/GM_VENUS>   &lt;GM_MARS>4.28283149222192e+13&lt;/GM_MARS>   &lt;GM_JUPITER>1.26712769822770e+17&lt;/GM_JUPITER>   &lt;GM_SATURN>3.79406266494906e+16&lt;/GM_SATURN>   &lt;TIME_EPSILON>1.0e-05&lt;/TIME_EPSILON>   &lt;DELTA_TAI_GPS>19&lt;/DELTA_TAI_GPS>   &lt;DELTA_TT_GPS>51.184&lt;/DELTA_TT_GPS>   &lt;J2000>51544.5&lt;/J2000>   &lt;leapSecond>     &lt;MJD>57754&lt;/MJD>     &lt;DELTA_UTC_GPS>-18&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   &lt;leapSecond>     &lt;MJD>57204&lt;/MJD>     &lt;DELTA_UTC_GPS>-17&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   &lt;leapSecond>     &lt;MJD>56109&lt;/MJD>     &lt;DELTA_UTC_GPS>-16&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   ...   &lt;leapSecond>     &lt;MJD>41317&lt;/MJD>     &lt;DELTA_UTC_GPS>9&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   &lt;leapSecond>     &lt;MJD>0&lt;/MJD>     &lt;DELTA_UTC_GPS>10&lt;/DELTA_UTC_GPS>   &lt;/leapSecond> &lt;/groops>', 'config_table': '', 'display_text': 'GROOPS uses some built-in constants like <code>DEFAULT_GM</code> or the definition of leap seconds, which are defined in  <code>source/base/constants.cpp</code>.</p><p>A complete list of the constants can be written to an XML file with: <pre>   groops --write-settings &lt;groopsDefaults.xml> </pre></p><p>The built-in constants can be overwritten by a <code>groopsDefaults.xml</code> file in the working directory or by explicitly passing the file as an argument at execution: <pre>   groops --settings &lt;groopsDefaults.xml> &lt;config.xml> </pre></p><p>It might also be useful to adjust the default values in the schema file used by the <a class="groops-ref" href="general.gui.html">GUI</a>: <pre>   groops --settings &lt;groopsDefaults.xml> --xsd &lt;groops.xsd> </pre></p><p>Example file: <pre> &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops>   &lt;LIGHT_VELOCITY>299792458&lt;/LIGHT_VELOCITY>   &lt;DEFAULT_GM>3.986004415e+14&lt;/DEFAULT_GM>   &lt;DEFAULT_R>6378136.3&lt;/DEFAULT_R>   &lt;GRS80_a>6378137.0&lt;/GRS80_a>   &lt;GRS80_f>298.2572221010&lt;/GRS80_f>   &lt;GRAVITATIONALCONSTANT>6.6730e-11&lt;/GRAVITATIONALCONSTANT>   &lt;R_Earth>6.37813630000000e+06&lt;/R_Earth>   &lt;R_Moon>1.73800000000000e+06&lt;/R_Moon>   &lt;GM_Earth>3.98600441500000e+14&lt;/GM_Earth>   &lt;GM_Sun>1.32712442076000e+20&lt;/GM_Sun>   &lt;GM_Moon>4.90280105600000e+12&lt;/GM_Moon>   &lt;GM_MERCURY>2.20320808280762e+13&lt;/GM_MERCURY>   &lt;GM_VENUS>3.24858603864143e+14&lt;/GM_VENUS>   &lt;GM_MARS>4.28283149222192e+13&lt;/GM_MARS>   &lt;GM_JUPITER>1.26712769822770e+17&lt;/GM_JUPITER>   &lt;GM_SATURN>3.79406266494906e+16&lt;/GM_SATURN>   &lt;TIME_EPSILON>1.0e-05&lt;/TIME_EPSILON>   &lt;DELTA_TAI_GPS>19&lt;/DELTA_TAI_GPS>   &lt;DELTA_TT_GPS>51.184&lt;/DELTA_TT_GPS>   &lt;J2000>51544.5&lt;/J2000>   &lt;leapSecond>     &lt;MJD>57754&lt;/MJD>     &lt;DELTA_UTC_GPS>-18&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   &lt;leapSecond>     &lt;MJD>57204&lt;/MJD>     &lt;DELTA_UTC_GPS>-17&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   &lt;leapSecond>     &lt;MJD>56109&lt;/MJD>     &lt;DELTA_UTC_GPS>-16&lt;/DELTA_UTC_GPS>   &lt;/leapSecond></p><p>  ...</p><p>  &lt;leapSecond>     &lt;MJD>41317&lt;/MJD>     &lt;DELTA_UTC_GPS>9&lt;/DELTA_UTC_GPS>   &lt;/leapSecond>   &lt;leapSecond>     &lt;MJD>0&lt;/MJD>     &lt;DELTA_UTC_GPS>10&lt;/DELTA_UTC_GPS>   &lt;/leapSecond> &lt;/groops> </pre>'},
'general.parallelization': { 'name': 'general.parallelization', 'key': 'general.parallelization', 'description': 'If GROOPS is compiled with the   (MPI), most GROOPS  programs  can be run in parallel on multiple processor cores. Processing on computer clusters with distributed memory is also supported. Many loops are parallelized by computing each loop step at a different core. Usually the first node distributes the work load, assigns loop steps to different cores, and is not participating on the actual loop computation. This means running GROOPS with only two nodes has no advantages in almost all cases. Non-parallel parts and  programs  without parallel support are executed at the first node only. Large systems of  normal equations , which are divided into blocks, are distributed over the nodes to reduce the memory consumption on each single node. As all nodes may read and write files (at least reading the  config files ) the required part of the file system must be available on all participating computers.', 'config_table': '', 'display_text': 'If GROOPS is compiled with the <a href="https://en.wikipedia.org/wiki/Message_Passing_Interface">Message Passing Interface</a> (MPI), most GROOPS <a class="groops-ref" href="programType.html">programs</a> can be run in parallel on multiple processor cores. Processing on computer clusters with distributed memory is also supported.</p><p>Many loops are parallelized by computing each loop step at a different core. Usually the first node distributes the work load, assigns loop steps to different cores, and is not participating on the actual loop computation. This means running GROOPS with only two nodes has no advantages in almost all cases. Non-parallel parts and <a class="groops-ref" href="programType.html">programs</a> without parallel support are executed at the first node only.</p><p>Large systems of <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a>, which are divided into blocks, are distributed over the nodes to reduce the memory consumption on each single node.</p><p>As all nodes may read and write files (at least reading the <a class="groops-ref" href="general.configFiles.html">config files</a>) the required part of the file system must be available on all participating computers.'},
'fundamentals.robustLeastSquares': { 'name': 'fundamentals.robustLeastSquares', 'key': 'fundamentals.robustLeastSquares', 'description': 'The robust least squares adjustment used in GROOPS is based on a modified Huber estimator. It downweights observations with large otuliers iteratively. The algorithm starts with a first solution with equal weights    The solution is used to compute the residuals  and the redundancies of all observations  For observations with large residuals a new standard deviation is assigned  where   is  huber ,   is  huberPower , and   a robust overall variance factor computed from all residuals. The estimation is repeated  huberMaxIteration  times with a new weight matrix   or until convergence is reached.', 'config_table': '', 'display_text': 'The robust least squares adjustment used in GROOPS is based on a modified Huber estimator. It downweights observations with large otuliers iteratively.</p><p>The algorithm starts with a first solution with equal weights $\\M P =\\M I$ \\[   \\hat{\\M x} = (\\M A^T\\M P\\M A)^{-1}\\M A^T\\M P\\M l. \\]The solution is used to compute the residuals \\[   \\hat{e}_i = \\left(\\M l - \\M A \\hat{\\M x}\\right)_i \\]and the redundancies of all observations \\[   r_i = \\left(\\M I - \\M A(\\M A^T\\M P\\M A)^{-1}\\M A^T\\M P\\right)_{ii}. \\]For observations with large residuals a new standard deviation is assigned \\[   \\sigma_i =   \\begin{cases}     1                                     & \\text{for } \\left|\\frac{\\hat{e}_i}{r_i}\\right| \\le h\\cdot\\hat{\\sigma} \\\\     \\left|\\frac{\\hat{e}_i}{r_ih}\\right|^p & \\text{for } \\left|\\frac{\\hat{e}_i}{r_i}\\right| > h\\cdot\\hat{\\sigma},   \\end{cases} \\]where $h$ is <strong class="groops-config-element">huber</strong>, $p$ is <strong class="groops-config-element">huberPower</strong>, and $\\hat{\\sigma}^2$ a robust overall variance factor computed from all residuals. The estimation is repeated <strong class="groops-config-element">huberMaxIteration</strong> times with a new weight matrix \\[   \\M P = \\text{diag}\\left(\\frac{1}{\\sigma_1^2}, \\frac{1}{\\sigma_2^2}, \\ldots, \\frac{1}{\\sigma_n^2}\\right) \\] or until convergence is reached.'},
'fundamentals.basisSplines': { 'name': 'fundamentals.basisSplines', 'key': 'fundamentals.basisSplines', 'description': 'A time variable function is given by  with the (spatial) coefficients   as parameters and the temporal basis functions  . Basis splines are defined as polynomials of degree   in intervals between nodal points in time  :    Block mean values ( )  Linear splines ( )  Quadratic splines ( )  Cubic splines ( )   where   is the normlized time in each time interval  The total number of coefficients   is  , where   is the count of nodal time points   and   is the degree.', 'config_table': '', 'display_text': 'A time variable function is given by \\[ f(x,t) =  \\sum_i f_i(x)\\Psi_i(t), \\]with the (spatial) coefficients $f_i(x)$ as parameters and the temporal basis functions $\\Psi_i(t)$. Basis splines are defined as polynomials of degree $n$ in intervals between nodal points in time $t_i$: <ul>  <li>Block mean values ($n=0$) \\[   \\Psi_i(t) = \\begin{cases}   1 & \\text{if } t\\in[t_i,t_{i+1}), \\\\   0 & \\text{otherwise} \\end{cases} \\]</li><li> Linear splines ($n=1$) \\[   \\Phi_i(t) = \\begin{cases}   \\tau_{i-1}   & \\text{if } t_{i-1}\\le t \\le t_i, \\\\   1-\\tau_i     & \\text{if } t_{i}\\le t \\le t_{i+1}, \\\\   0 & \\text{otherwise}. \\end{cases} \\]</li><li> Quadratic splines ($n=2$) \\[   \\Phi_i(t) = \\begin{cases}   \\frac{1}{2}\\tau^2_{i-1}   & \\text{if } t_{i-1}\\le t \\le t_i, \\\\   -\\tau^2_{i-1}+\\tau_{i-1}+\\frac{1}{2}     & \\text{if } t_{i}\\le t \\le t_{i+1}, \\\\   \\frac{1}{2}\\tau^2_{i-1}-\\tau_{i-1}+\\frac{1}{2}     & \\text{if } t_{i}\\le t \\le t_{i+1}, \\\\   0 & \\text{otherwise}. \\end{cases} \\]</li><li> Cubic splines ($n=3$) \\[   \\Phi_i(t) = \\begin{cases}    \\frac{1}{6}\\tau^3                                                        & \\text{if } t_{i-1}\\le t \\le t_i, \\\\   -\\frac{3}{6}\\tau^3 +\\frac{3}{6}\\tau^2 +\\frac{3}{6}\\tau  +\\frac{1}{6} & \\text{if } t_{i-1}\\le t \\le t_i, \\\\    \\frac{3}{6}\\tau^3 -            \\tau^2                     +\\frac{4}{6} & \\text{if } t_{i-1}\\le t \\le t_i, \\\\   -\\frac{1}{6}\\tau^3 +\\frac{3}{6}\\tau^2 -\\frac{3}{6}\\tau  +\\frac{1}{6} & \\text{if } t_{i-1}\\le t \\le t_i, \\\\   0 & \\text{otherwise}. \\end{cases} \\]</li></ul>  where $\\tau$ is the normlized time in each time interval \\[   \\tau_i = \\frac{t-t_i}{t_{i+1}-t_i}. \\]The total number of coefficients $f_i(x)$ is $N=N_t+n-1$, where $N_t$ is the count of nodal time points $t_i$ and $n$ is the degree.</p><p>'},
'fundamentals.autoregressiveModel': { 'name': 'fundamentals.autoregressiveModel', 'key': 'fundamentals.autoregressiveModel', 'description': 'A multivariate (or vector) autoregressive model is one possible representation of a random process. It specifies, that the output at epoch   depends on the   previous epochs, where   is denoted process order, plus a stochastic term. In the following, finite order vector autoregressive - VAR( ) in short - models as implemented in GROOPS will be described. A finite order VAR( ) model is defined as  where   are realizations of a random vector process Subtracting the right hand side and substituting the stochastic term   with the residual   gives us  which can be used as pseudo-observation equations in the determination of the parameters  . In matrix notation this reads  After rearranging the vectors   to have ascending time stamps  For practical purposes, the residuals above are further decorrelated using the inverse square root of the white noise covariance matrix, leading to  The used square root is in principle arbitrary, but should satisfy  . This means that both eigendecomposition based roots and Cholesky factors can be used. After the applying the matrix from the left, we arrive at the observation equations  which yields fully decorrelated residuals. Currenty, VAR( ) models are saved to a single  file which contains this matrix.', 'config_table': '', 'display_text': 'A multivariate (or vector) autoregressive model is one possible representation of a random process. It specifies, that the output at epoch $t$ depends on the $p$ previous epochs, where $p$ is denoted process order, plus a stochastic term. In the following, finite order vector autoregressive - VAR($p$) in short - models as implemented in GROOPS will be described.</p><p><h2>Definition</h2><p></p><p>A finite order VAR($p$) model is defined as \\[   \\mathbf{y}_e(t_i) = \\sum_{k=1}^p \\mathbf{\\Phi}^{(p)}_k\\mathbf{y}_e(t_{i-k}) + \\mathbf{w}(t_i),   \\hspace{5pt} \\mathbf{w}(t_i) \\sim \\mathcal{N}(0, \\mathbf{\\Sigma}^{(p)}_\\mathbf{w}), \\]where $\\mathbf{y}_e(t_i)$ are realizations of a random vector process Subtracting the right hand side and substituting the stochastic term $-\\mathbf{w}(t_i)$ with the residual $\\mathbf{v}(t_i)$ gives us \\[   \\mathbf{0}  = \\mathbf{y}_e(t_i) - \\sum_{k=1}^p \\mathbf{\\Phi}^{(p)}_k\\mathbf{y}_e(t_{i-k}) + \\mathbf{v}(t_i) \\]which can be used as pseudo-observation equations in the determination of the parameters $\\mathbf{y}_e(t_i)$. In matrix notation this reads \\[   0 =   \\begin{bmatrix}     \\mathbf{I} & -\\mathbf{\\Phi}^{(p)}_1 & \\cdots & -\\mathbf{\\Phi}^{(p)}_p \\\\   \\end{bmatrix}   \\begin{bmatrix}     \\mathbf{y}_e(t_i) \\\\     \\mathbf{y}_e(t_{i-1}) \\\\     \\vdots \\\\     \\mathbf{y}_e(t_{i-p}) \\\\   \\end{bmatrix}   + \\mathbf{v}(t_i). \\]After rearranging the vectors $\\mathbf{x}_t$ to have ascending time stamps \\[   0 =   \\begin{bmatrix}     -\\mathbf{\\Phi}^{(p)}_p & \\cdots & -\\mathbf{\\Phi}^{(p)}_1 & \\mathbf{I} \\\\   \\end{bmatrix}   \\begin{bmatrix}     \\mathbf{y}_e(t_{i-p}) \\\\     \\vdots \\\\     \\mathbf{y}_e(t_{i-1}) \\\\     \\mathbf{y}_e(t_i) \\\\   \\end{bmatrix}   + \\mathbf{v}(t_i) \\]For practical purposes, the residuals above are further decorrelated using the inverse square root of the white noise covariance matrix, leading to \\[   \\bar{\\mathbf{v}}(t_i) = \\underbrace{\\mathbf{\\Sigma}^{(p)^{-\\frac{1}{2}}}_\\mathbf{w}}_{=\\mathbf{W}}\\mathbf{v}(t_i), \\hspace{25pt}  \\bar{\\mathbf{v}}(t_i) \\sim \\mathcal{N}(0, \\mathbf{I}). \\]The used square root is in principle arbitrary, but should satisfy $\\mathbf{W}^T\\mathbf{W} = \\mathbf{\\Sigma}^{(p)}_\\mathbf{w} $. This means that both eigendecomposition based roots and Cholesky factors can be used. After the applying the matrix from the left, we arrive at the observation equations \\[   0 =   \\begin{bmatrix}     -\\mathbf{W}\\mathbf{\\Phi}^{(p)}_p & \\cdots & -\\mathbf{W}\\mathbf{\\Phi}^{(p)}_1 & \\mathbf{W} \\\\   \\end{bmatrix}   \\begin{bmatrix}     \\mathbf{y}_e(t_{i-p}) \\\\     \\vdots \\\\     \\mathbf{y}_e(t_{i-1}) \\\\     \\mathbf{y}_e(t_i) \\\\   \\end{bmatrix}   + \\bar{\\mathbf{v}}(t_i) \\]which yields fully decorrelated residuals. Currenty, VAR($p$) models are saved to a single  file which contains this matrix.'},
'cookbook.instrument': { 'name': 'cookbook.instrument', 'key': 'cookbook.instrument', 'description': 'GROOPS provides functions and programs to read/write, preprocess, analyze and visualize uniformly and non-uniformly sampled instrument data. This includes tools for filter design and analysis, re-sampling, smoothing, detrending, and power spectrum estimation. This tutorial goes through exemplary steps for data handling procedures.   GROOPS is able to read and convert relevant data from various LEO and GNSS satellites. Instrument files need to be converted into the respective GROOPS format using conversion programs.Depending on the content of the input file, the data is stored with a specific  section . User also has the option to change the type later on with  InstrumentSetType . Multiple files can be concatenated to one file using  InstrumentConcatenate . Using this program, it is also possible to sort the epochs, remove the duplicates and NaN values.  Example: Concatenating instrument files         Create three successively daily sinusoidal signals with  TimeSeriesCreate  and set their type to MISCVALUE with  InstrumentSetType . In this example, each data set has an overlap of 1 hour with their following dataset.    Merge all datasets to one single file with  InstrumentConcatenate .           Many measurements involve data collected asynchronously by multiple sensors with different sampling. Use  InstrumentSynchronize  for a continuous harmonization of the data over time or segmentation of the data into arcs.   Real-world data is often incomplete, inconsistent, and/or lacking in certain behaviors or trends, and is likely to contain many errors. Data preprocessing is a proven method of resolving such issues. Following steps are usually required to be taken:   Gross outlier removal:        Create reference values to compare the input data with. Depending on the instrument type, this can be done by simulation programs such as  SimulateAccelerometer  or  SimulateStarCamera . If no reference data is available, the outlier detection is based on the data itself. If needed, synchronize the reference data file and the input data with  InstrumentSynchronize .    In case of star camera data, compute the differences between the input data and the reference data with  InstrumentStarCameraMultiply .    Set a threshold for outlier detection in  InstrumentRemoveEpochsByCriteria . The threshold is defined empirically according to the accuracy characteristics of each data products. If the differences exceed a predefined threshold, the corresponding epochs are removed. An arbitrary margin can be defined to additionally remove epochs before and after the identified outliers. It is also possible to remove epochs at specific times using  InstrumentRemoveEpochsByTimes .    Missing epochs can be filled by reference data with  InstrumentConcatenate .    It is also possible to interpolate the missing epochs with  InstrumentResample .    Example: Removing outliers in a synthetic data.         Create a sinusoidal signal with an amplitude of 1.0 using  TimeSeriesCreate  and set its type to MISCVALUE with  InstrumentSetType .    Add zero-mean, white Gaussian noise with a standard deviation of 0.1 with  NoiseInstrument . Interpret this data as a real measurement file.    Set the threshold criteria to 0.2 in  InstrumentRemoveEpochsByCriteria  and remove the outliers and their nearest epochs in 20 second interval.    Fill the data gaps with  InstrumentResample .              Downsampling:        If the sampling is irregular use  InstrumentResample  to make the sampling equidistant.    Use  InstrumentSynchronize  to divide the data at gaps into arcs.    Apply a lowpass filter (e.g. Butterworth) with the Nyquist frequency of the target sampling as cutoff with  InstrumentFilter . Apply the filter in both directions to avoid phase shifts.    Use  InstrumentReduceSampling  to down-sample the data.    Calibration:        For a general instrument file,  InstrumentDetrend  subtracts offsets or linear/nonlinear trends from the input data. This can be achieved also with  FunctionsCalculate  or  InstrumentArcCalculate  by applying determined calibration factors or solving a least-square adjustment.    For accelerometer data,  InstrumentAccelerometerEstimateBiasScale  is designed to estimate and subtract complex biases or scales with respect to simulated accelerometer data. If a thruster file is given, the corresponding epochs are eliminated during estimation process.    Example: GRACE-C accelerometer calibration         For one particular date, read and convert Level-1B GRACE-C orbit, star camera, accelerometer, and thruster data with  GraceL1b2Orbit ,  GraceL1b2StarCamera ,  GraceL1b2Accelerometer , and  GraceL1b2Thruster  respectively. It is also required to read the macro-model data of the satellite using the related information in the official document and convert it to GROOPS format with  SatelliteModelCreate .    Use  SimulateAccelerometer  to generate simulated accelerations due to non-gravitational force models including:  section ,  section , and  section .    Calibrate the real measurements with a daily constant accelerometer bias by choosing a constant parameter per axis in  section .                  InstrumentStatisticsTimeSeries  returns statistics for one or more instrument files.  InstrumentArcCalculate  is also able to generate a  statistics  file with one mid epoch per arc.   Spectral analysis studies the frequency spectrum contained in discrete, uniformly sampled data. The Fourier transform is a tool that reveals frequency components of a signal by representing it in frequency space. The Power Spectral Density (PSD) is a measurement of the energy at each frequency.   If the sampling is irregular use  InstrumentResample  to make the sampling equidistant.  Use  Instrument2PowerSpectralDensity  to compute PSD.  If covariance function of a dataset is available, use  CovarianceFunction2PowerSpectralDensity .  Example: Spectral analysis of a synthetic signal.         Create a sinusoidal signal with an amplitude of 1.0 using  TimeSeriesCreate  and set its type to MISCVALUE with  InstrumentSetType . Interpret this data as a simulation data file.    Add zero-mean, white Gaussian noise with a standard deviation of 0.1 with  NoiseInstrument . Interpret this data as a real measurement file.    Compute PSD of the simulated and measurement data and represent the results with  PlotGraph .              Argument of latitude plot Plotting instrument data as a function of satellite position in orbit and time reveals features related to the orbit geometry or environmental conditions. For circular orbits, the position of  satellite can be specified by the argument of latitude.    Synchronize the instrument data file with the related orbit data using  InstrumentSynchronize .  Use  Orbit2ArgumentOfLatitude  to compute argument of latitude at each epoch.  Plot the instrument data versus argument of latitude and time with  PlotGraph .  Example: Argument of latitude representation of GRACE-C eclipse factors         Compute eclipse factors at each epoch of GRACE-C orbit at an arbitrary time using  Orbit2EclipseFactor .    Synchronize the eclipse factor data file with the related orbit data using  InstrumentSynchronize .    Use  Orbit2ArgumentOfLatitude  to compute argument of latitude at each epoch and visualize the results with  PlotGraph .          Ground-track plot Plotting instrument data with respect to the satellite ground track is useful to identify any features of geophysical origin in the data.    Synchronize the instrument data file with the related orbit data using  InstrumentSynchronize .  Use  Orbit2Groundtracks  to map instrument data to satellite ground-track.  Visualize the output with  PlotMap .  Example 6: Ground-track representation of GRACE-C eclipse factors         Compute eclipse factors at each epoch of GRACE-C orbit at an arbitrary time using  Orbit2EclipseFactor .    Synchronize the eclipse factor data file with the related orbit data using  InstrumentSynchronize .    Use  Orbit2Groundtracks  to generate the gridded data. Each grid value represents the mean value of eclipse factor over the instrument time period (1 month).  visualize the results with  PlotMap .', 'config_table': '', 'display_text': '</p><p>GROOPS provides functions and programs to read/write, preprocess, analyze and visualize uniformly and non-uniformly sampled instrument data. This includes tools for filter design and analysis, re-sampling, smoothing, detrending, and power spectrum estimation. This tutorial goes through exemplary steps for data handling procedures.</p><p><h2>Reading data</h2><p></p><p><ul>  <li>GROOPS is able to read and convert relevant data from various LEO and GNSS satellites. Instrument files need to be converted into the respective GROOPS format using conversion programs.Depending on the content of the input file, the data is stored with a specific <a class="groops-class" href="instrumentTypeType.html">instrument type</a>. User also has the option to change the type later on with <a class="groops-program" href="InstrumentSetType.html">InstrumentSetType</a>.</p><p></li><li> Multiple files can be concatenated to one file using <a class="groops-program" href="InstrumentConcatenate.html">InstrumentConcatenate</a>. Using this program, it is also possible to sort the epochs, remove the duplicates and NaN values. </li><li> <em>Example: Concatenating instrument files</em>   <ul>    </li><li> Create three successively daily sinusoidal signals with <a class="groops-program" href="TimeSeriesCreate.html">TimeSeriesCreate</a> and set their type to MISCVALUE with <a class="groops-program" href="InstrumentSetType.html">InstrumentSetType</a>. In this example, each data set has an overlap of 1 hour with their following dataset.   </li><li> Merge all datasets to one single file with <a class="groops-program" href="InstrumentConcatenate.html">InstrumentConcatenate</a>.      </li></ul>   <li>Many measurements involve data collected asynchronously by multiple sensors with different sampling. Use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a> for a continuous harmonization of the data over time or segmentation of the data into arcs. </li></ul> </p><p><h2>Preprocessing</h2><p> Real-world data is often incomplete, inconsistent, and/or lacking in certain behaviors or trends, and is likely to contain many errors. Data preprocessing is a proven method of resolving such issues. Following steps are usually required to be taken:</p><p><ul>  <li>Gross outlier removal:   <ul>    </li><li> Create reference values to compare the input data with. Depending on the instrument type, this can be done by simulation programs such as <a class="groops-program" href="SimulateAccelerometer.html">SimulateAccelerometer</a> or <a class="groops-program" href="SimulateStarCamera.html">SimulateStarCamera</a>. If no reference data is available, the outlier detection is based on the data itself. If needed, synchronize the reference data file and the input data with <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.</p><p>  </li><li> In case of star camera data, compute the differences between the input data and the reference data with <a class="groops-program" href="InstrumentStarCameraMultiply.html">InstrumentStarCameraMultiply</a>.</p><p>  </li><li> Set a threshold for outlier detection in <a class="groops-program" href="InstrumentRemoveEpochsByCriteria.html">InstrumentRemoveEpochsByCriteria</a>. The threshold is defined empirically according to the accuracy characteristics of each data products. If the differences exceed a predefined threshold, the corresponding epochs are removed. An arbitrary margin can be defined to additionally remove epochs before and after the identified outliers. It is also possible to remove epochs at specific times using <a class="groops-program" href="InstrumentRemoveEpochsByTimes.html">InstrumentRemoveEpochsByTimes</a>.   </li><li> Missing epochs can be filled by reference data with <a class="groops-program" href="InstrumentConcatenate.html">InstrumentConcatenate</a>.   </li><li> It is also possible to interpolate the missing epochs with <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a>.   </li><li> <em>Example: Removing outliers in a synthetic data.</em>   <ul>    </li><li> Create a sinusoidal signal with an amplitude of 1.0 using <a class="groops-program" href="TimeSeriesCreate.html">TimeSeriesCreate</a> and set its type to MISCVALUE with <a class="groops-program" href="InstrumentSetType.html">InstrumentSetType</a>.   </li><li> Add zero-mean, white Gaussian noise with a standard deviation of 0.1 with <a class="groops-program" href="NoiseInstrument.html">NoiseInstrument</a>. Interpret this data as a real measurement file.   </li><li> Set the threshold criteria to 0.2 in <a class="groops-program" href="InstrumentRemoveEpochsByCriteria.html">InstrumentRemoveEpochsByCriteria</a> and remove the outliers and their nearest epochs in 20 second interval.   </li><li> Fill the data gaps with <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a>.      </li></ul>    </ul></p><p> <li>Downsampling:   <ul>    </li><li> If the sampling is irregular use <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a> to make the sampling equidistant.   </li><li> Use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a> to divide the data at gaps into arcs.   </li><li> Apply a lowpass filter (e.g. Butterworth) with the Nyquist frequency of the target sampling as cutoff with <a class="groops-program" href="InstrumentFilter.html">InstrumentFilter</a>. Apply the filter in both directions to avoid phase shifts.   </li><li> Use <a class="groops-program" href="InstrumentReduceSampling.html">InstrumentReduceSampling</a> to down-sample the data.   </li></ul> </p><p><li>Calibration:   <ul>    </li><li> For a general instrument file, <a class="groops-program" href="InstrumentDetrend.html">InstrumentDetrend</a> subtracts offsets or linear/nonlinear trends from the input data. This can be achieved also with <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a> or <a class="groops-program" href="InstrumentArcCalculate.html">InstrumentArcCalculate</a> by applying determined calibration factors or solving a least-square adjustment.   </li><li> For accelerometer data, <a class="groops-program" href="InstrumentAccelerometerEstimateBiasScale.html">InstrumentAccelerometerEstimateBiasScale</a> is designed to estimate and subtract complex biases or scales with respect to simulated accelerometer data. If a thruster file is given, the corresponding epochs are eliminated during estimation process.   </li><li> <em>Example: GRACE-C accelerometer calibration</em>   <ul>    </li><li> For one particular date, read and convert Level-1B GRACE-C orbit, star camera, accelerometer, and thruster data with <a class="groops-program" href="GraceL1b2Orbit.html">GraceL1b2Orbit</a>, <a class="groops-program" href="GraceL1b2StarCamera.html">GraceL1b2StarCamera</a>, <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>, and <a class="groops-program" href="GraceL1b2Thruster.html">GraceL1b2Thruster</a> respectively. It is also required to read the macro-model data of the satellite using the related information in the official document and convert it to GROOPS format with <a class="groops-program" href="SatelliteModelCreate.html">SatelliteModelCreate</a>.   </li><li> Use <a class="groops-program" href="SimulateAccelerometer.html">SimulateAccelerometer</a> to generate simulated accelerations due to non-gravitational force models including: <a class="groops-class" href="miscAccelerationsType.html#atmosphericDrag">miscAccelerations:atmosphericDrag</a>, <a class="groops-class" href="miscAccelerationsType.html#solarRadiationPressure">miscAccelerations:solarRadiationPressure</a>, and <a class="groops-class" href="miscAccelerationsType.html#albedo">miscAccelerations:albedo</a>.   </li><li> Calibrate the real measurements with a daily constant accelerometer bias by choosing a constant parameter per axis in <a class="groops-class" href="parametrizationAccelerationType.html#accBias">parametrizationAcceleration:accBias</a>.      </li></ul>    </ul> </ul></p><p><h2>Statistical analysis</h2><p> <ul>  <li><a class="groops-program" href="InstrumentStatisticsTimeSeries.html">InstrumentStatisticsTimeSeries</a> returns statistics for one or more instrument files. <a class="groops-program" href="InstrumentArcCalculate.html">InstrumentArcCalculate</a> is also able to generate a <strong class="groops-config-element">statistics</strong> file with one mid epoch per arc. </li></ul> </p><p><h2>Spectral analysis</h2><p> Spectral analysis studies the frequency spectrum contained in discrete, uniformly sampled data. The Fourier transform is a tool that reveals frequency components of a signal by representing it in frequency space. The Power Spectral Density (PSD) is a measurement of the energy at each frequency.</p><p><ul>  <li>If the sampling is irregular use <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a> to make the sampling equidistant. </li><li> Use <a class="groops-program" href="Instrument2PowerSpectralDensity.html">Instrument2PowerSpectralDensity</a> to compute PSD. </li><li> If covariance function of a dataset is available, use <a class="groops-program" href="CovarianceFunction2PowerSpectralDensity.html">CovarianceFunction2PowerSpectralDensity</a>. </li><li> <em>Example: Spectral analysis of a synthetic signal.</em>   <ul>    </li><li> Create a sinusoidal signal with an amplitude of 1.0 using <a class="groops-program" href="TimeSeriesCreate.html">TimeSeriesCreate</a> and set its type to MISCVALUE with <a class="groops-program" href="InstrumentSetType.html">InstrumentSetType</a>. Interpret this data as a simulation data file.   </li><li> Add zero-mean, white Gaussian noise with a standard deviation of 0.1 with <a class="groops-program" href="NoiseInstrument.html">NoiseInstrument</a>. Interpret this data as a real measurement file.   </li><li> Compute PSD of the simulated and measurement data and represent the results with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.      </li></ul>  </ul></p><p><h2>Data visualization</h2><p> <ul>  <li>Argument of latitude plot Plotting instrument data as a function of satellite position in orbit and time reveals features related to the orbit geometry or environmental conditions. For circular orbits, the position of  satellite can be specified by the argument of latitude. <ul>  </li><li> Synchronize the instrument data file with the related orbit data using <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>. </li><li> Use <a class="groops-program" href="Orbit2ArgumentOfLatitude.html">Orbit2ArgumentOfLatitude</a> to compute argument of latitude at each epoch. </li><li> Plot the instrument data versus argument of latitude and time with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>. </li><li> <em>Example: Argument of latitude representation of GRACE-C eclipse factors</em>   <ul>    </li><li> Compute eclipse factors at each epoch of GRACE-C orbit at an arbitrary time using <a class="groops-program" href="Orbit2EclipseFactor.html">Orbit2EclipseFactor</a>.   </li><li> Synchronize the eclipse factor data file with the related orbit data using <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.   </li><li> Use <a class="groops-program" href="Orbit2ArgumentOfLatitude.html">Orbit2ArgumentOfLatitude</a> to compute argument of latitude at each epoch and visualize the results with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.      </li></ul>  </ul></p><p><li>Ground-track plot Plotting instrument data with respect to the satellite ground track is useful to identify any features of geophysical origin in the data. <ul>  </li><li> Synchronize the instrument data file with the related orbit data using <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>. </li><li> Use <a class="groops-program" href="Orbit2Groundtracks.html">Orbit2Groundtracks</a> to map instrument data to satellite ground-track. </li><li> Visualize the output with <a class="groops-program" href="PlotMap.html">PlotMap</a>. </li><li> <em>Example 6: Ground-track representation of GRACE-C eclipse factors</em>   <ul>    </li><li> Compute eclipse factors at each epoch of GRACE-C orbit at an arbitrary time using <a class="groops-program" href="Orbit2EclipseFactor.html">Orbit2EclipseFactor</a>.   </li><li> Synchronize the eclipse factor data file with the related orbit data using <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.   </li><li> Use <a class="groops-program" href="Orbit2Groundtracks.html">Orbit2Groundtracks</a> to generate the gridded data. Each grid value represents the mean value of eclipse factor over the instrument time period (1 month).  visualize the results with <a class="groops-program" href="PlotMap.html">PlotMap</a>.   </li></ul>     </ul></p><p></ul>'},
'cookbook.gnssNetwork': { 'name': 'cookbook.gnssNetwork', 'key': 'cookbook.gnssNetwork', 'description': 'This cookbook chapter describes an example of global GNSS processing as done by analysis centers of the International GNSS Service (IGS). Resulting products usually comprise:      Satellite orbits, clocks, and signal biases    Station positions, clocks, signal biases, and troposphere estimates    Earth orientation parameters  Scientific details about the underlying processing approach and the applied parametrizations, models, and corrections can be found in a doctoral thesis available under DOI  . An example scenario for this task is available at  https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssNetwork.zip . It includes GROOPS scripts and data for the example, but not the general GROOPS data and metadata found at  https://ftp.tugraz.at/outgoing/ITSG/groops  (data folder or zipped archive). The scenario generally represents what is described in this cookbook, but may slightly differ in certain settings. Note: Global GNSS processing can become very computationally intensive. Depending on the number of satellites and stations, the observation and processing sampling, and parametrizations it can quickly exceed the capabilities of a normal desktop computer and may require computer clusters or number crunchers (see section   Parallelization ).  Most of the required metadata files are provided in GROOPS file formats at  https://ftp.tugraz.at/outgoing/ITSG/groops . These files are regularly updated. Data that has to be gathered from other sources comprises:      Receiver observations : GNSS measurements converted from RINEX format (see  RinexObservation2GnssReceiver ).    Approximate orbits : broadcast or precise orbits in CRF for orbit integration (see  GnssRinexNavigation2OrbitClock  or  Sp3Format2Orbit ).    Approximate clocks : broadcast or precise clocks (see  GnssRinexNavigation2OrbitClock  or  GnssClockRinex2InstrumentClock )   Receiver observations, broadcast ephemerides, and precise satellite orbits and clocks can be downloaded from the  . GPS, GLONASS, and Galileo orbits and clocks for the period 1994-2020 are also available as part of  . The   includes a small set of this data. The script  010groopsConvert.xml  can be used to convert these external formats into GROOPS formats. Prepare a  station list file  that contains the stations to be processed. Each line can contain more than one station. The first station in each line that has data available is used for the processing. If your network contains more than 60-70 stations, it is recommended to start processing with a core network (see  Advanced ). In this case, define an additional  core station list file  that can also have multiple stations per line.  Numerical integration of the satellite orbits is the first step in global GNSS processing. Dynamic orbits are integrated based on  section  and then fitted to the approximate orbits by estimating their initial state and additional empirical parameters for solar radiation pressure to improve the orbit fit. The resulting  variational equations  file contains the integrated orbit, derivatives with respect to the satellite state vector, attitude, Earth rotation and satellite model. Orbit preprocessing is covered by the script  020groopsGnssPreprocessing.xml  in the  . It is recommended to perform the steps below in a  loop  over all satellites/PRNs using  LoopPrograms .     GnssPrn2SvnBlockVariables     InstrumentResample : resample approximate orbits from  data preparation  to target sampling (e.g., 1 minute) by defining a  section  based on a  method:polynomial  ( polynomialDegree = 7 ,  maxDataPointRange = 7200 ,  maxExtrapolationDistance = 900 ).    OrbitAddVelocityAndAcceleration : add velocity via running polynomial ( polynomialDegree = 2 ) derivation (needed for attitude computation)    SimulateStarCameraGnss     PreprocessingVariationalEquation :                      section = {groopsDataDir}/gnss/transmitter/satelliteModel/satelliteModel_boxWing.{svn}.xml             section : the resampled approximate orbit from  InstrumentResample             section : the attitude file from  SimulateStarCameraGnss             forces : see below            section : a static gravity field (e.g. GOCO06s) with  maxDegree = 4 .              PreprocessingVariationalEquationOrbitFit : fit the integrated orbit ( section ) to the approximate orbit ( section ) by least squares adjustment.         Add  section          and select the   parameters to be estimated.  Force models usually include:      section :         static gravity field (e.g. GOCO06s)    section           section :           trend component of time-variable gravity field (e.g. GOCO06s)        section           section :           annual cosine component of time-variable gravity field (e.g. GOCO06s)      section :           annual sine component of time-variable gravity field (e.g. GOCO06s)        section : astronomical tides (e.g. based on JPL ephemeris)    section : Earth tide (IERS conventions)    section : ocean tides (e.g. FES 2014b)    section : pole tides (IERS conventions)    section : ocean pole tides (IERS conventions)    section :         solar radiation pressure (box-wing model)    section : Earth radiation pressure (albedo model)    section :         antenna thrust (e.g. from IGS metadata SINEX file)    section :         relativistic effects (IERS conventions)   For the spherical harmonics expansions a  maxDegree = 60  is more than enough. The result of the preprocessing should be a  variational equations file , a  reduced dynamic orbit file  from  PreprocessingVariationalEquationOrbitFit  and an  attitude file  from  SimulateStarCameraGnss  for each satellite.  The script  030groopsGnssProcessing.xml  in the   implements the following steps and settings. These are the settings for  GnssProcessing . If not otherwise stated use the default values. The first step is setting the processing sampling, in this example it is 30 seconds. The processing interval usually is a single 24-hour day, therefore define  section  with  timeStart = &lt;mjd> ,  timeEnd = &lt;mjd>+1 ,  sampling = 30/86400  (processing sampling). Add the appropriate  section  (e.g. GPS, GLONASS, and Galileo) and provide the required files:      section  from  preprocessing     section  from  preprocessing     section  from  data preparation   The following settings are needed in  section :       section : list of all stations to be processed     section : The converted RINEX observation files.     section : Use the settings described in  receiver:stationNetwork .     section : Signals you might want to exclude are  C*?G  (old unknown GPS code observations),  *3*R  (GLONASS G3 freq.),  *6*E  (Galileo E6 freq.).  Add the following  section  and define the  outputfiles  you are interested in inside each of them:      section : add a constraint of  sigmaSTEC = 40     section : add  section          with linear ( degree = 1 ) 2-hourly splines    section : optionally change  section  to  section  with  name = G*  to align clocks to mean over GPS (instead of all) satellites    section     section     section     section     section : time-variable GPS L5 phase bias with  section = L5*G          and  section  with degree 3 and hourly nodes.    section     section : select  section          with the appropriate vmf3grid file. Add  section          with linear ( degree = 1 ) 2-hourly splines         and  section  with linear daily splines.    section :         provide  section = preprocessing/variational.{prn}.dat          from the preprocessing step.         Add  section  and          section  parameter at center of day to further improve orbit fit.    section                       section : polar motion            section  polar motion rate                 (at center of day with  timeStep = 1 )            section : length of day (at center of day with                  timeStep = -1  to match IGS sign convention)                section : loose constraint on GPS L5 phase biases,          section = signalBias.L5* ,  sigma = 5  meters, and  relativeToApriori = yes       section : loose constraint troposphere estimates,          section = troposphere* ,  sigma = 5  meters, and  relativeToApriori = yes       section : constraint on stochastic pulses,          section = stochasticPulse* ,  sigma = 0.1  micrometers/second.  Finally, define the  section . This can be overwhelming at first, but offers a lot of flexibility. The example script uses a 5-minute processing sampling with subsequent clock densification to 30 seconds.         section : with  nthEpoch = 10  to reduce sampling to 5 minutes.        section :             disable  constraint.STEC ,  *VTEC ,  *.tecBiases  as the ionosphere parameters are estimated in the final steps only.        section : with  maxIterationCount = 6         section         section :             enable  *  (all) parameters        section : with  maxIterationCount = 4 : final iterations (with 5-minute sampling) and ionosphere parameters        section : clock densification to 30-second sampling                      section : with  nthEpoch = 1  to set full 30-second sampling              section :             disable  *  (all) parameters and reenable  *.clock*  and  *.STEC  parameters              section : with  maxIterationCount = 6               section : with  suffix = 30s  to write 30-second clock files                section : write the final results  With some additional steps, the full 30-second sampling can be used to estimate all parameters (not only the clocks). These steps are disabled in the example script, as they require at least 16 GB of system memory. In this case, it is not necessary to separately write the 30-second clock files as listed above.         section : with  nthEpoch = 1  to set full 30-second sampling        section : As the system of normal       equations can be very large, the memory consumption might be reduced with  keepEpochNormalsinMemory = no .       In this case the epoch parameters are directly eliminated during the accumulation and reconstructed in the solving step.       This might lead to longer computation times.        section : with  maxIterationCount = 2 : final iterations with full sampling  Processing large station networks requires some additional steps to keep the computational load to a reasonable degree. The general processing strategy is to first process a well-distributed subset of stations (i.e. a core network) to get good estimates of all satellite parameters, which then enables integer ambiguity resolution (IAR). Once the ambiguities of the core network are resolved and stable estimates for satellite phase biases are available, all other (non-core) stations can be processed individually (including IAR) while keeping the satellite parameters fixed. At last, all stations can be processed together with all satellite parameters and ionosphere parameters. Let\'s start with the  section  of the core network:          section  with  section        using the core network station list file from  data preparation  as  section .        section : with  nthEpoch = 10  to reduce sampling to 5 minutes.        section :             disable  constraint.STEC ,  *VTEC ,  *.tecBiases  as the ionosphere parameters are estimated in the final steps only.        section : with  maxIterationCount = 6         section         section : with  maxIterationCount = 4 : final iterations (with 5-minute sampling)  Now all other (non-core) stations can be processed separately:          section :             with  section  inside  section              using the station list from the core network above to process all non-core stations individually with fixed transmitter parameters                section : with  maxIterationCount = 6         section         section : with  maxIterationCount = 4           Next all stations are processed together with all parameters:          section : with  section         section : with  nthEpoch = 1  to set full 30-second sampling        section : clock densification to 30-second sampling                      section :             disable  *  (all) parameters and reenable  *.clock*  and  *.STEC  parameters              section : with  maxIterationCount = 6                 section : enable  *  (all) parameters.        section : with  keepEpochNormalsinMemory = no         section : with  maxIterationCount = 4 : final iterations with full sampling and all parameters        section : write the final results', 'config_table': '', 'display_text': 'This cookbook chapter describes an example of global GNSS processing as done by analysis centers of the International GNSS Service (IGS). Resulting products usually comprise: <ul>    <li>Satellite orbits, clocks, and signal biases   </li><li> Station positions, clocks, signal biases, and troposphere estimates   </li><li> Earth orientation parameters </li></ul> </p><p>Scientific details about the underlying processing approach and the applied parametrizations, models, and corrections can be found in a doctoral thesis available under DOI <a href="https://doi.org/10.3217/978-3-85125-885-1">10.3217/978-3-85125-885-1</a>.</p><p>An example scenario for this task is available at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssNetwork.zip" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssNetwork.zip</a>. It includes GROOPS scripts and data for the example, but not the general GROOPS data and metadata found at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a> (data folder or zipped archive). The scenario generally represents what is described in this cookbook, but may slightly differ in certain settings.</p><p><em>Note: Global GNSS processing can become very computationally intensive. Depending on the number of satellites and stations, the observation and processing sampling, and parametrizations it can quickly exceed the capabilities of a normal desktop computer and may require computer clusters or number crunchers (see section</em> <a class="groops-ref" href="general.parallelization.html">Parallelization</a><em>).</em></p><p><h2 id="metadata">Data preparation</h2><p> Most of the required metadata files are provided in GROOPS file formats at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a>. These files are regularly updated.</p><p>Data that has to be gathered from other sources comprises: <ul>    <li><b>Receiver observations</b>: GNSS measurements converted from RINEX format (see <a class="groops-program" href="RinexObservation2GnssReceiver.html">RinexObservation2GnssReceiver</a>).   </li><li> <b>Approximate orbits</b>: broadcast or precise orbits in CRF for orbit integration (see <a class="groops-program" href="GnssRinexNavigation2OrbitClock.html">GnssRinexNavigation2OrbitClock</a> or <a class="groops-program" href="Sp3Format2Orbit.html">Sp3Format2Orbit</a>).   </li><li> <b>Approximate clocks</b>: broadcast or precise clocks (see <a class="groops-program" href="GnssRinexNavigation2OrbitClock.html">GnssRinexNavigation2OrbitClock</a> or <a class="groops-program" href="GnssClockRinex2InstrumentClock.html">GnssClockRinex2InstrumentClock</a>) </li></ul>  Receiver observations, broadcast ephemerides, and precise satellite orbits and clocks can be downloaded from the <a href="https://igs.org/data-products-overview/">IGS Data Centers</a>. GPS, GLONASS, and Galileo orbits and clocks for the period 1994-2020 are also available as part of <a href="https://doi.org/10.3217/dataset-4528-0723-0867">Graz University of Technology\'s contribution to IGS repro3</a>.</p><p>The <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssNetwork.zip">example scenario</a> includes a small set of this data. The script <code>010groopsConvert.xml</code> can be used to convert these external formats into GROOPS formats.</p><p>Prepare a <a class="groops-file" href="fileFormat_stringTable.html">station list file</a> that contains the stations to be processed. Each line can contain more than one station. The first station in each line that has data available is used for the processing. If your network contains more than 60-70 stations, it is recommended to start processing with a core network (see <a class="groops-ref" href="cookbook.gnssNetwork.html#advanced">Advanced</a>). In this case, define an additional <a class="groops-file" href="fileFormat_stringTable.html">core station list file</a> that can also have multiple stations per line.</p><p><h2 id="orbitIntegration">Preprocessing: Orbit integration</h2><p> Numerical integration of the satellite orbits is the first step in global GNSS processing. Dynamic orbits are integrated based on <a class="groops-class" href="forcesType.html">force models</a> and then fitted to the approximate orbits by estimating their initial state and additional empirical parameters for solar radiation pressure to improve the orbit fit. The resulting <a class="groops-file" href="fileFormat_variationalEquation.html">variational equations</a> file contains the integrated orbit, derivatives with respect to the satellite state vector, attitude, Earth rotation and satellite model.</p><p>Orbit preprocessing is covered by the script <code>020groopsGnssPreprocessing.xml</code> in the <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssNetwork.zip">example scenario</a>.</p><p>It is recommended to perform the steps below in a <a class="groops-ref" href="general.loopsAndConditions.html">loop</a> over all satellites/PRNs using <a class="groops-program" href="LoopPrograms.html">LoopPrograms</a>.</p><p><ul>    <li><a class="groops-program" href="GnssPrn2SvnBlockVariables.html">GnssPrn2SvnBlockVariables</a>   </li><li> <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a>: resample approximate orbits from <a class="groops-ref" href="cookbook.gnssPpp.html#metadata">data preparation</a> to target sampling (e.g., 1 minute) by defining a <a class="groops-class" href="timeSeriesType.html">timeSeries</a> based on a <strong class="groops-config-element">method:polynomial</strong> (<strong class="groops-config-element">polynomialDegree</strong>=<code>7</code>, <strong class="groops-config-element">maxDataPointRange</strong>=<code>7200</code>, <strong class="groops-config-element">maxExtrapolationDistance</strong>=<code>900</code>).   </li><li> <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a>: add velocity via running polynomial (<strong class="groops-config-element">polynomialDegree</strong>=<code>2</code>) derivation (needed for attitude computation)   </li><li> <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a>   </li><li> <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a>:         <ul>            </li><li> <a class="groops-class" href="fileFormat_satelliteModel.html">inputfileSatelliteModel</a>=<code>{groopsDataDir}/gnss/transmitter/satelliteModel/satelliteModel_boxWing.{svn}.xml</code>           </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>: the resampled approximate orbit from <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a>           </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>: the attitude file from <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a>           </li><li> <strong class="groops-config-element">forces</strong>: see below           </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gradientfield:potentialCoefficients</a>: a static gravity field (e.g. GOCO06s) with <strong class="groops-config-element">maxDegree</strong>=<code>4</code>.         </li></ul>    <li><a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>: fit the integrated orbit (<a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a>) to the approximate orbit (<a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>) by least squares adjustment.         Add <a class="groops-class" href="parametrizationAccelerationType.html#gnssSolarRadiation">parametrizationAcceleration:gnssSolarRadiation</a>         and select the <a href="https://doi.org/10.1007/s00190-015-0814-4">ECOM2</a> parameters to be estimated. </li></ul> </p><p>Force models usually include: <ul>    <li><a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>:         static gravity field (e.g. GOCO06s)   </li><li> <a class="groops-class" href="gravityfieldType.html#trend">gravityfield:trend</a>   <ul>      </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>:           trend component of time-variable gravity field (e.g. GOCO06s)   </li></ul>    <li><a class="groops-class" href="gravityfieldType.html#oscillation">gravityfield:oscillation</a>   <ul>      </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfieldCos:potentialCoefficients</a>:           annual cosine component of time-variable gravity field (e.g. GOCO06s)     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfieldSin:potentialCoefficients</a>:           annual sine component of time-variable gravity field (e.g. GOCO06s)   </li></ul>    <li><a class="groops-class" href="tidesType.html#astronomicalTide">tides:astronomicalTide</a>: astronomical tides (e.g. based on JPL ephemeris)   </li><li> <a class="groops-class" href="tidesType.html#earthTide">tides:earthTide</a>: Earth tide (IERS conventions)   </li><li> <a class="groops-class" href="tidesType.html#doodsonHarmonicTide">tides:doodsonHarmonicTide</a>: ocean tides (e.g. FES 2014b)   </li><li> <a class="groops-class" href="tidesType.html#poleTide">tides:poleTide</a>: pole tides (IERS conventions)   </li><li> <a class="groops-class" href="tidesType.html#oceanPoleTide">tides:poleOceanTide</a>: ocean pole tides (IERS conventions)   </li><li> <a class="groops-class" href="miscAccelerationsType.html#solarRadiationPressure">miscAccelerations:solarRadiationPressure</a>:         solar radiation pressure (box-wing model)   </li><li> <a class="groops-class" href="miscAccelerationsType.html#albedo">miscAccelerations:albedo</a>: Earth radiation pressure (albedo model)   </li><li> <a class="groops-class" href="miscAccelerationsType.html#antennaThrust">miscAccelerations:antennaThrust</a>:         antenna thrust (e.g. from IGS metadata SINEX file)   </li><li> <a class="groops-class" href="miscAccelerationsType.html#relativisticEffect">miscAccelerations:relativisticEffect</a>:         relativistic effects (IERS conventions) </li></ul>  For the spherical harmonics expansions a <strong class="groops-config-element">maxDegree</strong>=<code>60</code> is more than enough.</p><p>The result of the preprocessing should be a <a class="groops-file" href="fileFormat_variationalEquation.html">variational equations file</a>, a <a class="groops-file" href="fileFormat_instrument.html">reduced dynamic orbit file</a> from <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a> and an <a class="groops-file" href="fileFormat_instrument.html">attitude file</a> from <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a> for each satellite.</p><p><h2 id="processing">GNSS processing</h2><p> The script <code>030groopsGnssProcessing.xml</code> in the <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssNetwork.zip">example scenario</a> implements the following steps and settings.</p><p>These are the settings for <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. If not otherwise stated use the default values.</p><p>The first step is setting the processing sampling, in this example it is 30 seconds. The processing interval usually is a single 24-hour day, therefore define <a class="groops-class" href="timeSeriesType.html#uniformSampling">timeSeries:uniformSampling</a> with <strong class="groops-config-element">timeStart</strong>=<code>&lt;mjd></code>, <strong class="groops-config-element">timeEnd</strong>=<code>&lt;mjd>+1</code>, <strong class="groops-config-element">sampling</strong>=<code>30/86400</code> (processing sampling).</p><p>Add the appropriate <a class="groops-class" href="gnssTransmitterGeneratorType.html#gnss">transmitters:gnss</a> (e.g. GPS, GLONASS, and Galileo) and provide the required files: <ul>    <li><a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> from <a class="groops-ref" href="cookbook.gnssNetwork.html#orbitIntegration">preprocessing</a>   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileAttitude</a> from <a class="groops-ref" href="cookbook.gnssNetwork.html#orbitIntegration">preprocessing</a>   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileClock</a> from <a class="groops-ref" href="cookbook.gnssPpp.html#metadata">data preparation</a> </li></ul> </p><p>The following settings are needed in <a class="groops-class" href="gnssReceiverGeneratorType.html#stationNetwork">receiver:stationNetwork</a>: <ul>     <li><a class="groops-class" href="fileFormat_stringTable.html">inputfileStationList</a>: list of all stations to be processed    </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileObservations</a>: The converted RINEX observation files.    </li><li> <a class="groops-class" href="tidesType.html">tidalDisplacement</a>: Use the settings described in <a class="groops-ref" href="gnssReceiverGeneratorType.html#stationNetwork">receiver:stationNetwork</a>.    </li><li> <a class="groops-class" href="gnssType.html">excludeType</a>: Signals you might want to exclude are <code>C*?G</code> (old unknown GPS code observations), <code>*3*R</code> (GLONASS G3 freq.), <code>*6*E</code> (Galileo E6 freq.). </li></ul> </p><p>Add the following <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a> and define the <strong class="groops-config-element">outputfiles</strong> you are interested in inside each of them: <ul>    <li><a class="groops-class" href="gnssParametrizationType.html#ionosphereSTEC">ionosphereSTEC</a>: add a constraint of <strong class="groops-config-element">sigmaSTEC</strong>=<code>40</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#ionosphereMap">ionosphereMap</a>: add <a class="groops-class" href="parametrizationTemporalType.html#splines">temporal:splines</a>         with linear (<strong class="groops-config-element">degree</strong>=<code>1</code>) 2-hourly splines   </li><li> <a class="groops-class" href="gnssParametrizationType.html#clocks">clocks</a>: optionally change <a class="groops-class" href="platformSelectorType.html">selectTransmitterZeroMeans</a> to <a class="groops-class" href="platformSelectorType.html#wildcard">wildcard</a> with <strong class="groops-config-element">name</strong>=<code>G*</code> to align clocks to mean over GPS (instead of all) satellites   </li><li> <a class="groops-class" href="gnssParametrizationType.html#signalBiases">signalBiases</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#ambiguities">ambiguities</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#codeBiases">codeBiases</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#tecBiases">tecBiases</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#temporalBias">temporalBias</a>: time-variable GPS L5 phase bias with <a class="groops-class" href="gnssType.html">type</a>=<code>L5*G</code>         and <a class="groops-class" href="parametrizationTemporalType.html#splines">parametrizationTemporal:splines</a> with degree 3 and hourly nodes.   </li><li> <a class="groops-class" href="gnssParametrizationType.html#staticPositions">staticPositions</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#troposphere">troposphere</a>: select <a class="groops-class" href="troposphereType.html#viennaMapping">troposphere:viennaMapping</a>         with the appropriate vmf3grid file. Add <a class="groops-class" href="parametrizationTemporalType.html#splines">troposphereWetEstimation:splines</a>         with linear (<strong class="groops-config-element">degree</strong>=<code>1</code>) 2-hourly splines         and <a class="groops-class" href="parametrizationTemporalType.html#splines">troposphereGradientEstimation:splines</a> with linear daily splines.   </li><li> <a class="groops-class" href="gnssParametrizationType.html#transmitterDynamicOrbits">transmitterDynamicOrbit</a>:         provide <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a>=<code>preprocessing/variational.{prn}.dat</code>         from the preprocessing step.         Add <a class="groops-class" href="parametrizationAccelerationType.html#gnssSolarRadiation">parametrizationAcceleration:gnssSolarRadiation</a> and         <a class="groops-class" href="timeSeriesType.html#irregular">stochasticPulse:irregular</a> parameter at center of day to further improve orbit fit.   </li><li> <a class="groops-class" href="gnssParametrizationType.html#earthRotation">earthRotation</a>         <ul>            </li><li> <a class="groops-class" href="parametrizationTemporalType.html#constant">estimatePole:constant</a>: polar motion           </li><li> <a class="groops-class" href="parametrizationTemporalType.html#trend">estimatePole:trend</a> polar motion rate                 (at center of day with <strong class="groops-config-element">timeStep</strong>=<code>1</code>)           </li><li> <a class="groops-class" href="parametrizationTemporalType.html#trend">estimateUT1:trend</a>: length of day (at center of day with                 <strong class="groops-config-element">timeStep</strong>=<code>-1</code> to match IGS sign convention)         </li></ul>      <li><a class="groops-class" href="gnssParametrizationType.html#constraints">constraints</a>: loose constraint on GPS L5 phase biases,         <a class="groops-class" href="parameterSelectorType.html#wildcard">parameters:wildcard:type</a>=<code>signalBias.L5*</code>, <strong class="groops-config-element">sigma</strong>=<code>5</code> meters, and <strong class="groops-config-element">relativeToApriori</strong>=<code>yes</code>     </li><li> <a class="groops-class" href="gnssParametrizationType.html#constraints">constraints</a>: loose constraint troposphere estimates,         <a class="groops-class" href="parameterSelectorType.html#wildcard">parameters:wildcard:type</a>=<code>troposphere*</code>, <strong class="groops-config-element">sigma</strong>=<code>5</code> meters, and <strong class="groops-config-element">relativeToApriori</strong>=<code>yes</code>     </li><li> <a class="groops-class" href="gnssParametrizationType.html#constraints">constraints</a>: constraint on stochastic pulses,         <a class="groops-class" href="parameterSelectorType.html#wildcard">parameters:wildcard:type</a>=<code>stochasticPulse*</code>, <strong class="groops-config-element">sigma</strong>=<code>0.1</code> micrometers/second. </li></ul> </p><p>Finally, define the <a class="groops-class" href="gnssProcessingStepType.html">processingSteps</a>. This can be overwhelming at first, but offers a lot of flexibility. The example script uses a 5-minute processing sampling with subsequent clock densification to 30 seconds.</p><p><ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">selectEpochs</a>: with <strong class="groops-config-element">nthEpoch</strong>=<code>10</code> to reduce sampling to 5 minutes.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>:             disable <code>constraint.STEC</code>, <code>*VTEC</code>, <code>*.tecBiases</code> as the ionosphere parameters are estimated in the final steps only.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>6</code>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">resolveAmbiguities</a>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>:             enable <code>*</code> (all) parameters       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>4</code>: final iterations (with 5-minute sampling) and ionosphere parameters       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#group">group</a>: clock densification to 30-second sampling       <ul>              </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">selectEpochs</a>: with <strong class="groops-config-element">nthEpoch</strong>=<code>1</code> to set full 30-second sampling             </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>:             disable <code>*</code> (all) parameters and reenable <code>*.clock*</code> and <code>*.STEC</code> parameters             </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>6</code>             </li><li> <a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a>: with <strong class="groops-config-element">suffix</strong>=<code>30s</code> to write 30-second clock files       </li></ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a>: write the final results </li></ul> </p><p>With some additional steps, the full 30-second sampling can be used to estimate all parameters (not only the clocks). These steps are disabled in the example script, as they require at least 16 GB of system memory. In this case, it is not necessary to separately write the 30-second clock files as listed above.</p><p><ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">selectEpochs</a>: with <strong class="groops-config-element">nthEpoch</strong>=<code>1</code> to set full 30-second sampling       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectNormalsBlockStructure">selectNormalsBlockStructure</a>: As the system of normal       equations can be very large, the memory consumption might be reduced with <strong class="groops-config-element">keepEpochNormalsinMemory</strong>=<code>no</code>.       In this case the epoch parameters are directly eliminated during the accumulation and reconstructed in the solving step.       This might lead to longer computation times.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>2</code>: final iterations with full sampling </li></ul> </p><p><h2 id="advanced">Advanced: Processing large station networks</h2><p></p><p>Processing large station networks requires some additional steps to keep the computational load to a reasonable degree. The general processing strategy is to first process a well-distributed subset of stations (i.e. a core network) to get good estimates of all satellite parameters, which then enables integer ambiguity resolution (IAR). Once the ambiguities of the core network are resolved and stable estimates for satellite phase biases are available, all other (non-core) stations can be processed individually (including IAR) while keeping the satellite parameters fixed. At last, all stations can be processed together with all satellite parameters and ionosphere parameters.</p><p>Let\'s start with the <a class="groops-class" href="gnssProcessingStepType.html">processingSteps</a> of the core network: <ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#selectReceivers">selectReceivers</a> with <a class="groops-class" href="platformSelectorType.html#file">selectReceivers:file</a>       using the core network station list file from <a class="groops-ref" href="cookbook.gnssPpp.html#metadata">data preparation</a> as <a class="groops-class" href="fileFormat_stringTable.html">inputfileStringTable</a>.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">selectEpochs</a>: with <strong class="groops-config-element">nthEpoch</strong>=<code>10</code> to reduce sampling to 5 minutes.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>:             disable <code>constraint.STEC</code>, <code>*VTEC</code>, <code>*.tecBiases</code> as the ionosphere parameters are estimated in the final steps only.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>6</code>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">resolveAmbiguities</a>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>4</code>: final iterations (with 5-minute sampling) </li></ul> </p><p>Now all other (non-core) stations can be processed separately: <ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#forEachReceiverSeparately">forEachReceiverSeparately</a>:             with <a class="groops-class" href="platformSelectorType.html#file">selectReceivers:file</a> inside <a class="groops-class" href="platformSelectorType.html#exclude">selectReceivers:exclude</a>             using the station list from the core network above to process all non-core stations individually with fixed transmitter parameters       <ul>        </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">processingStep:estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>6</code>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">processingStep:resolveAmbiguities</a>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">processingStep:estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>4</code>       </li></ul>  </ul></p><p>Next all stations are processed together with all parameters: <ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#selectReceivers">selectReceivers</a>: with <a class="groops-class" href="platformSelectorType.html#all">selectReceivers:all</a>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">selectEpochs</a>: with <strong class="groops-config-element">nthEpoch</strong>=<code>1</code> to set full 30-second sampling       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#group">group</a>: clock densification to 30-second sampling       <ul>              </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>:             disable <code>*</code> (all) parameters and reenable <code>*.clock*</code> and <code>*.STEC</code> parameters             </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>6</code>       </li></ul>        <li><a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>: enable <code>*</code> (all) parameters.       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#selectNormalsBlockStructure">selectNormalsBlockStructure</a>: with <strong class="groops-config-element">keepEpochNormalsinMemory</strong>=<code>no</code>       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>4</code>: final iterations with full sampling and all parameters       </li><li> <a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a>: write the final results </li></ul> </p><p>'},
'cookbook.gnssPpp': { 'name': 'cookbook.gnssPpp', 'key': 'cookbook.gnssPpp', 'description': 'This cookbook chapter describes an example of GNSS precise point positioning (PPP) for a ground station using GPS, GLONASS, and Galileo. For information on how to generate the GNSS products (orbits, clocks, signal biases, etc.) required for PPP, see the cookbook  GNSS satellite orbit determination and station network analysis . Scientific details about the underlying processing approach and the applied parametrizations, models, and corrections can be found in a doctoral thesis available under DOI  . An example scenario for this task is available at  https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssPPP.zip . It includes GROOPS scripts and data for the example, but not the general GROOPS data and metadata found at  https://ftp.tugraz.at/outgoing/ITSG/groops  (data folder or zipped archive). The scenario generally represents what is described in this cookbook, but may slightly differ in certain settings.  Most of the required metadata files are provided in GROOPS file formats at  https://ftp.tugraz.at/outgoing/ITSG/groops . These files are regularly updated. Data that has to be gathered from other sources comprises:      Receiver observations : GNSS measurements converted from RINEX format (see  RinexObservation2GnssReceiver )    Precise orbits : precise orbits in CRF for orbit integration (see  Sp3Format2Orbit )    Precise clocks : precise clocks (see  GnssClockRinex2InstrumentClock )    Attitude : rotation from body frame to CRF (see  SimulateStarCameraGnss  or  GnssOrbex2StarCamera )    Signal biases : code (and phase) biases (see  GnssSinexBias2SignalBias )   Receiver observations, precise satellite orbits and clocks, and possibly attitude and signal biases can be downloaded from the  . GPS, GLONASS, and Galileo orbits, clocks, attitude, and signal biases for the period 1994-2020 are also available as part of  . The   includes a small set of this data. The script  010groopsConvert.xml  can be used to convert these external formats into GROOPS formats. Prepare a  station list file  that contains the stations (one per line) to be processed.  The script  02groopsGnssProcessing.xml  in the   implements the following steps and settings. These are the settings for  GnssProcessing . If not otherwise stated use the default values. The first step is setting the processing sampling, in this example it is 30 seconds. The processing interval usually is a single 24-hour day,  section  with  timeStart = &lt;mjd> ,  timeEnd = &lt;mjd>+1 ,  sampling = 30/86400  (processing sampling). Add the appropriate  section  (e.g. GPS, GLONASS, and Galileo) and provide the required files (from  Data preparation ):      section     section     section   The following settings are needed in  section :       section : list of all stations to be processed     section : The converted RINEX observation file.     section : Use the settings described in  receiver:stationNetwork .     section : We recommend to explicitly specify the signals to be processed             and to make sure that at least transmitter code biases are provided for each of them, e.g.  C1CG ,              C1WG ,  C2WG ,  L1*G ,  L2*G , ...).     section : Signals you might want to exclude are  L5*G  (GPS L5 phase due to time-variable bias on block IIF satellites),  *3*R  (GLONASS G3 freq.),  *6*E  (Galileo E6 freq.)  Add the following  section  and define the  outputfiles  you are interested in inside each of them:      section : add a constraint of  sigmaSTEC = 40     section     section : delete  section     section : provide  section  from          Data preparation .    section : if precise transmitter phase biases are available you can delete  section     section : delete  section , set  sigmaZeroMeanConstraint = 0     section : delete  section , set  sigmaZeroMeanConstraint = 0     section     section : select  section          with the appropriate vmf3grid file. Add  section          with linear ( degree = 1 ) 2-hourly splines         and  section  with linear daily splines.    section : loose constraint troposphere estimates,          section = troposphere* ,  sigma = 5 , and  relativeToApriori = yes   Add the following  section :      section : with  maxIterationCount = 8     section     section : with  maxIterationCount = 2     section   When processing multiple stations at the same time, moving  section  and  section  into the processing step  section  sets up and solves the normal equations independently for each station.', 'config_table': '', 'display_text': 'This cookbook chapter describes an example of GNSS precise point positioning (PPP) for a ground station using GPS, GLONASS, and Galileo. For information on how to generate the GNSS products (orbits, clocks, signal biases, etc.) required for PPP, see the cookbook <a class="groops-ref" href="cookbook.gnssNetwork.html">GNSS satellite orbit determination and station network analysis</a>.</p><p>Scientific details about the underlying processing approach and the applied parametrizations, models, and corrections can be found in a doctoral thesis available under DOI <a href="https://doi.org/10.3217/978-3-85125-885-1">10.3217/978-3-85125-885-1</a>.</p><p>An example scenario for this task is available at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssPPP.zip" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssPPP.zip</a>. It includes GROOPS scripts and data for the example, but not the general GROOPS data and metadata found at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a> (data folder or zipped archive). The scenario generally represents what is described in this cookbook, but may slightly differ in certain settings.</p><p><h2 id="metadata">Data preparation</h2><p> Most of the required metadata files are provided in GROOPS file formats at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a>. These files are regularly updated.</p><p>Data that has to be gathered from other sources comprises: <ul>    <li><b>Receiver observations</b>: GNSS measurements converted from RINEX format (see <a class="groops-program" href="RinexObservation2GnssReceiver.html">RinexObservation2GnssReceiver</a>)   </li><li> <b>Precise orbits</b>: precise orbits in CRF for orbit integration (see <a class="groops-program" href="Sp3Format2Orbit.html">Sp3Format2Orbit</a>)   </li><li> <b>Precise clocks</b>: precise clocks (see <a class="groops-program" href="GnssClockRinex2InstrumentClock.html">GnssClockRinex2InstrumentClock</a>)   </li><li> <b>Attitude</b>: rotation from body frame to CRF (see <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a> or <a class="groops-program" href="GnssOrbex2StarCamera.html">GnssOrbex2StarCamera</a>)   </li><li> <b>Signal biases</b>: code (and phase) biases (see <a class="groops-program" href="GnssSinexBias2SignalBias.html">GnssSinexBias2SignalBias</a>) </li></ul>  Receiver observations, precise satellite orbits and clocks, and possibly attitude and signal biases can be downloaded from the <a href="https://igs.org/data-products-overview/">IGS Data Centers</a>. GPS, GLONASS, and Galileo orbits, clocks, attitude, and signal biases for the period 1994-2020 are also available as part of <a href="https://doi.org/10.3217/dataset-4528-0723-0867">Graz University of Technology\'s contribution to IGS repro3</a>.</p><p>The <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssPPP.zip">example scenario</a> includes a small set of this data. The script <code>010groopsConvert.xml</code> can be used to convert these external formats into GROOPS formats.</p><p>Prepare a <a class="groops-file" href="fileFormat_stringList.html">station list file</a> that contains the stations (one per line) to be processed.</p><p><h2 id="processing">Processing of a ground station</h2><p> The script <code>02groopsGnssProcessing.xml</code> in the <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGnssPPP.zip">example scenario</a> implements the following steps and settings.</p><p>These are the settings for <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. If not otherwise stated use the default values.</p><p>The first step is setting the processing sampling, in this example it is 30 seconds. The processing interval usually is a single 24-hour day, <a class="groops-class" href="timeSeriesType.html#uniformSampling">timeSeries:uniformSampling</a> with <strong class="groops-config-element">timeStart</strong>=<code>&lt;mjd></code>, <strong class="groops-config-element">timeEnd</strong>=<code>&lt;mjd>+1</code>, <strong class="groops-config-element">sampling</strong>=<code>30/86400</code> (processing sampling).</p><p>Add the appropriate <a class="groops-class" href="gnssTransmitterGeneratorType.html#gnss">transmitters:gnss</a> (e.g. GPS, GLONASS, and Galileo) and provide the required files (from <a class="groops-ref" href="cookbook.gnssPpp.html#metadata">Data preparation</a>): <ul>    <li><a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileAttitude</a>   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileClock</a> </li></ul> </p><p>The following settings are needed in <a class="groops-class" href="gnssReceiverGeneratorType.html#stationNetwork">receiver:stationNetwork</a>: <ul>     <li><a class="groops-class" href="fileFormat_stringList.html">inputfileStationList</a>: list of all stations to be processed    </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileObservations</a>: The converted RINEX observation file.    </li><li> <a class="groops-class" href="tidesType.html">tidalDisplacement</a>: Use the settings described in <a class="groops-ref" href="gnssReceiverGeneratorType.html#stationNetwork">receiver:stationNetwork</a>.    </li><li> <a class="groops-class" href="gnssType.html">useType</a>: We recommend to explicitly specify the signals to be processed             and to make sure that at least transmitter code biases are provided for each of them, e.g. <code>C1CG</code>,             <code>C1WG</code>, <code>C2WG</code>, <code>L1*G</code>, <code>L2*G</code>, ...).    </li><li> <a class="groops-class" href="gnssType.html">excludeType</a>: Signals you might want to exclude are <code>L5*G</code> (GPS L5 phase due to time-variable bias on block IIF satellites), <code>*3*R</code> (GLONASS G3 freq.), <code>*6*E</code> (Galileo E6 freq.) </li></ul> </p><p>Add the following <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a> and define the <strong class="groops-config-element">outputfiles</strong> you are interested in inside each of them: <ul>    <li><a class="groops-class" href="gnssParametrizationType.html#ionosphereSTEC">ionosphereSTEC</a>: add a constraint of <strong class="groops-config-element">sigmaSTEC</strong>=<code>40</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#ionosphereVTEC">ionosphereVTEC</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#clocks">clocks</a>: delete <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#signalBiases">signalBiases</a>: provide <a class="groops-class" href="fileFormat_gnssSignalBias.html">inputfileSignalBiasTransmitter</a> from         <a class="groops-ref" href="cookbook.gnssPpp.html#metadata">Data preparation</a>.   </li><li> <a class="groops-class" href="gnssParametrizationType.html#ambiguities">ambiguities</a>: if precise transmitter phase biases are available you can delete <a class="groops-class" href="platformSelectorType.html">estimateTransmitterPhaseBiases</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#codeBiases">codeBiases</a>: delete <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>, set <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>=<code>0</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#tecBiases">tecBiases</a>: delete <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>, set <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>=<code>0</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#kinematicPositions">kinematicPositions</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#troposphere">troposphere</a>: select <a class="groops-class" href="troposphereType.html#viennaMapping">troposphere:viennaMapping</a>         with the appropriate vmf3grid file. Add <a class="groops-class" href="parametrizationTemporalType.html#splines">troposphereWetEstimation:splines</a>         with linear (<strong class="groops-config-element">degree</strong>=<code>1</code>) 2-hourly splines         and <a class="groops-class" href="parametrizationTemporalType.html#splines">troposphereGradientEstimation:splines</a> with linear daily splines.   </li><li> <a class="groops-class" href="gnssParametrizationType.html#constraints">constraints</a>: loose constraint troposphere estimates,         <a class="groops-class" href="parameterSelectorType.html#wildcard">parameters:wildcard:type</a>=<code>troposphere*</code>, <strong class="groops-config-element">sigma</strong>=<code>5</code>, and <strong class="groops-config-element">relativeToApriori</strong>=<code>yes</code> </li></ul> </p><p>Add the following <a class="groops-class" href="gnssProcessingStepType.html">processingSteps</a>: <ul>    <li><a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>8</code>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">resolveAmbiguities</a>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>2</code>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a> </li></ul> </p><p>When processing multiple stations at the same time, moving <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a> and <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">resolveAmbiguities</a> into the processing step <a class="groops-class" href="gnssProcessingStepType.html#forEachReceiverSeparately">forEachReceiverSeparately</a> sets up and solves the normal equations independently for each station.</p><p>'},
'cookbook.kinematicOrbit': { 'name': 'cookbook.kinematicOrbit', 'key': 'cookbook.kinematicOrbit', 'description': 'This cookbook chapter describes exemplarily the steps for determining kinematic orbits of low-Earth orbit (LEO) satellites. An example scenario for this task is available at  https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioLeoKinematicOrbit.zip . It includes GROOPS scripts and data for the example, but not the general GROOPS data and metadata found at  https://ftp.tugraz.at/outgoing/ITSG/groops  (data folder or zipped archive). The scenario generally represents what is described in this cookbook, but may slightly differ in certain settings.  Most of the required metadata files are provided in GROOPS file formats at  https://ftp.tugraz.at/outgoing/ITSG/groops . These files are regularly updated. Data that has to be gathered from other sources comprises:      Receiver observations : GNSS measurements converted from RINEX format (see  RinexObservation2GnssReceiver )    Precise orbits : precise orbits in CRF for orbit integration (see  Sp3Format2Orbit )    Precise clocks : precise clocks (see  GnssClockRinex2InstrumentClock )    Attitude : rotation from body frame to CRF (see  SimulateStarCameraGnss  or  GnssOrbex2StarCamera )    Signal biases : code (and phase) biases (see  GnssSinexBias2SignalBias )   Receiver observations, precise satellite orbits and clocks, and possibly attitude and signal biases can be downloaded from the  . GPS, GLONASS, and Galileo orbits, clocks, attitude, and signal biases for the period 1994-2020 are also available as part of  . The   includes a small set of this data. The script  010groopsConvert.xml  can be used to convert these external formats into GROOPS formats.  Metadata for several LEO missions is availabe at  https://ftp.tugraz.at/outgoing/ITSG/groops/data/gnss/receiverLowEarthOrbiter . If you want to process another mission, you can create the necessary files with these steps:      For creating the  GnssSatelliteInfo file  use  PlatformCreate . Note that the rotation from the   satellite reference frame into the antenna reference frame, as well as the change of the center of mass due to fuel consumption, has to be considered here.    The  GnssReceiverDefinition file  can be created by using  GnssReceiverDefinitionCreate . Here you can specify which GNSS signal types the receiver observes.    For creating the  GnssAntennaDefinition file use  GnssAntennaDefinitionCreate . Here you can define phase center offsets for the antenna.    For determining the elevation dependent accuracies the program  GnssAntennaDefinitionCreate  is used again.          antenna : set to new      Set the  pattern s for code ( type = C** ) and phase     ( type = L** ). The standard deviation is expressed e.g. with  values = 0.001/cos(2*PI/180*zenith) .       The   includes a small set of this data for the GRACE-FO mission. The script  020groopsConvertGracefo.xml  can be used to convert these external formats into GROOPS formats. The data preparation steps are:      Conversion of the approximate orbit and star camera data into GROOPS format using a conversion program.    If no attitude data is given the star camera data can be simulated by using  SimulateStarCamera  or  SimulateStarCameraSentinel1 .    The GNSS observation data (given in RINEX format) can be converted with  RinexObservation2GnssReceiver .    Suitable programs to get daily data are  InstrumentConcatenate  and  InstrumentSynchronize .    For interpolating the orbit and star camera data to GNSS receiver epochs use  InstrumentResample  and provide the converted RINEX observation file as input for    section .    For synchronizing these data use  InstrumentSynchronize .   Detailed description of instrument data handling can be found in  Instrument data handling .  The script  03groopsGnssProcessing.xml  in the   implements the following steps and settings. These are the settings for  GnssProcessing . If not otherwise stated use the default values. As we have only one receiver the processing sampling can be directly taken from the observation file:  section . Add the appropriate  section  (e.g. GPS) and provide the required files (from  Prepare GNSS satellite data ):      section     section     section   The following files (from  Prepare LEO metadata  and  Prepare LEO data ) and settings are needed in  section :       section : The satellite info file.     section      section      section      section : The converted RINEX observation file.     section : The approximate orbit.     section : The convered or simulated attitude.     section : We recommend to explicitly specify the signals to be processed             and to make sure that at least transmitter code biases are provided for each of them, e.g.  C1CG ,              C1WG ,  C2WG ,  L1*G ,  L2*G , ...).  Add the following  section  and define the  outputfiles  within you are interested in:      section : add a constraint of  sigmaSTEC = 40     section :         set  mapR = 6371e3+450e3  to satellite height and ionosphere height  mapH = 50e3  above.    section : delete  section     section : provide  section  created with  GnssSinexBias2SignalBias     section : if precise transmitter phase biases are available you can delete  section     section : delete  section , set  sigmaZeroMeanConstraint = 0     section : delete  section , set  sigmaZeroMeanConstraint = 0     section   Add the following  section :      section : with  maxIterationCount = 8     section     section : with  maxIterationCount = 2     section     section', 'config_table': '', 'display_text': 'This cookbook chapter describes exemplarily the steps for determining kinematic orbits of low-Earth orbit (LEO) satellites.</p><p>An example scenario for this task is available at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioLeoKinematicOrbit.zip" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioLeoKinematicOrbit.zip</a>. It includes GROOPS scripts and data for the example, but not the general GROOPS data and metadata found at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a> (data folder or zipped archive). The scenario generally represents what is described in this cookbook, but may slightly differ in certain settings.</p><p><h2 id="gnssMetadata">Prepare GNSS satellite data</h2><p> Most of the required metadata files are provided in GROOPS file formats at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a>. These files are regularly updated.</p><p>Data that has to be gathered from other sources comprises: <ul>    <li><b>Receiver observations</b>: GNSS measurements converted from RINEX format (see <a class="groops-program" href="RinexObservation2GnssReceiver.html">RinexObservation2GnssReceiver</a>)   </li><li> <b>Precise orbits</b>: precise orbits in CRF for orbit integration (see <a class="groops-program" href="Sp3Format2Orbit.html">Sp3Format2Orbit</a>)   </li><li> <b>Precise clocks</b>: precise clocks (see <a class="groops-program" href="GnssClockRinex2InstrumentClock.html">GnssClockRinex2InstrumentClock</a>)   </li><li> <b>Attitude</b>: rotation from body frame to CRF (see <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a> or <a class="groops-program" href="GnssOrbex2StarCamera.html">GnssOrbex2StarCamera</a>)   </li><li> <b>Signal biases</b>: code (and phase) biases (see <a class="groops-program" href="GnssSinexBias2SignalBias.html">GnssSinexBias2SignalBias</a>) </li></ul>  Receiver observations, precise satellite orbits and clocks, and possibly attitude and signal biases can be downloaded from the <a href="https://igs.org/data-products-overview/">IGS Data Centers</a>. GPS, GLONASS, and Galileo orbits, clocks, attitude, and signal biases for the period 1994-2020 are also available as part of <a href="https://doi.org/10.3217/dataset-4528-0723-0867">Graz University of Technology\'s contribution to IGS repro3</a>.</p><p>The <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioLeoKinematicOrbit.zip">example scenario</a> includes a small set of this data. The script <code>010groopsConvert.xml</code> can be used to convert these external formats into GROOPS formats.</p><p><h2 id="leoMetadata">Prepare LEO metadata</h2><p> Metadata for several LEO missions is availabe at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/data/gnss/receiverLowEarthOrbiter" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/data/gnss/receiverLowEarthOrbiter</a>.</p><p>If you want to process another mission, you can create the necessary files with these steps: <ul>    <li>For creating the <a class="groops-file" href="fileFormat_platform.html">GnssSatelliteInfo file</a> use <a class="groops-program" href="PlatformCreate.html">PlatformCreate</a>. Note that the rotation from the   satellite reference frame into the antenna reference frame, as well as the change of the center of mass due to fuel consumption, has to be considered here.   </li><li> The <a class="groops-file" href="fileFormat_gnssReceiverDefinition.html">GnssReceiverDefinition file</a> can be created by using <a class="groops-program" href="GnssReceiverDefinitionCreate.html">GnssReceiverDefinitionCreate</a>. Here you can specify which GNSS signal types the receiver observes.   </li><li> For creating the <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">GnssAntennaDefinition file</a> use <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>. Here you can define phase center offsets for the antenna.   </li><li> For determining the elevation dependent accuracies the program <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a> is used again.   <ul>      </li><li> <strong class="groops-config-element">antenna</strong>: set to new     </li><li> Set the <strong class="groops-config-element">pattern</strong>s for code (<strong class="groops-config-element">type</strong>=<code>C**</code>) and phase     (<strong class="groops-config-element">type</strong>=<code>L**</code>). The standard deviation is expressed e.g. with <strong class="groops-config-element">values</strong>=<code>0.001/cos(2*PI/180*zenith)</code>.   </li></ul>  </ul></p><p><h2 id="leoData">Prepare LEO data</h2><p> The <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioLeoKinematicOrbit.zip">example scenario</a> includes a small set of this data for the GRACE-FO mission. The script <code>020groopsConvertGracefo.xml</code> can be used to convert these external formats into GROOPS formats.</p><p>The data preparation steps are: <ul>    <li>Conversion of the approximate orbit and star camera data into GROOPS format using a conversion program.   </li><li> If no attitude data is given the star camera data can be simulated by using <a class="groops-program" href="SimulateStarCamera.html">SimulateStarCamera</a> or <a class="groops-program" href="SimulateStarCameraSentinel1.html">SimulateStarCameraSentinel1</a>.   </li><li> The GNSS observation data (given in RINEX format) can be converted with <a class="groops-program" href="RinexObservation2GnssReceiver.html">RinexObservation2GnssReceiver</a>.   </li><li> Suitable programs to get daily data are <a class="groops-program" href="InstrumentConcatenate.html">InstrumentConcatenate</a> and <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.   </li><li> For interpolating the orbit and star camera data to GNSS receiver epochs use <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a> and provide the converted RINEX observation file as input for   <a class="groops-class" href="timeSeriesType.html#instrument">timeSeries:instrument</a>.   </li><li> For synchronizing these data use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>. </li></ul>  Detailed description of instrument data handling can be found in <a class="groops-ref" href="cookbook.instrument.html">Instrument data handling</a>.</p><p><h2 id="processing">Estimate kinematic orbits</h2><p> The script <code>03groopsGnssProcessing.xml</code> in the <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioLeoKinematicOrbit.zip">example scenario</a> implements the following steps and settings.</p><p>These are the settings for <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. If not otherwise stated use the default values.</p><p>As we have only one receiver the processing sampling can be directly taken from the observation file: <a class="groops-class" href="timeSeriesType.html#instrument">timeSeries:instrument</a>.</p><p>Add the appropriate <a class="groops-class" href="gnssTransmitterGeneratorType.html#gnss">transmitters:gnss</a> (e.g. GPS) and provide the required files (from <a class="groops-ref" href="cookbook.kinematicOrbit.html#gnssMetadata">Prepare GNSS satellite data</a>): <ul>    <li><a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileAttitude</a>   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileClock</a> </li></ul> </p><p>The following files (from <a class="groops-ref" href="cookbook.kinematicOrbit.html#leoMetadata">Prepare LEO metadata</a> and <a class="groops-ref" href="cookbook.kinematicOrbit.html#leoData">Prepare LEO data</a>) and settings are needed in <a class="groops-class" href="gnssReceiverGeneratorType.html#lowEarthOrbiter">receiver:lowEarthOrbiter</a>: <ul>     <li><a class="groops-class" href="fileFormat_platform.html">inputfileStationInfo</a>: The satellite info file.    </li><li> <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a>    </li><li> <a class="groops-class" href="fileFormat_gnssReceiverDefinition.html">inputfileReceiverDefinition</a>    </li><li> <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAccuracyDefinition</a>    </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileObservations</a>: The converted RINEX observation file.    </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>: The approximate orbit.    </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>: The convered or simulated attitude.    </li><li> <a class="groops-class" href="gnssType.html">useType</a>: We recommend to explicitly specify the signals to be processed             and to make sure that at least transmitter code biases are provided for each of them, e.g. <code>C1CG</code>,             <code>C1WG</code>, <code>C2WG</code>, <code>L1*G</code>, <code>L2*G</code>, ...). </li></ul> </p><p>Add the following <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a> and define the <strong class="groops-config-element">outputfiles</strong> within you are interested in: <ul>    <li><a class="groops-class" href="gnssParametrizationType.html#ionosphereSTEC">ionosphereSTEC</a>: add a constraint of <strong class="groops-config-element">sigmaSTEC</strong>=<code>40</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#ionosphereVTEC">ionosphereVTEC</a>:         set <strong class="groops-config-element">mapR</strong>=<code>6371e3+450e3</code> to satellite height and ionosphere height <strong class="groops-config-element">mapH</strong>=<code>50e3</code> above.   </li><li> <a class="groops-class" href="gnssParametrizationType.html#clocks">clocks</a>: delete <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#signalBiases">signalBiases</a>: provide <a class="groops-class" href="fileFormat_gnssSignalBias.html">inputfileSignalBiasTransmitter</a> created with <a class="groops-program" href="GnssSinexBias2SignalBias.html">GnssSinexBias2SignalBias</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#ambiguities">ambiguities</a>: if precise transmitter phase biases are available you can delete <a class="groops-class" href="platformSelectorType.html">estimateTransmitterPhaseBiases</a>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#codeBiases">codeBiases</a>: delete <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>, set <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>=<code>0</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#tecBiases">tecBiases</a>: delete <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>, set <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>=<code>0</code>   </li><li> <a class="groops-class" href="gnssParametrizationType.html#kinematicPositions">kinematicPositions</a> </li></ul> </p><p>Add the following <a class="groops-class" href="gnssProcessingStepType.html">processingSteps</a>: <ul>    <li><a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>8</code>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">resolveAmbiguities</a>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: with <strong class="groops-config-element">maxIterationCount</strong>=<code>2</code>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#computeCovarianceMatrix">computeCovarianceMatrix</a>   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a> </li></ul> </p><p>'},
'cookbook.gravityFieldPod': { 'name': 'cookbook.gravityFieldPod', 'key': 'cookbook.gravityFieldPod', 'description': 'This cookbook chapter describes exemplarily the steps for determining the monthly gravity variations from precise orbit data (POD). Following data have to be prepared monthly with an adequate sampling, e.g. 10 s using  InstrumentConcatenate :      Precise (kinematic) orbit data    3x3 covariance matrices data    Initial orbit data used for precise orbit determination    Star camera data    Accelerometer data   Reduced sampling can be achieved by  InstrumentReduceSampling . If the satellite mission does not provide any required accelerometer data, these data can be generated via  SimulateAccelerometer . For satellite missions with less knowledge about the acting forces, it make sense to consider more than one state vector within an orbit revolution. Otherwise the accuracy of the estimated parameters will decrease. This implies that shorter arcs are necessary. The assignment of the kinematic orbit data as well as the 3x3 covariance matrices data to the arcs can be done with  InstrumentSynchronize .   Gravityfield2SphericalHarmonicsVector  converts the static respectively background gravity field into spherical harmonics.  For determining the accuracies and weights of the kinematic orbits it is sufficient to make a least-square estimation with only certain parameters, due to the fact that some parameters do not influence the estimation of the accuracies and weights. This estimation is done with  PreprocessingPod . Additional this program determines the temporal correlation of the kinematic orbit positions x,y and z. If short arcs are used the setting  section  shall be used. This setting considers the frictional forces by means of a macro model as well as the conservative and non-conservative forces.   NormalsSolverVCE  sets up the observation equations and summarized them to a normal equations system. The subsequent least-square estimation delivers the parameters surcharges.  The estimated parameters result from the re-addition of the background field, which is done in  MatrixCalculate .   Gravityfield2PotentialCoefficients  converts the gravity field parameters into spherical harmonics.', 'config_table': '', 'display_text': '</p><p>This cookbook chapter describes exemplarily the steps for determining the monthly gravity variations from precise orbit data (POD).</p><p><h2>Step 1: Preperation of data</h2><p></p><p>Following data have to be prepared monthly with an adequate sampling, e.g. 10 s using <a class="groops-program" href="InstrumentConcatenate.html">InstrumentConcatenate</a>: <ul>    <li>Precise (kinematic) orbit data   </li><li> 3x3 covariance matrices data   </li><li> Initial orbit data used for precise orbit determination   </li><li> Star camera data   </li><li> Accelerometer data </li></ul>  Reduced sampling can be achieved by <a class="groops-program" href="InstrumentReduceSampling.html">InstrumentReduceSampling</a>. If the satellite mission does not provide any required accelerometer data, these data can be generated via <a class="groops-program" href="SimulateAccelerometer.html">SimulateAccelerometer</a>.</p><p>For satellite missions with less knowledge about the acting forces, it make sense to consider more than one state vector within an orbit revolution. Otherwise the accuracy of the estimated parameters will decrease. This implies that shorter arcs are necessary. The assignment of the kinematic orbit data as well as the 3x3 covariance matrices data to the arcs can be done with <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.</p><p><h2>Step 2: Conversion of the background gravity field</h2><p> <a class="groops-program" href="Gravityfield2SphericalHarmonicsVector.html">Gravityfield2SphericalHarmonicsVector</a> converts the static respectively background gravity field into spherical harmonics.</p><p><h2>Step 3: Preprocessing POD</h2><p> For determining the accuracies and weights of the kinematic orbits it is sufficient to make a least-square estimation with only certain parameters, due to the fact that some parameters do not influence the estimation of the accuracies and weights. This estimation is done with <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>. Additional this program determines the temporal correlation of the kinematic orbit positions x,y and z. If short arcs are used the setting <a class="groops-class" href="observationType.html#podIntegral">observation:podIntegral</a> shall be used. This setting considers the frictional forces by means of a macro model as well as the conservative and non-conservative forces.</p><p><h2>Step 4: Solving of normal equations system</h2><p> <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a> sets up the observation equations and summarized them to a normal equations system. The subsequent least-square estimation delivers the parameters surcharges.</p><p><h2>Step 5: Determination of the estimated gravity field parameters</h2><p> The estimated parameters result from the re-addition of the background field, which is done in <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a>.</p><p><h2>Step 6: Conversion of the gravity field parameters</h2><p> <a class="groops-program" href="Gravityfield2PotentialCoefficients.html">Gravityfield2PotentialCoefficients</a> converts the gravity field parameters into spherical harmonics.</p><p>'},
'cookbook.gravityFieldGrace': { 'name': 'cookbook.gravityFieldGrace', 'key': 'cookbook.gravityFieldGrace', 'description': 'This cookbook chapter describes an example of estimating a gravity field solution using GRACE observation data. For the respective month a set of spherical harmonic coefficients up to a maximum degree is determined. An example scenario for this task can be found at  https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGraceGravityfieldRecovery.zip  including the required GROOPS scripts and data sets for the gravity field recovery process. The background models are provided at  https://ftp.tugraz.at/outgoing/ITSG/groops/data/ .    The following background models were used during the data processing:      Earth rotation :        Moon, sun and planets ephemerides :        Earth tide :        Ocean tide :        Pole tide :        Ocean pole tide :        Atmospheric tides :        Atmosphere and Ocean Dealiasing :        Sub-monthly continental hydrology :        Relativistic corrections :       These models were reduced during the analysis process and are not present in the solution. The   model was used as the static gravity field as well as for the trend component and annual oscillation. In the script  000groopsBackgroundModels.xml  a monthly mean of the GOCO06s including the time-variable components is determined in form of time splines using  Gravityfield2TimeSplines . This model is later added back to the final gravity solution.  The ITSG gravity field solutions are computed from the official GRACE L1B   and GRACE-FO L1B   observation data. The data sets for this example are provided in GROOPS file format in the scenario folder. The satellite-to-satellite-tracking (SST) data consists of:      K-band range rates     Light time correction     Antenna offset corrections   Additional observation data required for the processing comprises:      Star camera observations     Accelerometer data     Approximate orbits       Thruster data   The determination of      Kinematic orbits     3x3 epoch covariances    is depicted in  Kinematic orbit determination of LEO satellites . These data sets are also provided in the scenario folder. Data preparation is handled in the script  010groopsInstruments.xml . The approximate orbits (initial dynamic orbits) of the satellites, the star camera observations, the accelerometer data and the thruster data are resampled with a 5s sampling and small gaps in the data are filled using  InstrumentResample . Gross outliers are removed using  InstrumentRemoveEpochsByCriteria  and the data is synchronized using   InstrumentSynchronize . The approximate orbits are later used as a priori information for the dynamic orbit integration. In addition to the observed orientation of the spacecrafts (star camera observations), the nominal orientation is computed using  SimulateStarCameraGrace . The difference between observed and simulated orientation is determined using  InstrumentStarCameraMultiply  and is employed in the outlier detection. The accelerometer data is initially calibrated by estimating a bias using  InstrumentAccelerometerEstimateBiasScale  with respect to simulated data created with  SimulateAccelerometer . For simulating accelerometer data a satellite model implying the satellite\'s mass and surfaces is required. Such a model can be created with  SatelliteModelCreate . Models for the GRACE and GRACE-FO satellites are also provided at  https://ftp.tugraz.at/outgoing/ITSG/groops/data/satelliteModel/ . Non-gravitational forces comprising atmospheric drag, solar radiation pressure and albedo have to modeled when simulating the accelerometer data. The acceleration bias parameters are determined as degree 3 time splines with 6h nodes. When determining these parameters the thruster events are excluded from the estimation. The SST observations, the light time corrections and the antenna center corrections are synchronized with a 5s sampling together with simulated SST data created with  SimulateSatelliteTracking . Simulated data is used for the outlier detection of the original SST observations. The sampling of the kinematic orbits is reduced to 60s using  InstrumentReduceSampling  and an outlier detection is performed using the approximate dynamic orbits. The approximate orbits, the star camera observations and the accelerometer data are divided into 24h arcs (variational arcs). The kinematic orbits, its 3x3 epoch covariances, KBR observations, light time corrections, antenna center corrections and star camera observations are divided into 3h arcs per day (short arcs). Additionally the approximate orbits and the star camera observations are also synchronized to short arcs. Further information on instrument data preparation can be found in  Instrument data handling .  In this processing step dynamic orbits are computed for a complete 24h orbit arc by integrating the forces acting on the GRACE/GRACE-FO satellites. Additionally, the state transition matrix is set up. The dynamic orbits are then fitted to kinematic orbits and SST observations in a least squares adjustment by co-estimating additional accelerometer calibration parameters together with the initial state vector. The newly estimated parameters are then used to re-estimate the dynamic orbits and setting up the new state transition matrix. The script  020groopsVariational.xml  in the scenario folder implements the required processing steps. Time splines from a time-variable gravity field are estimated using  Gravityfield2TimeSplines . In this step the static gravity field (GOCO06s) is combined with the following time-variable components:        section :     static gravity field      section                 section :       trend component of gravity field            section                 section :       annual cosine component of gravity field          section :       annual sine component of gravity field            section : atmosphere and ocean dealiasing (AOD1B RL06)      section : hydrology dealiasing (LSDM)      section : ocean tides (FES2014b)      section : atmospheric tides (AOD1B RL06)      section : pole tides (IERS 2010)      section : ocean pole tides (IERS 2010)    maxDegree = 220  and  sampling = 10/1440  is sufficient. In  PreprocessingVariationalEquation  the  variational equations  comprising the integrated orbit together with the state transition matrix are stored in  section . This program has to be executed for both GRACE or GRACE-FO satellites and it is recommended to use  LoopPrograms .        section : satellite model from  020groopsInstruments.xml       section : the approximate orbits from  020groopsInstruments.xml       section : the attitude file from  020groopsInstruments.xml       section : the accelerometer data from      020groopsInstruments.xml       forces : see below      section : JPL DE432      section : a static gravity field (GOCO06s) with  maxDegree = 10  is more than sufficient.  The  section  include:      section :         the previously estimated time-variable gravity field    section : astronomical tides (based on JPL DE432 ephemerides)    section : Earth tide (IERS conventions)    section :         relativistic effects (IERS conventions)  In  PreprocessingVariationalEquationOrbitFit  the integrated orbit ( section ) is fitted to the kinematic orbit ( section ) by least squares adjustment. The additional accelerometer calibration parameters can be defined by      section : accelerometer scale factor (once per day)    section : accelerometer bias (time spline with 6h nodes)  The observation equations (parameter sensitivity matrix) are computed by integration of the variational equations ( section ) using a polynomial with  integrationDegree = 7 .  PreprocessingVariationalEquationOrbitFit  has to be executed per satellite. PreprocessingVariationalEquationSstFit  fits two dynamic orbits  section  to the SST observations and the kinematic orbits.        rightHandSide : input for observation vectors                        section : K-band range rate observations              section : light time correction              section : antenna offset corrections              section : kinematic orbit of satellite 1              section : kinematic orbit of satellite 2                sstType : rangeRate      section : dynamic orbit and integrated state matrix of satellite 1      section : dynamic orbit and integrated state matrix of satellite 2      section : same as in In  PreprocessingVariationalEquationOrbitFit       section : same as in In  PreprocessingVariationalEquationOrbitFit       integrationDegree :  7       interpolationDegree :  7       section                         sigma :  1                 section                         sigma : 1              section : 3x3 epoch covariances                section                         sigma : 1              section : 3x3 epoch covariances             The estimated accelerometer calibration parameters from  PreprocessingVariationalEquationOrbitFit  and  PreprocessingVariationalEquationSstFit  are determined as corrections and stored in  section . Both correction estimates have to be summed up using  FunctionsCalculate . The dynamic orbit and the resulting accelerometer calibration parameters are now used to re-integrate the orbit once more using  PreprocessingVariationalEquation  and introducing  section  as  estimatedParameters . This step usually ensures convergence. If the maximum orbit difference is still not sufficient this step can be repeated again.  The script  030groopsPreprocessing.xml  implements the following steps and settings. The program  PreprocessingSst  processes SST observations and kinematic orbit data and performs a complete least squares adjustment for gravity field determination by computing the observations equations. Force model parameters (gravitational potential coefficients and accelerometer calibration parameters) are computed by integrating the parameter sensitivity matrix from the variational equations. Parameters describing effects due to the SST observation system and geometry (KBR antenna phase center variations) are computed using the dynamic orbits as a Taylor point. Short time gravity variations can be co-estimated together with the monthly mean gravity field. The autoregressive model sequence constraining the short time parameters is provided in the data folder. See   for more information about this co-estimation.        section : sstVariational                        rightHandSide :                                section : KBR range rates                  section : light time correction                  section : antenna offset corrections                  section : kinematic orbit of satellite 1                  section : kinematic orbit of satellite 2                            sstType : rangeRate              section : dynamic orbit and integrated state matrix of satellite 1              section : dynamic orbit and integrated state matrix of satellite 2              section : JPL DE432              section : spherical harmonics from  minDegree = 2  to  maxDegree = 60               section : high frequency parametrization              section : same as in In  PreprocessingVariationalEquationOrbitFit               section : same as in In  PreprocessingVariationalEquationOrbitFit               section : antenna phase center variations (y and z for both satellites)              integrationDegree : 7              interpolationDegree : 7                section                         sigma :  1e-7               sampling : 5 [seconds]                section                         sigma :   2               section : 3x3 epoch covariances              sampling : 60 [seconds]                estimateShortTimeVariations                         section : AR models              section : names                                        section : parametrizationGravity                                                section : high frequency parametrization                                                    ParameterSelection2IndexVector  and  MatrixCalculate  with  section  can be used to extract the desired spherical harmonic coefficients from  section  and the respective standard deviations from  section  up to a certain degree. In the program  Gravityfield2PotentialCoefficients  the estimated spherical harmonics coefficients are read with  section . The monthly mean gravity field can be added back by additionaly selecting the time splines created in  000groopsBackgroundModels.xml  using  section . The preprocessing solution is saved as a  spherical harmonics file .  Normal equations are set up in the script  040groopsMonthlyNormals120.xml  using the program  NormalsBuildShortTimeStaticLongTime . The time intervals which the normal equations are divided into are defined in  section . The normal equations are based on  section  including the SST data, the kinematic orbits and the variational equations. The parametrization of the gravity field can be set with  section  (e.g. spherical harmonics up to degree and order 120). Accelerometer calibration parameters and KBR antenna phase center variations can be parameterized using  section  and  section . With  estimateShortTimeVariations  short time variations of the gravity field can be co-estimated. The parameters selected by  section  (e.g. linear splines with 6h nodes) are constrained by an  section . Additional temporal variations (e.g. trend and annual oscillation) could be estimated with  estimateLongTimeVariations .  The desired spherical harmonic coefficients are determined in the script  050groopsMonthlySolve.xml .  NormalsSolverVCE  accumulates  section  and solves the total combined system. Variance component estimation is used to determine the relative weighting of the individual normals. The estimated parameter vector ( section ) the estimated accuracies ( section ) and the full covariance matrix ( section ) can be saved. Using  Gravityfield2PotentialCoefficients  the final solution can be saved as a  spherical harmonics file  by adding back the monthly mean gravity field to the estimated spherical harmonic coefficients.', 'config_table': '', 'display_text': 'This cookbook chapter describes an example of estimating a gravity field solution using GRACE observation data. For the respective month a set of spherical harmonic coefficients up to a maximum degree is determined. An example scenario for this task can be found at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGraceGravityfieldRecovery.zip" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/scenario/scenarioGraceGravityfieldRecovery.zip</a> including the required GROOPS scripts and data sets for the gravity field recovery process. The background models are provided at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/data/" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/data/</a>.</p><p> <h2 id="backgroundModels">Background models</h2><p> The following background models were used during the data processing: <ul>    <li><b>Earth rotation</b>: <a href="https://www.iers.org/IERS/EN/Publications/TechnicalNotes/tn36.html">IERS 2010</a>    </li><li> <b>Moon, sun and planets ephemerides</b>: <a href="https://ipnpr.jpl.nasa.gov/progress_report/42-196/196C.pdf">JPL DE432</a>    </li><li> <b>Earth tide</b>: <a href="https://www.iers.org/IERS/EN/Publications/TechnicalNotes/tn36.html">IERS 2010</a>    </li><li> <b>Ocean tide</b>: <a href="https://www.aviso.altimetry.fr/es/data/products/auxiliary-products/global-tide-fes/description-fes2014.html">FES2014b</a>    </li><li> <b>Pole tide</b>: <a href="https://www.iers.org/IERS/EN/Publications/TechnicalNotes/tn36.html">IERS 2010</a>    </li><li> <b>Ocean pole tide</b>: <a href="https://doi.org/10.1029/2001JC001224">Desai 2004</a>    </li><li> <b>Atmospheric tides</b>: <a href="https://doi.org/10.1093/gji/ggx302">AOD1B RL06</a>    </li><li> <b>Atmosphere and Ocean Dealiasing</b>: <a href="https://doi.org/10.1093/gji/ggx302">AOD1B RL06</a>    </li><li> <b>Sub-monthly continental hydrology</b>: <a href="https://doi.org/10.2312/GFZ.b103-08095">LSDM (ESMGFZ)</a>    </li><li> <b>Relativistic corrections</b>: <a href="https://www.iers.org/IERS/EN/Publications/TechnicalNotes/tn36.html">IERS 2010</a>  </li></ul>  These models were reduced during the analysis process and are not present in the solution. The <a href="https://doi.org/10.5194/essd-13-99-2021">GOCO06s</a> model was used as the static gravity field as well as for the trend component and annual oscillation. In the script <code>000groopsBackgroundModels.xml</code> a monthly mean of the GOCO06s including the time-variable components is determined in form of time splines using <a class="groops-program" href="Gravityfield2TimeSplines.html">Gravityfield2TimeSplines</a>. This model is later added back to the final gravity solution.</p><p><h2 id="metadata">Instrument data preparation</h2><p> The ITSG gravity field solutions are computed from the official GRACE L1B <a href="https://doi.org/10.5067/GRJPL-L1B03">JPL (2018)</a> and GRACE-FO L1B <a href="https://doi.org/10.5067/GFL1B-ASJ04">JPL (2019)</a> observation data. The data sets for this example are provided in GROOPS file format in the scenario folder.</p><p>The satellite-to-satellite-tracking (SST) data consists of: <ul>    <li><b>K-band range rates</b>   </li><li> <b>Light time correction</b>   </li><li> <b>Antenna offset corrections</b> </li></ul> </p><p>Additional observation data required for the processing comprises: <ul>    <li><b>Star camera observations</b>   </li><li> <b>Accelerometer data</b>   </li><li> <b>Approximate orbits</b>    </li><li> <b>Thruster data</b> </li></ul> </p><p>The determination of <ul>    <li><b>Kinematic orbits</b>   </li><li> <b>3x3 epoch covariances</b> </li></ul>  is depicted in <a class="groops-ref" href="cookbook.kinematicOrbit.html">Kinematic orbit determination of LEO satellites</a>. These data sets are also provided in the scenario folder.</p><p>Data preparation is handled in the script <code>010groopsInstruments.xml</code>. The approximate orbits (initial dynamic orbits) of the satellites, the star camera observations, the accelerometer data and the thruster data are resampled with a 5s sampling and small gaps in the data are filled using <a class="groops-program" href="InstrumentResample.html">InstrumentResample</a>. Gross outliers are removed using <a class="groops-program" href="InstrumentRemoveEpochsByCriteria.html">InstrumentRemoveEpochsByCriteria</a> and the data is synchronized using  <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.</p><p>The approximate orbits are later used as a priori information for the dynamic orbit integration. In addition to the observed orientation of the spacecrafts (star camera observations), the nominal orientation is computed using <a class="groops-program" href="SimulateStarCameraGrace.html">SimulateStarCameraGrace</a>. The difference between observed and simulated orientation is determined using <a class="groops-program" href="InstrumentStarCameraMultiply.html">InstrumentStarCameraMultiply</a> and is employed in the outlier detection.</p><p>The accelerometer data is initially calibrated by estimating a bias using <a class="groops-program" href="InstrumentAccelerometerEstimateBiasScale.html">InstrumentAccelerometerEstimateBiasScale</a> with respect to simulated data created with <a class="groops-program" href="SimulateAccelerometer.html">SimulateAccelerometer</a>. For simulating accelerometer data a satellite model implying the satellite\'s mass and surfaces is required. Such a model can be created with <a class="groops-program" href="SatelliteModelCreate.html">SatelliteModelCreate</a>. Models for the GRACE and GRACE-FO satellites are also provided at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops/data/satelliteModel/" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops/data/satelliteModel/</a>. Non-gravitational forces comprising atmospheric drag, solar radiation pressure and albedo have to modeled when simulating the accelerometer data. The acceleration bias parameters are determined as degree 3 time splines with 6h nodes. When determining these parameters the thruster events are excluded from the estimation.</p><p>The SST observations, the light time corrections and the antenna center corrections are synchronized with a 5s sampling together with simulated SST data created with <a class="groops-program" href="SimulateSatelliteTracking.html">SimulateSatelliteTracking</a>. Simulated data is used for the outlier detection of the original SST observations.</p><p>The sampling of the kinematic orbits is reduced to 60s using <a class="groops-program" href="InstrumentReduceSampling.html">InstrumentReduceSampling</a> and an outlier detection is performed using the approximate dynamic orbits.</p><p>The approximate orbits, the star camera observations and the accelerometer data are divided into 24h arcs (variational arcs). The kinematic orbits, its 3x3 epoch covariances, KBR observations, light time corrections, antenna center corrections and star camera observations are divided into 3h arcs per day (short arcs). Additionally the approximate orbits and the star camera observations are also synchronized to short arcs.</p><p>Further information on instrument data preparation can be found in <a class="groops-ref" href="cookbook.instrument.html">Instrument data handling</a>.</p><p><h2 id="variational">Variational equations</h2><p> In this processing step dynamic orbits are computed for a complete 24h orbit arc by integrating the forces acting on the GRACE/GRACE-FO satellites. Additionally, the state transition matrix is set up. The dynamic orbits are then fitted to kinematic orbits and SST observations in a least squares adjustment by co-estimating additional accelerometer calibration parameters together with the initial state vector. The newly estimated parameters are then used to re-estimate the dynamic orbits and setting up the new state transition matrix.</p><p>The script <code>020groopsVariational.xml</code> in the scenario folder implements the required processing steps. Time splines from a time-variable gravity field are estimated using <a class="groops-program" href="Gravityfield2TimeSplines.html">Gravityfield2TimeSplines</a>. In this step the static gravity field (GOCO06s) is combined with the following time-variable components: <ul>      <li><a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>:     static gravity field     </li><li> <a class="groops-class" href="gravityfieldType.html#trend">gravityfield:trend</a>     <ul>          </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>:       trend component of gravity field     </li></ul>      <li><a class="groops-class" href="gravityfieldType.html#oscillation">gravityfield:oscillation</a>     <ul>          </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfieldCos:potentialCoefficients</a>:       annual cosine component of gravity field         </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfieldSin:potentialCoefficients</a>:       annual sine component of gravity field     </li></ul>      <li><a class="groops-class" href="gravityfieldType.html#timeSplines">gravityfield:timeSplines</a>: atmosphere and ocean dealiasing (AOD1B RL06)     </li><li> <a class="groops-class" href="gravityfieldType.html#timeSplines">gravityfield:timeSplines</a>: hydrology dealiasing (LSDM)     </li><li> <a class="groops-class" href="tidesType.html#doodsonHarmonicTide">doodsonHarmonicTide</a>: ocean tides (FES2014b)     </li><li> <a class="groops-class" href="tidesType.html#doodsonHarmonicTide">doodsonHarmonicTide</a>: atmospheric tides (AOD1B RL06)     </li><li> <a class="groops-class" href="tidesType.html#poleTide">tides:poleTide</a>: pole tides (IERS 2010)     </li><li> <a class="groops-class" href="tidesType.html#oceanPoleTide">tides:poleOceanTide</a>: ocean pole tides (IERS 2010) </li></ul>  <strong class="groops-config-element">maxDegree</strong>=<code>220</code> and <strong class="groops-config-element">sampling</strong>=<code>10/1440</code> is sufficient.</p><p>In <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a> the <a class="groops-file" href="fileFormat_variationalEquation.html">variational equations</a> comprising the integrated orbit together with the state transition matrix are stored in <a class="groops-class" href="fileFormat_variationalEquation.html">outputfileVariational</a>.</p><p>This program has to be executed for both GRACE or GRACE-FO satellites and it is recommended to use <a class="groops-program" href="LoopPrograms.html">LoopPrograms</a>. <ul>      <li><a class="groops-class" href="fileFormat_satelliteModel.html">inputfileSatelliteModel</a>: satellite model from <code>020groopsInstruments.xml</code>     </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>: the approximate orbits from <code>020groopsInstruments.xml</code>     </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>: the attitude file from <code>020groopsInstruments.xml</code>     </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a>: the accelerometer data from     <code>020groopsInstruments.xml</code>     </li><li> <strong class="groops-config-element">forces</strong>: see below     </li><li> <a class="groops-class" href="ephemeridesType.html">ephemerides</a>: JPL DE432     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gradientfield:potentialCoefficients</a>: a static gravity field (GOCO06s) with <strong class="groops-config-element">maxDegree</strong>=<code>10</code> is more than sufficient. </li></ul> </p><p>The <a class="groops-class" href="forcesType.html">force models</a> include: <ul>    <li><a class="groops-class" href="gravityfieldType.html#timeSplines">gravityfield:timeSplines</a>:         the previously estimated time-variable gravity field   </li><li> <a class="groops-class" href="tidesType.html#astronomicalTide">tides:astronomicalTide</a>: astronomical tides (based on JPL DE432 ephemerides)   </li><li> <a class="groops-class" href="tidesType.html#earthTide">tides:earthTide</a>: Earth tide (IERS conventions)   </li><li> <a class="groops-class" href="miscAccelerationsType.html#relativisticEffect">miscAccelerations:relativisticEffect</a>:         relativistic effects (IERS conventions) </li></ul> </p><p>In <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a> the integrated orbit (<a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a>) is fitted to the kinematic orbit (<a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>) by least squares adjustment. The additional accelerometer calibration parameters can be defined by <ul>    <li><a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a>: accelerometer scale factor (once per day)   </li><li> <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a>: accelerometer bias (time spline with 6h nodes) </li></ul> </p><p>The observation equations (parameter sensitivity matrix) are computed by integration of the variational equations (<a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a>) using a polynomial with <strong class="groops-config-element">integrationDegree</strong>=<code>7</code>. <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a> has to be executed per satellite.</p><p><a class="groops-program" href="PreprocessingVariationalEquationSstFit.html">PreprocessingVariationalEquationSstFit</a> fits two dynamic orbits <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational1/2</a> to the SST observations and the kinematic orbits. <ul>      <li><strong class="groops-config-element">rightHandSide</strong>: input for observation vectors         <ul>              </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>: K-band range rate observations             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>: light time correction             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>: antenna offset corrections             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit1</a>: kinematic orbit of satellite 1             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit2</a>: kinematic orbit of satellite 2         </li></ul>      <li><strong class="groops-config-element">sstType</strong>: rangeRate     </li><li> <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational1</a>: dynamic orbit and integrated state matrix of satellite 1     </li><li> <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational2</a>: dynamic orbit and integrated state matrix of satellite 2     </li><li> <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration1</a>: same as in In <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>     </li><li> <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration2</a>: same as in In <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>     </li><li> <strong class="groops-config-element">integrationDegree</strong>: <code>7</code>     </li><li> <strong class="groops-config-element">interpolationDegree</strong>: <code>7</code>     </li><li> <a class="groops-class" href="covarianceSstType.html">covarianceSst</a>         <ul>              </li><li> <strong class="groops-config-element">sigma</strong>: <code>1</code>         </li></ul>      <li><a class="groops-class" href="covariancePodType.html">covariancePod1</a>         <ul>              </li><li> <strong class="groops-config-element">sigma</strong>: 1             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileCovariancePodEpoch</a>: 3x3 epoch covariances         </li></ul>      <li><a class="groops-class" href="covariancePodType.html">covariancePod2</a>         <ul>              </li><li> <strong class="groops-config-element">sigma</strong>: 1             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileCovariancePodEpoch</a>: 3x3 epoch covariances         </li></ul>  </ul> The estimated accelerometer calibration parameters from <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a> and <a class="groops-program" href="PreprocessingVariationalEquationSstFit.html">PreprocessingVariationalEquationSstFit</a> are determined as corrections and stored in <a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a>. Both correction estimates have to be summed up using <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a>.</p><p>The dynamic orbit and the resulting accelerometer calibration parameters are now used to re-integrate the orbit once more using <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a> and introducing <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a> as <strong class="groops-config-element">estimatedParameters</strong>. This step usually ensures convergence. If the maximum orbit difference is still not sufficient this step can be repeated again.</p><p><h2 id="preprocessing">Preprocessing</h2><p> The script <code>030groopsPreprocessing.xml</code> implements the following steps and settings. The program <a class="groops-program" href="PreprocessingSst.html">PreprocessingSst</a> processes SST observations and kinematic orbit data and performs a complete least squares adjustment for gravity field determination by computing the observations equations. Force model parameters (gravitational potential coefficients and accelerometer calibration parameters) are computed by integrating the parameter sensitivity matrix from the variational equations. Parameters describing effects due to the SST observation system and geometry (KBR antenna phase center variations) are computed using the dynamic orbits as a Taylor point. Short time gravity variations can be co-estimated together with the monthly mean gravity field. The autoregressive model sequence constraining the short time parameters is provided in the data folder. See <a href="https://doi.org/10.1007/s00190-019-01314-1">Kvas 2019</a> for more information about this co-estimation. <ul>      <li><a class="groops-class" href="observationType.html">observation</a>: sstVariational         <ul>              </li><li> <strong class="groops-config-element">rightHandSide</strong>:             <ul>                  </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>: KBR range rates                 </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>: light time correction                 </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>: antenna offset corrections                 </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit1</a>: kinematic orbit of satellite 1                 </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit2</a>: kinematic orbit of satellite 2             </li></ul>              <li><strong class="groops-config-element">sstType</strong>: rangeRate             </li><li> <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational1</a>: dynamic orbit and integrated state matrix of satellite 1             </li><li> <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational2</a>: dynamic orbit and integrated state matrix of satellite 2             </li><li> <a class="groops-class" href="ephemeridesType.html">ephemerides</a>: JPL DE432             </li><li> <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>: spherical harmonics from <strong class="groops-config-element">minDegree</strong>=<code>2</code> to <strong class="groops-config-element">maxDegree</strong>=<code>60</code>             </li><li> <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>: high frequency parametrization             </li><li> <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration1</a>: same as in In <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>             </li><li> <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration2</a>: same as in In <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>             </li><li> <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrizationSst</a>: antenna phase center variations (y and z for both satellites)             </li><li> <strong class="groops-config-element">integrationDegree</strong>: 7             </li><li> <strong class="groops-config-element">interpolationDegree</strong>: 7         </li></ul>      <li><a class="groops-class" href="covarianceSstType.html">covarianceSst</a>         <ul>              </li><li> <strong class="groops-config-element">sigma</strong>: <code>1e-7</code>             </li><li> <strong class="groops-config-element">sampling</strong>: 5 [seconds]         </li></ul>      <li><a class="groops-class" href="covariancePodType.html">covariancePod1/2</a>         <ul>              </li><li> <strong class="groops-config-element">sigma</strong>:  <code>2</code>             </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileCovariancePodEpoch</a>: 3x3 epoch covariances             </li><li> <strong class="groops-config-element">sampling</strong>: 60 [seconds]         </li></ul>      <li><strong class="groops-config-element">estimateShortTimeVariations</strong>         <ul>              </li><li> <a class="groops-class" href="autoregressiveModelSequenceType.html">autoregressiveModelSequence</a>: AR models             </li><li> <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a>: names                 <ul>                      </li><li> <a class="groops-class" href="parameterNamesType.html">parameterName</a>: parametrizationGravity                     <ul>                          </li><li> <a class="groops-class" href="parametrizationGravityType.html">parametrization</a>: high frequency parametrization                     </li></ul>                  </ul>         </ul> </ul></p><p><a class="groops-program" href="ParameterSelection2IndexVector.html">ParameterSelection2IndexVector</a> and <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a> with <a class="groops-class" href="matrixGeneratorType.html#reorder">matrix:reorder</a> can be used to extract the desired spherical harmonic coefficients from <a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a> and the respective standard deviations from <a class="groops-class" href="fileFormat_matrix.html">outputfileSigmax</a> up to a certain degree.</p><p>In the program <a class="groops-program" href="Gravityfield2PotentialCoefficients.html">Gravityfield2PotentialCoefficients</a> the estimated spherical harmonics coefficients are read with <a class="groops-class" href="gravityfieldType.html#fromParametrization">gravityfield:fromParametrization</a>. The monthly mean gravity field can be added back by additionaly selecting the time splines created in <code>000groopsBackgroundModels.xml</code> using <a class="groops-class" href="gravityfieldType.html#timeSplines">gravityfield:timeSplines</a>. The preprocessing solution is saved as a <a class="groops-file" href="fileFormat_potentialCoefficients.html">spherical harmonics file</a>.</p><p><h2 id="monthlyNormals">Setting up normal equations</h2><p> Normal equations are set up in the script <code>040groopsMonthlyNormals120.xml</code> using the program <a class="groops-program" href="NormalsBuildShortTimeStaticLongTime.html">NormalsBuildShortTimeStaticLongTime</a>. The time intervals which the normal equations are divided into are defined in <a class="groops-class" href="fileFormat_arcList.html">inputfileArcList</a>. The normal equations are based on <a class="groops-class" href="observationType.html">observation</a> including the SST data, the kinematic orbits and the variational equations. The parametrization of the gravity field can be set with <a class="groops-class" href="parametrizationGravityType.html">observation:parametrizationGravity</a> (e.g. spherical harmonics up to degree and order 120). Accelerometer calibration parameters and KBR antenna phase center variations can be parameterized using <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a> and <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrizationSst</a>. With <strong class="groops-config-element">estimateShortTimeVariations</strong> short time variations of the gravity field can be co-estimated. The parameters selected by <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a> (e.g. linear splines with 6h nodes) are constrained by an <a class="groops-class" href="autoregressiveModelSequenceType.html">autoregressiveModelSequence</a>. Additional temporal variations (e.g. trend and annual oscillation) could be estimated with <strong class="groops-config-element">estimateLongTimeVariations</strong>.</p><p><h2 id="monhtlySolve">Solving normal equations</h2><p> The desired spherical harmonic coefficients are determined in the script <code>050groopsMonthlySolve.xml</code>. <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a> accumulates <a class="groops-class" href="normalEquationType.html">normalEquation</a> and solves the total combined system. Variance component estimation is used to determine the relative weighting of the individual normals. The estimated parameter vector (<a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a>) the estimated accuracies (<a class="groops-class" href="fileFormat_matrix.html">outputfileSigmax</a>) and the full covariance matrix (<a class="groops-class" href="fileFormat_matrix.html">outputfileCovariance</a>) can be saved. Using <a class="groops-program" href="Gravityfield2PotentialCoefficients.html">Gravityfield2PotentialCoefficients</a> the final solution can be saved as a <a class="groops-file" href="fileFormat_potentialCoefficients.html">spherical harmonics file</a> by adding back the monthly mean gravity field to the estimated spherical harmonic coefficients.</p><p>'},
'cookbook.regionalGeoid': { 'name': 'cookbook.regionalGeoid', 'key': 'cookbook.regionalGeoid', 'description': 'This shows exemplary the computation of a regional geoid using terrestrial gravimetric observations in combination with a global satellite model such as GOCO06s. The geoid is estimated in a least squares adjustment with a parametrization using radial basis functions. A detailed desciption of the method is given in Christian Pock (2017), Consistent Combination of Satellite and Terrestrial Gravity Field Observations in Regional Geoid Modeling. Dissertation TU Graz.    Here it is assumed that the measured absolute gravity data is given at points in ellipsoidal coordinates. The observed values should be converted to SI units  .      Matrix2GriddedData  to convert data from text file in tabular form.   A high resolution topography model is needed to reduce the observations. As the model heights are usually given in physical heights a reference geoid is needed to compute the correct ellipsoidal height.      NetCdf2GridRectangular  convert into groops format.    Gravityfield2GriddedData : Compute geoid heights using the GOCO06s model with          section  The topography grid      section       section  the GOCO06s model      section      Subtract ( factor =-1) GRS680 normal field.        GriddedDataCalculate : Generate a new combined griddedData file         with the orthometric height ( data0 ) and the geoid height ( data1 ).    GriddedTopography2PotentialCoefficients : Compute the gravitational potential in terms         of spherical harmonics up to a maximum degree of the global satellite model.         This is the part of the topography, which is already included in the global satellite model.         The integration boundaries are  radialUpperBound = data0+data1          and  radialLowerBound = data1 .   Calculate approximate reference gravity to reduce it from the observations.      Gravityfield2AbsoluteGravity           section  at observation positions      section  Centrifugal potential      section  full GOCO06s model      section            ( radialUpperBound = data0+data1 ,  radialLowerBound = data1 )      section            Subtract ( factor =-1) the potential part of the topography already included in the GOCO06s model.        GriddedDataCalculate  to calculate observed minus computed.    Large outliers can be removed in  GriddedDataCalculate  with  removalCriteria .     The residual gravity is parametrized in terms of Radial Basis Functions  section . The basis functions should be distributed on a regular  section  covering a somewhat larger area than the observations, see  section . The shape of the functions  section  should reflect the signal content of reduced observations and are defined by the coefficients.      RadialBasisSplines2KernelCoefficients           section  accuracies of GOCO06s model      maxDegree =7000. Complemented by Kaula\'s rule of thumb       The maximum degree should correspond to the spatial resolution. Rule of thumb: the number of spherical harmonic coefficients   should roughly agree to the number of grid points if they would cover the complete Earth.  Setup the observation equations and accumulate the system of normal equations.    NormalsBuild           section  with            section               section         section              with  section             NormalsSolverVCE           section  from  NormalsBuild       section             towards zero means regularization towards the GOCO06s, which is reduced from the data.       Evaluate the estimated parameters and add back the reduced reference models.      Gravityfield2GriddedData : Compute approximate geoid heights using the GOCO06s model with          section  select a grid with target resolution at elliposid      section       section  GOCO06s model      section      Subtract ( factor =-1) GRS80 normal field.        GriddedDataCalculate : Move points from ellipsoid to geoid with  height = data0     Gravityfield2GriddedData           section  from above.      section       section            The solution vector   together with the RBF parametrization      section  GOCO06s model      section            ( radialUpperBound = data0+data1 ,  radialLowerBound = data1 )      section            Subtract ( factor =-1) the potential part of the topography already included in the GOCO06s model.      section            Subtract ( factor =-1) GRS80 normal field.      convertToHarmonics = no , otherwise the RBF are converted to harmonics up to degree 7000.        GriddedDataCalculate : Set  height =0 of the computed geoid grid.    GridRectangular2NetCdf', 'config_table': '', 'display_text': 'This shows exemplary the computation of a regional geoid using terrestrial gravimetric observations in combination with a global satellite model such as GOCO06s. The geoid is estimated in a least squares adjustment with a parametrization using radial basis functions. A detailed desciption of the method is given in Christian Pock (2017), Consistent Combination of Satellite and Terrestrial Gravity Field Observations in Regional Geoid Modeling. Dissertation TU Graz.</p><p> <h2>Gravimetric data</h2><p> Here it is assumed that the measured absolute gravity data is given at points in ellipsoidal coordinates. The observed values should be converted to SI units $m/s^2$. <ul>    <li><a class="groops-program" href="Matrix2GriddedData.html">Matrix2GriddedData</a> to convert data from text file in tabular form. </li></ul> </p><p></p><p><h2>Topography</h2><p> A high resolution topography model is needed to reduce the observations. As the model heights are usually given in physical heights a reference geoid is needed to compute the correct ellipsoidal height. <ul>    <li><a class="groops-program" href="NetCdf2GridRectangular.html">NetCdf2GridRectangular</a> convert into groops format.   </li><li> <a class="groops-program" href="Gravityfield2GriddedData.html">Gravityfield2GriddedData</a>: Compute geoid heights using the GOCO06s model with   <ul>      </li><li> <a class="groops-class" href="gridType.html#file">grid:file</a> The topography grid     </li><li> <a class="groops-class" href="kernelType.html#geoidHeight">kernel:geoidHeight</a>     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a> the GOCO06s model     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>     Subtract (<strong class="groops-config-element">factor</strong>=-1) GRS680 normal field.   </li></ul>    <li><a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a>: Generate a new combined griddedData file         with the orthometric height (<code>data0</code>) and the geoid height (<code>data1</code>).   </li><li> <a class="groops-program" href="GriddedTopography2PotentialCoefficients.html">GriddedTopography2PotentialCoefficients</a>: Compute the gravitational potential in terms         of spherical harmonics up to a maximum degree of the global satellite model.         This is the part of the topography, which is already included in the global satellite model.         The integration boundaries are <strong class="groops-config-element">radialUpperBound</strong>=<code>data0+data1</code>         and <strong class="groops-config-element">radialLowerBound</strong>=<code>data1</code>. </li></ul> </p><p></p><p><h2>Reduce</h2><p> Calculate approximate reference gravity to reduce it from the observations. <ul>    <li><a class="groops-program" href="Gravityfield2AbsoluteGravity.html">Gravityfield2AbsoluteGravity</a>   <ul>      </li><li> <a class="groops-class" href="gridType.html#file">grid:File</a> at observation positions     </li><li> <a class="groops-class" href="gravityfieldType.html#tides">gravityfield:tides</a> Centrifugal potential     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a> full GOCO06s model     </li><li> <a class="groops-class" href="gravityfieldType.html#topography">gravityfield:topography</a>           (<strong class="groops-config-element">radialUpperBound</strong>=<code>data0+data1</code>, <strong class="groops-config-element">radialLowerBound</strong>=<code>data1</code>)     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>           Subtract (<strong class="groops-config-element">factor</strong>=-1) the potential part of the topography already included in the GOCO06s model.   </li></ul>    <li><a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a> to calculate observed minus computed.   </li><li> Large outliers can be removed in <a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a> with <strong class="groops-config-element">removalCriteria</strong>. </li></ul> </p><p></p><p> <h2>Radial Basis Functions (RBF)</h2><p> The residual gravity is parametrized in terms of Radial Basis Functions <a class="groops-class" href="parametrizationGravityType.html#radialBasis">parametrizationGravity:radialBasis</a>. The basis functions should be distributed on a regular <a class="groops-class" href="gridType.html">grid</a> covering a somewhat larger area than the observations, see <a class="groops-class" href="borderType.html">border</a>. The shape of the functions <a class="groops-class" href="kernelType.html#coefficients">kernel:coefficients</a> should reflect the signal content of reduced observations and are defined by the coefficients. <ul>    <li><a class="groops-program" href="RadialBasisSplines2KernelCoefficients.html">RadialBasisSplines2KernelCoefficients</a>   <ul>      </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a> accuracies of GOCO06s model     </li><li> <strong class="groops-config-element">maxDegree</strong>=7000. Complemented by Kaula\'s rule of thumb   </li></ul>  </ul> The maximum degree should correspond to the spatial resolution. Rule of thumb: the number of spherical harmonic coefficients $(\\text{maxDegree}+1)^2$ should roughly agree to the number of grid points if they would cover the complete Earth.</p><p></p><p><h2>Compute: Estimate parameters in a least squares adjustment</h2><p> Setup the observation equations and accumulate the system of normal equations. <ul>  <li><a class="groops-program" href="NormalsBuild.html">NormalsBuild</a>   <ul>      </li><li> <a class="groops-class" href="normalEquationType.html#design">normalEquation:design</a> with           <a class="groops-class" href="observationType.html#terrestrial">observation:terrestrial</a>     <ul>        </li><li> <a class="groops-class" href="kernelType.html#disturbance">kernel:disturbance</a>       </li><li> <a class="groops-class" href="parametrizationGravityType.html#radialBasis">parametrizationGravity:radialBasis</a>             with <a class="groops-class" href="kernelType.html#coefficients">kernel:coefficients</a>     </li></ul>    </ul> <li><a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>   <ul>      </li><li> <a class="groops-class" href="normalEquationType.html#file">normalEquation:file</a> from <a class="groops-program" href="NormalsBuild.html">NormalsBuild</a>     </li><li> <a class="groops-class" href="normalEquationType.html#regularization">normalEquation:regularization</a>            towards zero means regularization towards the GOCO06s, which is reduced from the data.   </li></ul>  </ul></p><p><h2>Restore: Calculate the geoid solution</h2><p> Evaluate the estimated parameters and add back the reduced reference models. <ul>    <li><a class="groops-program" href="Gravityfield2GriddedData.html">Gravityfield2GriddedData</a>: Compute approximate geoid heights using the GOCO06s model with   <ul>      </li><li> <a class="groops-class" href="gridType.html">grid</a> select a grid with target resolution at elliposid     </li><li> <a class="groops-class" href="kernelType.html#geoidHeight">kernel:geoidHeight</a>     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a> GOCO06s model     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>     Subtract (<strong class="groops-config-element">factor</strong>=-1) GRS80 normal field.   </li></ul>    <li><a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a>: Move points from ellipsoid to geoid with <strong class="groops-config-element">height</strong>=<code>data0</code>   </li><li> <a class="groops-program" href="Gravityfield2GriddedData.html">Gravityfield2GriddedData</a>   <ul>      </li><li> <a class="groops-class" href="gridType.html#file">grid:file</a> from above.     </li><li> <a class="groops-class" href="kernelType.html#geoidHeight">kernel:geoidHeight</a>     </li><li> <a class="groops-class" href="gravityfieldType.html#fromParametrization">gravityfield:fromParametrization</a>           The solution vector $\\M x$ together with the RBF parametrization     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a> GOCO06s model     </li><li> <a class="groops-class" href="gravityfieldType.html#topography">gravityfield:topography</a>           (<strong class="groops-config-element">radialUpperBound</strong>=<code>data0+data1</code>, <strong class="groops-config-element">radialLowerBound</strong>=<code>data1</code>)     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>           Subtract (<strong class="groops-config-element">factor</strong>=-1) the potential part of the topography already included in the GOCO06s model.     </li><li> <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a>           Subtract (<strong class="groops-config-element">factor</strong>=-1) GRS80 normal field.     </li><li> <strong class="groops-config-element">convertToHarmonics</strong>=<code>no</code>, otherwise the RBF are converted to harmonics up to degree 7000.   </li></ul>    <li><a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a>: Set <strong class="groops-config-element">height</strong>=0 of the computed geoid grid.   </li><li> <a class="groops-program" href="GridRectangular2NetCdf.html">GridRectangular2NetCdf</a> </li></ul> </p><p></p><p>'},
'AutoregressiveModel2CovarianceMatrix': { 'name': 'AutoregressiveModel2CovarianceMatrix', 'key': 'AutoregressiveModel2CovarianceMatrix', 'description': 'This program computes the covariance structure of a random process represented by an AR model sequence. The covariance matrix is determined by accumulating the normal equations of all AR models in  autoregressiveModelSequence  and inverting the combined normal equation matrix. For each output file in   This program computes the covariance structure of a random process represented by an AR model sequence. The covariance matrix is determined by accumulating the normal equations of all AR models in  , the covariance matrix of appropriate time lag is saved (the first file contains the auto-covariance, second file cross covariance and so on). The matrix for lag   describes the covariance between   and  , i.e.  .', 'config_table': 'outputfileCovarianceMatrix filename covariance matrix for each lag autoregressiveModelSequence autoregressiveModelSequenceType AR model sequence', 'display_text': 'This program computes the covariance structure of a random process represented by an AR model sequence. The covariance matrix is determined by accumulating the normal equations of all AR models in <strong class="groops-config-element">autoregressiveModelSequence</strong> and inverting the combined normal equation matrix. For each output file in <a class="groops-class" href="fileFormat_matrix.html">outputfileCovarianceMatrix</a>, the covariance matrix of appropriate time lag is saved (the first file contains the auto-covariance, second file cross covariance and so on). The matrix for lag $h$ describes the covariance between $x_{t-h}$ and $x_{t}$, i.e. $\\Sigma(t-h, t)$.'},
'CovarianceFunction2DigitalFilter': { 'name': 'CovarianceFunction2DigitalFilter', 'key': 'CovarianceFunction2DigitalFilter', 'description': 'Computes digital filter coefficients for a   Computes digital filter coefficients for a   of given degree and order. The filter coefficients are computed by fitting them to an approximated impulse response represented by the cholesky factor of the covariance matrix. The parameter  warmup  determines from which element of the cholesky matrix the coefficients (default: half the covariance length) are fitted. Per default, the program computes filter coefficients which generate colored noise when applied to a white noise sequence. When  decorrelationFilter  is set, a decorrelation filter is computed which yields white noise when applied to colored noise.', 'config_table': 'outputfileFilter filename filter coefficients inputfileCovariance filename first column: time steps, following columns: covariance functions column uint Column with covariance function to be fitted warmup uint number of samples until diagonal of Cholesky factor is flat (default: half covariance length) numeratorDegree uint Maximum degree of numerator polynomial (MA constituent) denominatorDegree uint Maximum degree of denominator polynomial (AR constitutent) decorrelationFilter boolean compute a decorrelation filter', 'display_text': 'Computes digital filter coefficients for a <a class="groops-class" href="digitalFilterType.html">digital filter</a> of given degree and order. The filter coefficients are computed by fitting them to an approximated impulse response represented by the cholesky factor of the covariance matrix.</p><p>The parameter <strong class="groops-config-element">warmup</strong> determines from which element of the cholesky matrix the coefficients (default: half the covariance length) are fitted.</p><p>Per default, the program computes filter coefficients which generate colored noise when applied to a white noise sequence. When <strong class="groops-config-element">decorrelationFilter</strong> is set, a decorrelation filter is computed which yields white noise when applied to colored noise.'},
'CovarianceFunction2PowerSpectralDensity': { 'name': 'CovarianceFunction2PowerSpectralDensity', 'key': 'CovarianceFunction2PowerSpectralDensity', 'description': 'One sided Power Spectral Density (PSD) from a covariance function. The first column of   One sided Power Spectral Density (PSD) from a covariance function. The first column of   should contain the time lag in seconds. Multiple covariance functions (in the following column)s are supported. The output is a  matrix  with first column contains the frequency   and the other columns the PSD  . Conversion between covariance function   and PSD   is performed by discrete cosine transformation:   See also  PowerSpectralDensity2CovarianceFunction .', 'config_table': 'outputfilePSD filename first column: frequency [Hz], other columns PSD [unit^2/Hz] inputfileCovarianceFunction filename first column: time steps, following columns: covariance functions', 'display_text': 'One sided Power Spectral Density (PSD) from a covariance function. The first column of <a class="groops-class" href="fileFormat_matrix.html">inputfileCovarianceFunction</a> should contain the time lag in seconds. Multiple covariance functions (in the following column)s are supported. The output is a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> with first column contains the frequency $[Hz]$ and the other columns the PSD $[unit^2/Hz]$.</p><p>Conversion between covariance function $c_j$ and PSD $p_k$ is performed by discrete cosine transformation: \\[ p_k = 2\\Delta t\\left(c_0 + c_{n-1} (-1)^k + \\sum_{j=1}^{n-2} 2 c_j \\cos(\\pi jk/(n-1))\\right). \\] See also <a class="groops-program" href="PowerSpectralDensity2CovarianceFunction.html">PowerSpectralDensity2CovarianceFunction</a>.'},
'CovarianceMatrix2AutoregressiveModel': { 'name': 'CovarianceMatrix2AutoregressiveModel', 'key': 'CovarianceMatrix2AutoregressiveModel', 'description': 'This program computes a VAR(p) model from empirical covariance matrices. The   This program computes a VAR(p) model from empirical covariance matrices. The   represent the covariance structure of the process: the first file should contain the auto-covariance, the second the cross-covariance of lag one, the next cross-covariance of lag two and so on. Cross-covariance matrices   are defined as the cross-covariance between epoch   and  . If the process realizations   are arrange by ascending time stamps ( ), the covariance structure of the (stationary) process is therefore given by   The estimate AR model is saved as single matrix  outputfileAutoregressiveModel  according to the GROOPS AR model conventions.', 'config_table': 'outputfileAutoregressiveModel filename coefficients and white noise covariance of AR(p) model inputfileCovarianceMatrix filename file name of covariance matrix', 'display_text': 'This program computes a VAR(p) model from empirical covariance matrices. The <a class="groops-class" href="fileFormat_matrix.html">inputfileCovarianceMatrix</a> represent the covariance structure of the process: the first file should contain the auto-covariance, the second the cross-covariance of lag one, the next cross-covariance of lag two and so on.</p><p>Cross-covariance matrices $\\Sigma_{\\Delta_k}$ are defined as the cross-covariance between epoch $t-k$ and $t$. If the process realizations $x_{t}$ are arrange by ascending time stamps ($\\{\\dots, x_{t-2}, x_{t-1}, x_{t}, x_{t+1}, x_{t+2},\\dots\\}$), the covariance structure of the (stationary) process is therefore given by \\[ \\begin{bmatrix} \\Sigma & \\Sigma_{\\Delta_1} & \\Sigma_{\\Delta_2} & \\cdots \\\\ \\Sigma_{\\Delta_1}^T & \\Sigma & \\Sigma_{\\Delta_1} &  \\cdots \\\\ \\Sigma_{\\Delta_2}^T & \\Sigma_{\\Delta_1}^T & \\Sigma & \\cdots \\\\ \\vdots & \\vdots & \\vdots & \\ddots \\\\ \\end{bmatrix}. \\] The estimate AR model is saved as single matrix <strong class="groops-config-element">outputfileAutoregressiveModel</strong> according to the GROOPS AR model conventions.'},
'CovarianceMatrix2Correlation': { 'name': 'CovarianceMatrix2Correlation', 'key': 'CovarianceMatrix2Correlation', 'description': 'This program computes the pearson correlation coefficient  from a given covariance matrix stored in   This program computes the pearson correlation coefficient  . The result is stored in   This program computes the pearson correlation coefficient  .', 'config_table': 'outputfileCorrelationMatrix filename correlation matrix inputfileCovarianceMatrix filename covariance matrix', 'display_text': 'This program computes the pearson correlation coefficient \\[   \\rho_{ij} = \\frac{\\sigma_{ij}}{\\sigma_i \\sigma_j} \\]from a given covariance matrix stored in <a class="groops-class" href="fileFormat_matrix.html">inputfileCovarianceMatrix</a>. The result is stored in <a class="groops-class" href="fileFormat_matrix.html">outputfileCorrelationMatrix</a>.'},
'PowerSpectralDensity2CovarianceFunction': { 'name': 'PowerSpectralDensity2CovarianceFunction', 'key': 'PowerSpectralDensity2CovarianceFunction', 'description': 'Covariance function from Power Spectral Density (PSD). The   Covariance function from Power Spectral Density (PSD). The   contains in the first column the frequency  , followed by (possibly multiple) PSDs  . The output is a  matrix , the first column containing time lag   and the other columns the covariance functions  . Conversion between PSD   and covariance function   is performed by discrete cosine transformation:   See also  CovarianceFunction2PowerSpectralDensity .', 'config_table': 'outputfileCovarianceFunction filename first column: time steps [seconds], following columns: covariance functions inputfilePSD filename first column: frequency [Hz], following columns PSD [unit^2/Hz]', 'display_text': 'Covariance function from Power Spectral Density (PSD). The <a class="groops-class" href="fileFormat_matrix.html">inputfilePSD</a> contains in the first column the frequency $[Hz]$, followed by (possibly multiple) PSDs $[unit^2/Hz]$. The output is a <a class="groops-file" href="fileFormat_matrix.html">matrix</a>, the first column containing time lag $[s]$ and the other columns the covariance functions $[unit^2]$. Conversion between PSD $p_j$ and covariance function $c_k$ is performed by discrete cosine transformation: \\[ c_k = \\frac{1}{4\\Delta t (n-1)}\\left(p_0 + p_{n-1} (-1)^k + \\sum_{j=1}^{n-2} 2 p_j \\cos(\\pi jk/(n-1))\\right). \\] See also <a class="groops-program" href="CovarianceFunction2PowerSpectralDensity.html">CovarianceFunction2PowerSpectralDensity</a>.'},
'DoodsonAdmittanceInterpolation': { 'name': 'DoodsonAdmittanceInterpolation', 'key': 'DoodsonAdmittanceInterpolation', 'description': 'To visualize the interpolation of the minor tides. The output is a  matrix  with the first column containing the tidal frequency, the second column is the tide generating amplitude (from   To visualize the interpolation of the minor tides. The output is a  ), and the following columns the contribution of the major tides to the this tidal frequency as defined in in   To visualize the interpolation of the minor tides. The output is a  .', 'config_table': 'outputfile filename  inputfileAdmittance filename interpolation of minor constituents inputfileTideGeneratingPotential filename', 'display_text': 'To visualize the interpolation of the minor tides. The output is a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> with the first column containing the tidal frequency, the second column is the tide generating amplitude (from <a class="groops-class" href="fileFormat_tideGeneratingPotential.html">inputfileTideGeneratingPotential</a>), and the following columns the contribution of the major tides to the this tidal frequency as defined in in <a class="groops-class" href="fileFormat_admittance.html">inputfileAdmittance</a>.</p><p>'},
'DoodsonAdmittanceTimeSeries': { 'name': 'DoodsonAdmittanceTimeSeries', 'key': 'DoodsonAdmittanceTimeSeries', 'description': 'To visualize the interpolation of the minor tides it computes cosine multipliers of all major tides. Without admittance this would be a simple cos oscillation. The  outputfileTimeSeries  is an  instrument file  (MISCVALUES) containining the cos of all the major tides.', 'config_table': 'outputfileTimeSeries filename MISCVALUES (cos of major tides, ...) inputfileAdmittance filename cos/sin multipliers of the major tides timeSeries timeSeriesType', 'display_text': 'To visualize the interpolation of the minor tides it computes cosine multipliers of all major tides. Without admittance this would be a simple cos oscillation. The <strong class="groops-config-element">outputfileTimeSeries</strong> is an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES) containining the cos of all the major tides.</p><p>'},
'DoodsonArguments2TimeSeries': { 'name': 'DoodsonArguments2TimeSeries', 'key': 'DoodsonArguments2TimeSeries', 'description': 'Time series of doodson/fundamental arguments. The   Time series of doodson/fundamental arguments. The   contains the six Doodson arguments, followed by the five fundamental arguments in radians.', 'config_table': 'outputfileTimeSeries filename each epoch: 6 doodson args, 5 fundamental args [rad] timeSeries timeSeriesType', 'display_text': 'Time series of doodson/fundamental arguments. The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> contains the six Doodson arguments, followed by the five fundamental arguments in radians.'},
'DoodsonHarmonics2GriddedAmplitudeAndPhase': { 'name': 'DoodsonHarmonics2GriddedAmplitudeAndPhase', 'key': 'DoodsonHarmonics2GriddedAmplitudeAndPhase', 'description': 'This program reads a   This program reads a   and evaluates a single tidal constituent selected by  dooddson  (Doodson number or Darwins name, e.g. 255.555 or M2). This program computes the amplitude and phase from the cos and sin coefficients on a given   This program reads a  . The type of functional (e.g gravity anomalies or geoid heights) can be choosen with   This program reads a  . The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening . To visualize the results use  PlotMap .', 'config_table': 'outputfileGrid filename ampl, phase [-pi,pi], cos, sin inputfileDoodsonHarmonics filename  doodson doodson tidal constituent filter sphericalHarmonicsFilterType  grid gridType  kernel kernelType  minDegree uint  maxDegree uint  factor double the values on grid are multiplied by this factor R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program reads a <a class="groops-class" href="fileFormat_doodsonHarmonic.html">inputfileDoodsonHarmonics</a> and evaluates a single tidal constituent selected by <strong class="groops-config-element">dooddson</strong> (Doodson number or Darwins name, e.g. 255.555 or M2). This program computes the amplitude and phase from the cos and sin coefficients on a given <a class="groops-class" href="gridType.html">grid</a>. The type of functional (e.g gravity anomalies or geoid heights) can be choosen with <a class="groops-class" href="kernelType.html">kernel</a>. The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>. To visualize the results use <a class="groops-program" href="PlotMap.html">PlotMap</a>.</p><p>'},
'DoodsonHarmonics2PotentialCoefficients': { 'name': 'DoodsonHarmonics2PotentialCoefficients', 'key': 'DoodsonHarmonics2PotentialCoefficients', 'description': 'The   The   contains a Fourier series of a time variable gravitational potential at specific tidal frequencies (tides)  where   and   are spherical harmonics expansions. If set the expansions are limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . The   The   is not a single file but a series of files. For each spherical harmonics expansion   and   a separate file is created where the variables  variableLoopName ,  variableLoopDoodson ,  variableLoopCosSin  are set accordingly. The file name should contain these variables, e.g.  coeff.{name}.{doodson}.{cossin}.gfc . If  applyXi  the Doodson-Warburg phase correction (see IERS conventions) is applied to the cos/sin potentialCoefficients before.', 'config_table': 'outputfilePotentialCoefficients filename  variableLoopName string variable with darwins\'s name of each constituent variableLoopDoodson string variable with doodson code of each constituent variableLoopCosSin string variable with \'cos\' or \'sin\' of each constituent variableLoopIndex string variable with index of each constituent (starts with zero) variableLoopCount string variable with total number of constituents inputfileDoodsonHarmonics filename  inputfileTideGeneratingPotential filename to compute Xi phase correction minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius applyXi boolean apply Doodson-Warburg phase correction (see IERS conventions)', 'display_text': 'The <a class="groops-class" href="fileFormat_doodsonHarmonic.html">inputfileDoodsonHarmonics</a> contains a Fourier series of a time variable gravitational potential at specific tidal frequencies (tides) \\[ V(\\M x,t) = \\sum_{f} V_f^c(\\M x)\\cos(\\theta_f(t)) + V_f^s(\\M x)\\sin(\\theta_f(t)), \\]where $V_f^c(\\M x)$ and $V_f^s(\\M x)$ are spherical harmonics expansions. If set the expansions are limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>The <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a> is not a single file but a series of files. For each spherical harmonics expansion $V_f^c(\\M x)$ and $V_f^s(\\M x)$ a separate file is created where the variables <strong class="groops-config-element">variableLoopName</strong>, <strong class="groops-config-element">variableLoopDoodson</strong>, <strong class="groops-config-element">variableLoopCosSin</strong> are set accordingly. The file name should contain these variables, e.g. <code>coeff.{name}.{doodson}.{cossin}.gfc</code>.</p><p>If <strong class="groops-config-element">applyXi</strong> the Doodson-Warburg phase correction (see IERS conventions) is applied to the cos/sin potentialCoefficients before.'},
'DoodsonHarmonicsCalculateAdmittance': { 'name': 'DoodsonHarmonicsCalculateAdmittance', 'key': 'DoodsonHarmonicsCalculateAdmittance', 'description': 'Computes the admittance function to interpolate minor tides from tides given in   Computes the admittance function to interpolate minor tides from tides given in   using   Computes the admittance function to interpolate minor tides from tides given in  .', 'config_table': 'outputfileAdmittance filename  inputfileDoodsonHarmonics filename  inputfileTideGeneratingPotential filename TGP threshold double [m^2/s^2] only interpolate tides with TGP greater than threshold degreeInterpolation uint polynomial degree for interpolation degreeExtrapolation uint polynomial degree for extrapolation excludeDoodsonForInterpolation doodson major tides not used for interpolation', 'display_text': 'Computes the admittance function to interpolate minor tides from tides given in <a class="groops-class" href="fileFormat_doodsonHarmonic.html">inputfileDoodsonHarmonics</a> using <a class="groops-class" href="fileFormat_tideGeneratingPotential.html">inputfileTideGeneratingPotential</a>.'},
'ModelEquilibriumTide': { 'name': 'ModelEquilibriumTide', 'key': 'ModelEquilibriumTide', 'description': 'Computes the equilibrium ocean tide of the long periodic  tideGeneratingPotential . The ocean surface is represented by   Computes the equilibrium ocean tide of the long periodic   and the gravitational effect is numerical integrated to spherical harmonics using  maxDegree ,  GM , and  R . It takes self attraction and loading into account using the Love numbers   Computes the equilibrium ocean tide of the long periodic   and   Computes the equilibrium ocean tide of the long periodic  . Additionally the effects of the solid Earth tide are considered, both the gravitational (Love numbers  k20 ,  k20plus ) and the geometrical (Love numbers  h20,0 ,  h20,2 ) effect. See also  PotentialCoefficients2DoodsonHarmonics .', 'config_table': 'outputfilePotentialCoefficients filename includes the loading gridOcean gridType  maxDegree uint  GM double Geocentric gravitational constant R double reference radius density double [kg/m**3] density of sea water tideGeneratingPotential double [m**2/s**2] k20 double earth tide love number k20plus double earth tide love number h20_0 double earth tide love number h20_2 double earth tide love number inputfilePotentialLoadLoveNumber filename  inputfileDeformationLoadLoveNumber filename', 'display_text': 'Computes the equilibrium ocean tide of the long periodic <strong class="groops-config-element">tideGeneratingPotential</strong>.</p><p>The ocean surface is represented by <a class="groops-class" href="gridType.html">gridOcean</a> and the gravitational effect is numerical integrated to spherical harmonics using <strong class="groops-config-element">maxDegree</strong>, <strong class="groops-config-element">GM</strong>, and <strong class="groops-config-element">R</strong>.</p><p>It takes self attraction and loading into account using the Love numbers <a class="groops-class" href="fileFormat_matrix.html">inputfilePotentialLoadLoveNumber</a> and <a class="groops-class" href="fileFormat_matrix.html">inputfileDeformationLoadLoveNumber</a>.</p><p>Additionally the effects of the solid Earth tide are considered, both the gravitational (Love numbers <strong class="groops-config-element">k20</strong>, <strong class="groops-config-element">k20plus</strong>) and the geometrical (Love numbers <strong class="groops-config-element">h20,0</strong>, <strong class="groops-config-element">h20,2</strong>) effect.</p><p>See also <a class="groops-program" href="PotentialCoefficients2DoodsonHarmonics.html">PotentialCoefficients2DoodsonHarmonics</a>.</p><p>'},
'PotentialCoefficients2DoodsonHarmonics': { 'name': 'PotentialCoefficients2DoodsonHarmonics', 'key': 'PotentialCoefficients2DoodsonHarmonics', 'description': 'Create a  DoodsonHarmonic file  from a list of cos/sin  potentialCoefficients  for given  doodson  (Doodson number or Darwins name, e.g. 255.555 or M2) tidal constituents. If  applyXi  the Doodson-Warburg phase correction (see IERS conventions) is applied before.', 'config_table': 'outputfileDoodsonHarmonics filename  inputfileTideGeneratingPotential filename to compute Xi phase correction constituent sequence  doodson doodson  inputfileCosPotentialCoefficients filename  inputfileSinPotentialCoefficients filename  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius applyXi boolean apply Doodson-Warburg phase correction (see IERS conventions)', 'display_text': 'Create a <a class="groops-file" href="fileFormat_doodsonHarmonic.html">DoodsonHarmonic file</a> from a list of cos/sin <a class="groops-file" href="fileFormat_potentialCoefficients.html">potentialCoefficients</a> for given <strong class="groops-config-element">doodson</strong> (Doodson number or Darwins name, e.g. 255.555 or M2) tidal constituents. If <strong class="groops-config-element">applyXi</strong> the Doodson-Warburg phase correction (see IERS conventions) is applied before.'},
'GnssAntennaDefinition2ParameterVector': { 'name': 'GnssAntennaDefinition2ParameterVector', 'key': 'GnssAntennaDefinition2ParameterVector', 'description': 'Estimates parameters of a parametrization of   Estimates parameters of a parametrization of  , which represents all antennas from   Estimates parameters of a parametrization of   matching the wildcard patterns of  name ,  serial ,  radome . The provided values at the grid points of the pattern of each gnssType are used as pseudo-observations. A subset of patterns can be selected with   Estimates parameters of a parametrization of  . The  GnssAntennaDefinition file  can be modified to the demands before with  GnssAntennaDefinitionCreate . See also  ParameterVector2GnssAntennaDefinition .', 'config_table': 'outputfileSolution filename  outputfileParameterNames filename  antennaCenterVariations parametrizationGnssAntennaType  inputfileAntennaDefinition filename  name string  serial string  radome string  types gnssType if not set, all types in the file are used', 'display_text': 'Estimates parameters of a parametrization of <a class="groops-class" href="parametrizationGnssAntennaType.html">antennaCenterVariations</a>, which represents all antennas from <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a> matching the wildcard patterns of <strong class="groops-config-element">name</strong>, <strong class="groops-config-element">serial</strong>, <strong class="groops-config-element">radome</strong>.</p><p>The provided values at the grid points of the pattern of each gnssType are used as pseudo-observations. A subset of patterns can be selected with <a class="groops-class" href="gnssType.html">types</a>.</p><p>The <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">GnssAntennaDefinition file</a> can be modified to the demands before with <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>.</p><p>See also <a class="groops-program" href="ParameterVector2GnssAntennaDefinition.html">ParameterVector2GnssAntennaDefinition</a>.'},
'GnssAntennaDefinition2Skyplot': { 'name': 'GnssAntennaDefinition2Skyplot', 'key': 'GnssAntennaDefinition2Skyplot', 'description': 'Produce a  skyplot  of antenna center variations which can be plotted with  PlotMap . The first antenna from   Produce a   matching the wildcard patterns of  name ,  serial ,  radome  is used. For each antenna pattern (gnssType) a separate data column is computed. A subset of patterns can be selected with   Produce a  . Azimuth and elevation are written as ellipsoidal longitude and latitude in a  griddedData file . The choosen ellipsoid parameters  R  and  inverseFlattening  are arbitrary but should be the same as in   Produce a   and  PlotMap .', 'config_table': 'outputfileGriddedData filename data column for each gnssType inputfileAntennaDefinition filename  grid gridType  name string  serial string  radome string  types gnssType if not set, all types in the file are used R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'Produce a <a class="groops-file" href="fileFormat_griddedData.html">skyplot</a> of antenna center variations which can be plotted with <a class="groops-program" href="PlotMap.html">PlotMap</a>.</p><p>The first antenna from <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a> matching the wildcard patterns of <strong class="groops-config-element">name</strong>, <strong class="groops-config-element">serial</strong>, <strong class="groops-config-element">radome</strong> is used.</p><p>For each antenna pattern (gnssType) a separate data column is computed. A subset of patterns can be selected with <a class="groops-class" href="gnssType.html">types</a>.</p><p>Azimuth and elevation are written as ellipsoidal longitude and latitude in a <a class="groops-file" href="fileFormat_griddedData.html">griddedData file</a>. The choosen ellipsoid parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong> are arbitrary but should be the same as in <a class="groops-class" href="gridType.html">grid</a> and <a class="groops-program" href="PlotMap.html">PlotMap</a>.</p><p>'},
'GnssAntennaDefinitionCreate': { 'name': 'GnssAntennaDefinitionCreate', 'key': 'GnssAntennaDefinitionCreate', 'description': 'Create a  GNSS antenna definition file  (Antenna Center Variations, ACV) consisting of multiple antennas. The antennas can be created from scratch or can be selected from existing files. This program can also be used to modify existing files. Furthermore it can be used to create accuracy definition files containing azimuth and elevation dependent accuracy values for antennas. To create an accuracy pattern for phase observations with  1 mm  accuracy at zenith and no azimuth dependency, define a pattern with  type = L ,  values = 0.001/cos(zenith/rho) . The antennas in   Create a   are sorted by names and duplicates are removed (first one is kept).', 'config_table': 'outputfileAntennaDefinition filename  antenna gnssAntennaDefintionListType', 'display_text': 'Create a <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">GNSS antenna definition file</a> (Antenna Center Variations, ACV) consisting of multiple antennas. The antennas can be created from scratch or can be selected from existing files. This program can also be used to modify existing files.</p><p>Furthermore it can be used to create accuracy definition files containing azimuth and elevation dependent accuracy values for antennas. To create an accuracy pattern for phase observations with <code>1 mm</code> accuracy at zenith and no azimuth dependency, define a pattern with <strong class="groops-config-element">type</strong>=<code>L</code>, <strong class="groops-config-element">values</strong>=<code>0.001/cos(zenith/rho)</code>.</p><p>The antennas in <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">outputfileAntennaDefinition</a> are sorted by names and duplicates are removed (first one is kept).'},
'GnssAntennaNormalsConstraint': { 'name': 'GnssAntennaNormalsConstraint', 'key': 'GnssAntennaNormalsConstraint', 'description': 'Apply constraints to  normal equations  containing   Apply constraints to  . Usually the antenna center variations are estimated together with other parameters like station coordinates, signal biases and slant TEC in  GnssProcessing . This results in a rank deficient matrix as not all parameters can be separated. The deficient can be solved by adding pseudo observation equations as constraints. To separate antenna center variations and signal biases apply  constraint:mean  for each GNSS   Apply constraints to  . The observation equation for the integral mean of antenna center variations (ACV) in all azimuth   and elevation   dependent directions  is approximated by a grid defined by  deltaAzimuth ,  deltaZenith , and  maxZenith . To separate from station coordinates use  constraint:centerMean  and from slant TEC parameters use  constraint:TEC . The constraints are applied separately to all antennas matching the wildcard patterns of  name ,  serial ,  radome . See also  ParameterVector2GnssAntennaDefinition .', 'config_table': 'outputfileNormalEquation filename with applied constraints inputfileNormalEquation filename  constraint choice  center sequence zero center (x,y,z) of a single pattern type gnssType applied for each matching types applyWeight boolean from normal equations sigma double [m] centerMean sequence zero center (x,y,z) as (weighted) mean of all patterns applyWeight boolean from normal equations sigma double [m] constant sequence zero constant (mean of all directions) of a single pattern type gnssType applied for each matching types applyWeight boolean from normal equations sigma double [m] constantMean sequence zero constant (mean of all directions) as (weighted) mean of all patterns applyWeight boolean from normal equations sigma double [m] TEC sequence zero TEC computed as (weighetd) least squares from all types applyWeight boolean from normal equations sigma double [TECU] antennaCenterVariations parametrizationGnssAntennaType  antennaName string apply constraints to all machting antennas antennaSerial string apply constraints to all machting antennas antennaRadome string apply constraints to all machting antennas deltaAzimuth angle [degree] sampling of pattern to estimate center/constant deltaZenith angle [degree] sampling of pattern to estimate center/constant maxZenith angle [degree] sampling of pattern to estimate center/constant', 'display_text': 'Apply constraints to <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a> containing <a class="groops-class" href="parametrizationGnssAntennaType.html">antennaCenterVariations</a>. Usually the antenna center variations are estimated together with other parameters like station coordinates, signal biases and slant TEC in <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. This results in a rank deficient matrix as not all parameters can be separated. The deficient can be solved by adding pseudo observation equations as constraints.</p><p>To separate antenna center variations and signal biases apply <strong class="groops-config-element">constraint:mean</strong> for each GNSS <a class="groops-class" href="gnssType.html">type</a>. The observation equation for the integral mean of antenna center variations (ACV) in all azimuth $A$ and elevation $E$ dependent directions \\[   0 = \\iint ACV(A,E)\\, d\\Phi \\approx \\sum_i ACV(A_i,E_i)\\, \\Delta\\Phi_i \\]is approximated by a grid defined by <strong class="groops-config-element">deltaAzimuth</strong>, <strong class="groops-config-element">deltaZenith</strong>, and <strong class="groops-config-element">maxZenith</strong>.</p><p>To separate from station coordinates use <strong class="groops-config-element">constraint:centerMean</strong> and from slant TEC parameters use <strong class="groops-config-element">constraint:TEC</strong>.</p><p>The constraints are applied separately to all antennas matching the wildcard patterns of <strong class="groops-config-element">name</strong>, <strong class="groops-config-element">serial</strong>, <strong class="groops-config-element">radome</strong>.</p><p>See also <a class="groops-program" href="ParameterVector2GnssAntennaDefinition.html">ParameterVector2GnssAntennaDefinition</a>.'},
'GnssAttitudeInfoCreate': { 'name': 'GnssAttitudeInfoCreate', 'key': 'GnssAttitudeInfoCreate', 'description': 'Creates attitude info file ( Instrument(MISCVALUES) ) used by  SimulateStarCameraGnss . One or more  attitudeInfo s can be specified. They are valid from  timeStart  until the start of the subsequent  attitudeInfo .  maxManeuverTime  is used by  SimulateStarCameraGnss  to look for ongoing orbit maneuvers before/after the given orbit that might affect the attitude at the beginning or end of a given orbit. Here is a list of GNSS satellite types for which the attitude behavior is known and their respective attitude modes and required parameters:    GPS-II/IIA  [1]      defaultMode : nominalYawSteering    midnightMode : shadowMaxYawSteeringAndRecovery    noonMode : catchUpYawSteering    maxYawRate : 0.12 deg/s    yawBias : 0.5 deg    maxManeuverTime : 2 h    GPS-IIR/IIR-M  [1]      defaultMode : nominalYawSteering    midnightMode : catchUpYawSteering    noonMode : catchUpYawSteering    maxYawRate : 0.2 deg/s    maxManeuverTime : 30 min    GPS-IIF  [2]      defaultMode : nominalYawSteering    midnightMode : shadowConstantYawSteering    noonMode : catchUpYawSteering    maxYawRate : 0.11 deg/s    yawBias : -0.7 deg    maxManeuverTime : 1.5 h    GLO-M  [3]      defaultMode : nominalYawSteering    midnightMode : shadowMaxYawSteeringAndStop    noonMode : centeredMaxYawSteering    maxYawRate : 0.25 deg/s    noonBetaThreshold : 2 deg    maxManeuverTime : 1.5 h    GAL-1  [4]      defaultMode : nominalYawSteering    midnightMode : smoothedYawSteering1    noonMode : smoothedYawSteering1    maxManeuverTime : 1.5 h    GAL-2  [4]      defaultMode : nominalYawSteering    midnightMode : smoothedYawSteering2    noonMode : smoothedYawSteering2    midnightBetaThreshold : 4.1 deg    noonBetaThreshold : 4.1 deg    activationThreshold : 10 deg    maxManeuverTime : 5656 s    BDS-2G/3G  [5, 6]      defaultMode : orbitNormal    midnightMode : orbitNormal    noonMode : orbitNormal    BDS-2I  [5]      defaultMode : nominalYawSteering    midnightMode : betaDependentOrbitNormal    noonMode : betaDependentOrbitNormal    maxYawRate : 0.085 deg/s    midnightBetaThreshold : 4 deg    noonBetaThreshold : 4 deg    activationThreshold : 5 deg    maxManeuverTime : 24 h    BDS-2M  [5]      defaultMode : nominalYawSteering    midnightMode : betaDependentOrbitNormal    noonMode : betaDependentOrbitNormal    maxYawRate : 0.159 deg/s    midnightBetaThreshold : 4 deg    noonBetaThreshold : 4 deg    activationThreshold : 5 deg    maxManeuverTime : 13 h    BDS-3I/3SI  [6]      defaultMode : nominalYawSteering    midnightMode : smoothedYawSteering2    noonMode : smoothedYawSteering2    midnightBetaThreshold : 3 deg    noonBetaThreshold : 3 deg    activationThreshold : 6 deg    maxManeuverTime : 5740 s    BDS-3M/3SM  [6]      defaultMode : nominalYawSteering    midnightMode : smoothedYawSteering2    noonMode : smoothedYawSteering2    midnightBetaThreshold : 3 deg    noonBetaThreshold : 3 deg    activationThreshold : 6 deg    maxManeuverTime : 3090 s    QZS-1  [7]      defaultMode : nominalYawSteering    midnightMode : betaDependentOrbitNormal    noonMode : betaDependentOrbitNormal    maxYawRate : 0.01 deg/s    yawBias : 180 deg    midnightBetaThreshold : 20 deg    noonBetaThreshold : 20 deg    activationThreshold : 18.5 deg    maxManeuverTime : 24 h    QZS-2G  [7]      defaultMode : orbitNormal    midnightMode : orbitNormal    noonMode : orbitNormal    yawBias : 180 deg    QZS-2I  [7]      defaultMode : nominalYawSteering    midnightMode : centeredMaxYawSteering    noonMode : centeredMaxYawSteering    maxYawRate : 0.055 deg/s    midnightBetaThreshold : 5 deg    noonBetaThreshold : 5 deg    maxManeuverTime : 1.5 h    Some specific satellites may deviate in their attitude behavior or parameters (e.g. G013-G040, R713, C005, C015, C017, J001). References for the attitude behavior information:          https://www.gsc-europa.eu/support-to-developers/galileo-satellite-metadata#3       https://qzss.go.jp/en/technical/qzssinfo/index.html', 'config_table': 'outputfileAttitudeInfo filename  attitudeInfo sequence  timeStart time  defaultMode choice default attitude mode nominalYawSteering  yaw to keep solar panels aligned to Sun (e.g. most GNSS satellites outside eclipse) orbitNormal  keep fixed yaw angle, for example point X-axis in flight direction (e.g. BDS-2G, BDS-3G, QZS-2G) midnightMode choice attitude mode for maneuvers around orbit midnight nominalYawSteering  yaw to keep solar panels aligned to Sun (e.g. most GNSS satellites outside eclipse) orbitNormal  keep fixed yaw angle, for example point X-axis in flight direction (e.g. BDS-2G, BDS-3G, QZS-2G) catchUpYawSteering  yaw at maximum yaw rate to catch up to nominal yaw angle (e.g. GPS-* (noon), GPS-IIR (midnight)) shadowMaxYawSteeringAndRecovery  yaw at maximum yaw rate from shadow start to end, recover after shadow (e.g. GPS-IIA (midnight)) shadowMaxYawSteeringAndStop  yaw at maximum yaw rate from shadow start until nominal yaw angle at shadow end is reached, then stop (e.g. GLO-M (midnight)) shadowConstantYawSteering  yaw at constant yaw rate from shadow start to end (e.g. GPS-IIF (midnight)) centeredMaxYawSteering  yaw at maximum yaw rate centered around noon/midnight (e.g. QZS-2I, GLO-M (noon)) smoothedYawSteering1  yaw based on an auxiliary Sun vector for a smooth yaw maneuver (e.g. GAL-1) smoothedYawSteering2  yaw based on a modified yaw-steering law for a smooth yaw maneuver (e.g. GAL-2, BDS-3M, BDS-3I) betaDependentOrbitNormal  switch to orbit normal mode if below beta angle threshold (e.g. BDS-2M, BDS-2I, QZS-1) noonMode choice attitude mode for maneuvers around orbit noon nominalYawSteering  yaw to keep solar panels aligned to Sun (e.g. most GNSS satellites outside eclipse) orbitNormal  keep fixed yaw angle, for example point X-axis in flight direction (e.g. BDS-2G, BDS-3G, QZS-2G) catchUpYawSteering  yaw at maximum yaw rate to catch up to nominal yaw angle (e.g. GPS-* (noon), GPS-IIR (midnight)) centeredMaxYawSteering  yaw at maximum yaw rate centered around noon/midnight (e.g. QZS-2I, GLO-M (noon)) smoothedYawSteering1  yaw based on an auxiliary Sun vector for a smooth yaw maneuver (e.g. GAL-1) smoothedYawSteering2  yaw based on a modified yaw-steering law for a smooth yaw maneuver (e.g. GAL-2, BDS-3M, BDS-3I) betaDependentOrbitNormal  switch to orbit normal mode if below beta angle threshold (e.g. BDS-2M, BDS-2I, QZS-1) maxYawRate double [degree/s] maximum yaw rate of the satellite yawBias double [degree] yaw bias applied in satellite attitude control system midnightBetaThreshold double [degree] limit midnight maneuver to this absolute angle of the Sun above/below the satellite orbital plane noonBetaThreshold double [degree] limit noon maneuver to this absolute angle of the Sun above/below the satellite orbital plane activationThreshold double [degree] limit maneuver to this yaw/Earth-spacecraft-Sun angle (depending on mode) maxManeuverTime double [s] maximum duration of maneuver or maximum maneuver lookup time before/after orbit start/end', 'display_text': 'Creates attitude info file (<a class="groops-file" href="fileFormat_instrument.html">Instrument(MISCVALUES)</a>) used by <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a>. One or more <strong class="groops-config-element">attitudeInfo</strong>s can be specified. They are valid from <strong class="groops-config-element">timeStart</strong> until the start of the subsequent <strong class="groops-config-element">attitudeInfo</strong>. <strong class="groops-config-element">maxManeuverTime</strong> is used by <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a> to look for ongoing orbit maneuvers before/after the given orbit that might affect the attitude at the beginning or end of a given orbit.</p><p></p><p>Here is a list of GNSS satellite types for which the attitude behavior is known and their respective attitude modes and required parameters: <ul>  <li><b>GPS-II/IIA</b> [1] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: shadowMaxYawSteeringAndRecovery   </li><li> <strong class="groops-config-element">noonMode</strong>: catchUpYawSteering   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.12 deg/s   </li><li> <strong class="groops-config-element">yawBias</strong>: 0.5 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 2 h </li></ul>  <li><b>GPS-IIR/IIR-M</b> [1] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: catchUpYawSteering   </li><li> <strong class="groops-config-element">noonMode</strong>: catchUpYawSteering   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.2 deg/s   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 30 min </li></ul>  <li><b>GPS-IIF</b> [2] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: shadowConstantYawSteering   </li><li> <strong class="groops-config-element">noonMode</strong>: catchUpYawSteering   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.11 deg/s   </li><li> <strong class="groops-config-element">yawBias</strong>: -0.7 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 1.5 h </li></ul>  <li><b>GLO-M</b> [3] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: shadowMaxYawSteeringAndStop   </li><li> <strong class="groops-config-element">noonMode</strong>: centeredMaxYawSteering   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.25 deg/s   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 2 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 1.5 h </li></ul>  <li><b>GAL-1</b> [4] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: smoothedYawSteering1   </li><li> <strong class="groops-config-element">noonMode</strong>: smoothedYawSteering1   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 1.5 h </li></ul>  <li><b>GAL-2</b> [4] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: smoothedYawSteering2   </li><li> <strong class="groops-config-element">noonMode</strong>: smoothedYawSteering2   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 4.1 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 4.1 deg   </li><li> <strong class="groops-config-element">activationThreshold</strong>: 10 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 5656 s </li></ul>  <li><b>BDS-2G/3G</b> [5, 6] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: orbitNormal   </li><li> <strong class="groops-config-element">midnightMode</strong>: orbitNormal   </li><li> <strong class="groops-config-element">noonMode</strong>: orbitNormal </li></ul>  <li><b>BDS-2I</b> [5] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: betaDependentOrbitNormal   </li><li> <strong class="groops-config-element">noonMode</strong>: betaDependentOrbitNormal   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.085 deg/s   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 4 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 4 deg   </li><li> <strong class="groops-config-element">activationThreshold</strong>: 5 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 24 h </li></ul>  <li><b>BDS-2M</b> [5] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: betaDependentOrbitNormal   </li><li> <strong class="groops-config-element">noonMode</strong>: betaDependentOrbitNormal   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.159 deg/s   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 4 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 4 deg   </li><li> <strong class="groops-config-element">activationThreshold</strong>: 5 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 13 h </li></ul>  <li><b>BDS-3I/3SI</b> [6] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: smoothedYawSteering2   </li><li> <strong class="groops-config-element">noonMode</strong>: smoothedYawSteering2   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 3 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 3 deg   </li><li> <strong class="groops-config-element">activationThreshold</strong>: 6 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 5740 s </li></ul>  <li><b>BDS-3M/3SM</b> [6] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: smoothedYawSteering2   </li><li> <strong class="groops-config-element">noonMode</strong>: smoothedYawSteering2   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 3 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 3 deg   </li><li> <strong class="groops-config-element">activationThreshold</strong>: 6 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 3090 s </li></ul>  <li><b>QZS-1</b> [7] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: betaDependentOrbitNormal   </li><li> <strong class="groops-config-element">noonMode</strong>: betaDependentOrbitNormal   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.01 deg/s   </li><li> <strong class="groops-config-element">yawBias</strong>: 180 deg   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 20 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 20 deg   </li><li> <strong class="groops-config-element">activationThreshold</strong>: 18.5 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 24 h </li></ul>  <li><b>QZS-2G</b> [7] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: orbitNormal   </li><li> <strong class="groops-config-element">midnightMode</strong>: orbitNormal   </li><li> <strong class="groops-config-element">noonMode</strong>: orbitNormal   </li><li> <strong class="groops-config-element">yawBias</strong>: 180 deg </li></ul>  <li><b>QZS-2I</b> [7] <ul>    </li><li> <strong class="groops-config-element">defaultMode</strong>: nominalYawSteering   </li><li> <strong class="groops-config-element">midnightMode</strong>: centeredMaxYawSteering   </li><li> <strong class="groops-config-element">noonMode</strong>: centeredMaxYawSteering   </li><li> <strong class="groops-config-element">maxYawRate</strong>: 0.055 deg/s   </li><li> <strong class="groops-config-element">midnightBetaThreshold</strong>: 5 deg   </li><li> <strong class="groops-config-element">noonBetaThreshold</strong>: 5 deg   </li><li> <strong class="groops-config-element">maxManeuverTime</strong>: 1.5 h </li></ul>  </ul></p><p>Some specific satellites may deviate in their attitude behavior or parameters (e.g. G013-G040, R713, C005, C015, C017, J001).</p><p>References for the attitude behavior information: <ol>  <li><a href="https://doi.org/10.1007/s10291-008-0092-1">Kouba (2009)</a> </li><li> <a href="https://doi.org/10.1007/s10291-016-0562-9">Kuang et al. (2017)</a> </li><li> <a href="https://doi.org/10.1016/j.asr.2010.09.007">Dilssner et al. (2011)</a> </li><li> <a href="https://www.gsc-europa.eu/support-to-developers/galileo-satellite-metadata#3" target="_blank">https://www.gsc-europa.eu/support-to-developers/galileo-satellite-metadata#3</a> </li><li> <a href="https://doi.org/10.1007/s10291-018-0783-1">Wang et al. (2018)</a> </li><li> <a href="https://doi.org/10.1017/S0373463318000103">Li et al. (2018)</a> </li><li> <a href="https://qzss.go.jp/en/technical/qzssinfo/index.html" target="_blank">https://qzss.go.jp/en/technical/qzssinfo/index.html</a> </li></ol>'},
'GnssBiasClockAlignment': { 'name': 'GnssBiasClockAlignment', 'key': 'GnssBiasClockAlignment', 'description': 'This program can be used to absolutely align GNSS transmitter clocks to reference clocks (i.e. broadcast clocks). Each \'group\' of  transmitter s, usually a system like GPS or Galileo, is aligned individually by a constant shift over all transmitters. If  alignClocksByFreqNo  is set, GLONASS transmitters will be divided by frequency number into groups of nominally two transmitters. The offset between clocks and reference clocks will be shifted into receiver code biases, if  receiver  is provided." By setting  alignFreqNoBiasesAtReceiver  and providing  receiver , this program can further align GLONASS transmitter signal biases so that the differences between frequency number-dependent receiver signal biases are minimal, which helps if PPP users don\'t set up individual signal biases per frequency number at the receiver. Alignment is done by computing signal bias residuals to the mean over all frequency numbers of a signal type at each receiver and then computing the means over all receivers for each frequency number and shifting those from the receiver signal biases to the transmitter signal biases. Internal consistency of the biases is not affected by this. If you only want to align GLONASS frequency numbers, provide the same clocks in   This program can be used to absolutely align GNSS transmitter clocks to reference clocks (i.e. broadcast clocks). Each \'group\' of   and   This program can be used to absolutely align GNSS transmitter clocks to reference clocks (i.e. broadcast clocks). Each \'group\' of  .', 'config_table': 'transmitter sequence one element per satellite outputfileClock filename aligned clock instrument file outputfileSignalBias filename (GLONASS only) aligned signal bias file inputfileClock filename clock instrument file inputfileReferenceClock filename reference clock instrument file inputfileSignalBias filename (GLONASS only) signal bias file inputfileTransmitterInfo filename transmitter platform file receiver sequence one element per station outputfileSignalBias filename aligned signal bias file inputfileSignalBias filename signal bias file alignClocksByFreqNo boolean align clocks for each GLONASS frequency number separately alignFreqNoBiasesAtReceiver boolean align frequency number-dependent code biases for each receiver', 'display_text': 'This program can be used to absolutely align GNSS transmitter clocks to reference clocks (i.e. broadcast clocks). Each \'group\' of <strong class="groops-config-element">transmitter</strong>s, usually a system like GPS or Galileo, is aligned individually by a constant shift over all transmitters. If <strong class="groops-config-element">alignClocksByFreqNo</strong> is set, GLONASS transmitters will be divided by frequency number into groups of nominally two transmitters. The offset between clocks and reference clocks will be shifted into receiver code biases, if <strong class="groops-config-element">receiver</strong> is provided."</p><p>By setting <strong class="groops-config-element">alignFreqNoBiasesAtReceiver</strong> and providing <strong class="groops-config-element">receiver</strong>, this program can further align GLONASS transmitter signal biases so that the differences between frequency number-dependent receiver signal biases are minimal, which helps if PPP users don\'t set up individual signal biases per frequency number at the receiver. Alignment is done by computing signal bias residuals to the mean over all frequency numbers of a signal type at each receiver and then computing the means over all receivers for each frequency number and shifting those from the receiver signal biases to the transmitter signal biases. Internal consistency of the biases is not affected by this.</p><p>If you only want to align GLONASS frequency numbers, provide the same clocks in <a class="groops-class" href="fileFormat_instrument.html">inputfileClock</a> and <a class="groops-class" href="fileFormat_instrument.html">inputfileReferenceClock</a>.'},
'GnssEstimateClockShift': { 'name': 'GnssEstimateClockShift', 'key': 'GnssEstimateClockShift', 'description': 'This program estimates an epoch-wise clock shift in a constellation of GNSS satellites. Each separate  data  represents a satellite... (e.g. 32 GPS satellites). The shift to reference clocks can be estimated by providing   This program estimates an epoch-wise clock shift in a constellation of GNSS satellites. Each separate  . Clock shifts are estimated for each epoch given by   This program estimates an epoch-wise clock shift in a constellation of GNSS satellites. Each separate  .', 'config_table': 'outputfileShiftTimeSeries filename columns: mjd, clock shift data sequence e.g. satellite outputfileInstrument filename corrected clocks outputfileInstrumentDiff filename clock difference after correction inputfileInstrument filename input clocks inputfileInstrumentRef filename reference clocks (subtracted from input clocks) timeSeries timeSeriesType clock epochs margin double [s] margin for time comparison', 'display_text': 'This program estimates an epoch-wise clock shift in a constellation of GNSS satellites. Each separate <strong class="groops-config-element">data</strong> represents a satellite... (e.g. 32 GPS satellites). The shift to reference clocks can be estimated by providing <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrumentRef</a>. Clock shifts are estimated for each epoch given by <a class="groops-class" href="timeSeriesType.html">timeSeries</a>.'},
'GnssGlonassFrequencyNumberUpdate': { 'name': 'GnssGlonassFrequencyNumberUpdate', 'key': 'GnssGlonassFrequencyNumberUpdate', 'description': 'Update/set GLONASS frequency number in   Update/set GLONASS frequency number in   files. PRN/SVN to frequency number source:  http://semisys.gfz-potsdam.de/semisys/api/?symname=2002&format=json&satellite=GLO . See also  GnssAntex2AntennaDefinition .', 'config_table': 'outputfileTransmitterInfo filename templated for PRN list (variableNamePrn) inputfileTransmitterInfo filename templated for PRN list (variableNamePrn) inputfilePrn2FrequencyNumber filename GROOPS matrix with columns: GLONASS PRN, SVN, mjdStart, mjdEnd, frequencyNumber prn string PRN (e.g. R01) for transmitter info files variableNamePrn string variable name for PRN in transmitter info files', 'display_text': 'Update/set GLONASS frequency number in <a class="groops-class" href="fileFormat_platform.html">inputfileTransmitterInfo</a> files.</p><p>PRN/SVN to frequency number source: <a href="http://semisys.gfz-potsdam.de/semisys/api/?symname=2002&format=json&satellite=GLO" target="_blank">http://semisys.gfz-potsdam.de/semisys/api/?symname=2002&format=json&satellite=GLO</a>.</p><p>See also <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a>.'},
'GnssPrn2SvnBlockVariables': { 'name': 'GnssPrn2SvnBlockVariables', 'key': 'GnssPrn2SvnBlockVariables', 'description': 'Create  variables  containing SVN and block based on an   Create   of a GNSS satellite/PRN and a specified  time .', 'config_table': 'variableSVN string name of the SVN variable variableBlock string name of the satellites block variable inputfileTransmitterInfo filename used for GNSS PRN-to-SVN/model relation time time used for GNSS PRN-to-SVN/model relation', 'display_text': 'Create <a class="groops-ref" href="general.parser.html">variables</a> containing SVN and block based on an <a class="groops-class" href="fileFormat_platform.html">inputfileTransmitterInfo</a> of a GNSS satellite/PRN and a specified <strong class="groops-config-element">time</strong>.'},
'GnssProcessing': { 'name': 'GnssProcessing', 'key': 'GnssProcessing', 'description': 'This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. The primary use cases of this program are:      GNSS satellite orbit determination and station network analysis     Kinematic orbit determination of LEO satellites     GNSS precise point positioning (PPP)   The observation epochs are defined by   This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it.  and only observations at these epochs (within a  timeMargin ) are considered. To calculate observation equations from the tracks, the model parameters or unknown parameters need to be defined beforehand. These unknown parameters can be chosen arbitrarily by the user with an adequate list of defined   This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. . Some of the   This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it.  also include a priori models. Lastly it is required to define the process flow of the gnssProcessing. This is accomplished with a list of   This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. . Each step is processed consecutively. Some steps allow the selection of parameters, epochs, or the normal equation structure, which affects all subsequent steps. A minimal example consists of following steps:       This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. : iterative float solution with outlier downeighting     This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. :         fix ambiguities to integer and remove them from the normals     This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. : few iteration for final outlier downweighting     This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. :         write the output files defined in   This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it.   If the program is run on multiple processes the   This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it. s (stations or LEO satellites) are distributed over the processes. See also  GnssSimulateReceiver .', 'config_table': 'timeSeries timeSeriesType defines observation epochs timeMargin double [seconds] margin to consider two times identical transmitter gnssTransmitterGeneratorType constellation of GNSS satellites receiver gnssReceiverGeneratorType ground station network or LEO satellite earthRotation earthRotationType apriori earth rotation parametrization gnssParametrizationType models and parameters processingStep gnssProcessingStepType steps are processed consecutively', 'display_text': 'This program processes GNSS observations. It calculates the linearized observation equations, accumulates them into a system of normal equations and solves it.</p><p>The primary use cases of this program are: <ul>    <li><a class="groops-ref" href="cookbook.gnssNetwork.html">GNSS satellite orbit determination and station network analysis</a>   </li><li> <a class="groops-ref" href="cookbook.kinematicOrbit.html">Kinematic orbit determination of LEO satellites</a>   </li><li> <a class="groops-ref" href="cookbook.gnssPpp.html">GNSS precise point positioning (PPP)</a> </li></ul> </p><p>The observation epochs are defined by <a class="groops-class" href="timeSeriesType.html">timeSeries</a> and only observations at these epochs (within a <strong class="groops-config-element">timeMargin</strong>) are considered.</p><p>To calculate observation equations from the tracks, the model parameters or unknown parameters need to be defined beforehand. These unknown parameters can be chosen arbitrarily by the user with an adequate list of defined <a class="groops-class" href="gnssParametrizationType.html">parametrization</a>. Some of the <a class="groops-class" href="gnssParametrizationType.html">parametrization</a> also include a priori models.</p><p>Lastly it is required to define the process flow of the gnssProcessing. This is accomplished with a list of <a class="groops-class" href="gnssProcessingStepType.html">processingSteps</a>. Each step is processed consecutively. Some steps allow the selection of parameters, epochs, or the normal equation structure, which affects all subsequent steps. A minimal example consists of following steps: <ul>    <li><a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: iterative float solution with outlier downeighting   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">resolveAmbiguities</a>:         fix ambiguities to integer and remove them from the normals   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>: few iteration for final outlier downweighting   </li><li> <a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a>:         write the output files defined in <a class="groops-class" href="gnssParametrizationType.html">parametrization</a> </li></ul> </p><p>If the program is run on multiple processes the <a class="groops-class" href="gnssReceiverGeneratorType.html">receiver</a>s (stations or LEO satellites) are distributed over the processes.</p><p>See also <a class="groops-program" href="GnssSimulateReceiver.html">GnssSimulateReceiver</a>.'},
'GnssReceiverDefinitionCreate': { 'name': 'GnssReceiverDefinitionCreate', 'key': 'GnssReceiverDefinitionCreate', 'description': 'Create a  GNSS receiver definition file .', 'config_table': 'outputfileGnssReceiverDefinition filename  receiverDefinition sequence  name string  serial string  version string  comment string  gnssType gnssType', 'display_text': 'Create a <a class="groops-file" href="fileFormat_gnssReceiverDefinition.html">GNSS receiver definition file</a>.'},
'GnssResiduals2AccuracyDefinition': { 'name': 'GnssResiduals2AccuracyDefinition', 'key': 'GnssResiduals2AccuracyDefinition', 'description': 'Compute antenna accuracies from observation   Compute antenna accuracies from observation  . The   Compute antenna accuracies from observation   is needed to assign the residuals to the equipped antenna at observation times. The   Compute antenna accuracies from observation   contains at first step the same accuracy information for all antennas as the input file. Only the azimuth   and elevation   dependent grid points of the patterns where enough residuals are available (   minRedundancy ) are replaced by estimated accuracy  where   are the azimuth and elevation dependent residuals and   the corresponding redundancies (number of observations minus the contribution to the estimated parameters). The   Compute antenna accuracies from observation   can be modified to the demands before with  GnssAntennaDefinitionCreate  (e.g. with  antenna:resample ). To verify the results the   Compute antenna accuracies from observation   and the accumulated   Compute antenna accuracies from observation   of the computed pattern grid points can be written. Example: Analysis of TerraSAR-X residuals of one month shows that low elevation GPS satellites are not tracked by the onboard receiver. An estimation of accuracies for these directions is not possible from the residuals and the apriori accuracies are left untouched. The other directions show very low phase noise hardly elevation and azimuth dependent for L2W. A nearly zero mean indicates the use of adequate antennca center variations in the processing.', 'config_table': 'outputfileAccuracyDefinition filename elevation and azimuth dependent accuracy outputfileAntennaMean filename weighted mean of the residuals outputfileAntennaRedundancy filename redundancy of adjustment inputfileAccuracyDefinition filename apriori accuracies inputfileStationInfo filename to assign residuals to antennas isTransmitter boolean stationInfo is of a transmitter thresholdOutlier double ignore residuals with sigma/sigma0 greater than threshold minRedundancy double min number of residuals. to estimate sigma inputfileResiduals filename GNSS receiver residuals', 'display_text': 'Compute antenna accuracies from observation <a class="groops-class" href="fileFormat_instrument.html">inputfileResiduals</a>. The <a class="groops-class" href="fileFormat_platform.html">inputfileStationInfo</a> is needed to assign the residuals to the equipped antenna at observation times.</p><p>The <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">outputfileAccuracyDefinition</a> contains at first step the same accuracy information for all antennas as the input file. Only the azimuth $A$ and elevation $E$ dependent grid points of the patterns where enough residuals are available ($>$ <strong class="groops-config-element">minRedundancy</strong>) are replaced by estimated accuracy \\[  \\sigma(A,E) = \\sqrt{\\frac{\\sum_i e_i^2(A,E)}{\\sum_i r_i(A,E)}}, \\]where $e_i$ are the azimuth and elevation dependent residuals and $r_i$ the corresponding redundancies (number of observations minus the contribution to the estimated parameters).</p><p>The <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAccuracyDefinition</a> can be modified to the demands before with <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a> (e.g. with <strong class="groops-config-element">antenna:resample</strong>).</p><p>To verify the results the <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">outputfileAntennaMean</a> and the accumulated <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">outputfileAntennaRedundancy</a> of the computed pattern grid points can be written.</p><p>Example: Analysis of TerraSAR-X residuals of one month shows that low elevation GPS satellites are not tracked by the onboard receiver. An estimation of accuracies for these directions is not possible from the residuals and the apriori accuracies are left untouched. The other directions show very low phase noise hardly elevation and azimuth dependent for L2W. A nearly zero mean indicates the use of adequate antennca center variations in the processing.</p><p>'},
'GnssResiduals2Skyplot': { 'name': 'GnssResiduals2Skyplot', 'key': 'GnssResiduals2Skyplot', 'description': 'Write GNSS residuals together with azimuth and elevation to be plotted with  PlotMap . Azimuth and elevation are written as ellipsoidal longitude and latitude in a  griddedData file . The choosen ellipsoid parameters  R  and  inverseFlattening  are arbitrary but should be the same as in  PlotMap . If with   Write GNSS residuals together with azimuth and elevation to be plotted with   (e.g. \' ***G18 \') a single transmitter is selected the azimuth and elevation are computed from the transmitter point of view. For each GNSS   Write GNSS residuals together with azimuth and elevation to be plotted with   an extra data column is created. A  GNSS residual file  includes additional information besides the residuals, which can also be selected with   Write GNSS residuals together with azimuth and elevation to be plotted with      A1* ,  E1* : azimuth and elevation at receiver  A2* ,  E2* : azimuth and elevation at transmitter  I** : Estimated slant total electron content (STEC)  Furthermore these files may include for each residual   Write GNSS residuals together with azimuth and elevation to be plotted with   information about the redundancy and the accuracy relation   of the estimated   versus the apriori   from the least squares adjustment. The 3 values (residuals, redundancy,  ) are coded with the same type. To get access to all values the corresponding type must be repeated in   Write GNSS residuals together with azimuth and elevation to be plotted with  .', 'config_table': 'outputfileGriddedData filename  type gnssType  typeTransmitter gnssType choose transmitter view, e.g. \'***G18\' inputfileResiduals filename GNSS receiver residuals R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'Write GNSS residuals together with azimuth and elevation to be plotted with <a class="groops-program" href="PlotMap.html">PlotMap</a>. Azimuth and elevation are written as ellipsoidal longitude and latitude in a <a class="groops-file" href="fileFormat_griddedData.html">griddedData file</a>. The choosen ellipsoid parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong> are arbitrary but should be the same as in <a class="groops-program" href="PlotMap.html">PlotMap</a>. If with <a class="groops-class" href="gnssType.html">typeTransmitter</a> (e.g. \'<code>***G18</code>\') a single transmitter is selected the azimuth and elevation are computed from the transmitter point of view.</p><p>For each GNSS <a class="groops-class" href="gnssType.html">type</a> an extra data column is created.</p><p>A <a class="groops-file" href="fileFormat_instrument.html">GNSS residual file</a> includes additional information besides the residuals, which can also be selected with <a class="groops-class" href="gnssType.html">type</a> <ul>  <li><code>A1*</code>, <code>E1*</code>: azimuth and elevation at receiver </li><li> <code>A2*</code>, <code>E2*</code>: azimuth and elevation at transmitter </li><li> <code>I**</code>: Estimated slant total electron content (STEC) </li></ul> </p><p>Furthermore these files may include for each residual <a class="groops-class" href="gnssType.html">type</a> information about the redundancy and the accuracy relation $\\sigma/\\sigma_0$ of the estimated $\\sigma$ versus the apriori $\\sigma_0$ from the least squares adjustment. The 3 values (residuals, redundancy, $\\sigma/\\sigma_0$) are coded with the same type. To get access to all values the corresponding type must be repeated in <a class="groops-class" href="gnssType.html">type</a>.</p><p>'},
'GnssSignalBias2Matrix': { 'name': 'GnssSignalBias2Matrix', 'key': 'GnssSignalBias2Matrix', 'description': 'Computes signal biases for a given list of   Computes signal biases for a given list of  . If the type list is empty, all types contained in   Computes signal biases for a given list of   are used. The resulting   Computes signal biases for a given list of   contains a vector with an entry for each type.', 'config_table': 'outputfileMatrix filename  outputfileTypes filename ASCII list of types inputfileSignalBias filename  types gnssType if not set, all types in the file are used', 'display_text': 'Computes signal biases for a given list of <a class="groops-class" href="gnssType.html">types</a>. If the type list is empty, all types contained in <a class="groops-class" href="fileFormat_gnssSignalBias.html">inputfileSignalBias</a> are used. The resulting <a class="groops-class" href="fileFormat_matrix.html">outputfileMatrix</a> contains a vector with an entry for each type.'},
'GnssSimulateReceiver': { 'name': 'GnssSimulateReceiver', 'key': 'GnssSimulateReceiver', 'description': 'This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  GnssProcessing , for example to conduct closed-loop simulations. One or more GNSS constellations must be defined via   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  . Receivers such as ground station networks or Low Earth Orbit (LEO) satellites can be defined via   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  . If multiple receivers defined an   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in   and   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in   are written for each single receiver with the  variable   {station}  being replaced by the receiver name. A list of simulated observation types can be defined via   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  . Noise can be added to both observations and clock errors via   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in   and   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  , respectively. Observation noise is interpreted as a factor that is multiplied to the accuracy derived from the accuracy pattern of the respective observation type (see   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in   in   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  ). The   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in   are used to simulate a priori models (e.g. troposphere, signal biases). Parameter settings and outputfiles are ignored. If the program is run on multiple processes the   This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in  s (stations or LEO satellites) are distributed over the processes.', 'config_table': 'outputfileGnssReceiver filename variable {station} available, simulated observations outputfileClock filename variable {station} available, simulated receiver clock errors timeSeries timeSeriesType defines observation epochs timeMargin double [seconds] margin to consider two times identical transmitter gnssTransmitterGeneratorType constellation of GNSS satellites receiver gnssReceiverGeneratorType ground station network or LEO satellite earthRotation earthRotationType apriori earth rotation parametrization gnssParametrizationType models and parameters observationType gnssType simulated observation types noiseObservation noiseGeneratorType [-] noise is multiplied with type accuracy pattern of receiver noiseClockReceiver noiseGeneratorType [m] noise added to the simulated receiver clock', 'display_text': 'This program simulates observations from receivers to GNSS satellites. These simulated observations can then be used in <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>, for example to conduct closed-loop simulations.</p><p>One or more GNSS constellations must be defined via <a class="groops-class" href="gnssTransmitterGeneratorType.html">transmitter</a>. Receivers such as ground station networks or Low Earth Orbit (LEO) satellites can be defined via <a class="groops-class" href="gnssReceiverGeneratorType.html">receiver</a>.</p><p>If multiple receivers defined an <a class="groops-class" href="fileFormat_instrument.html">outputfileGnssReceiver</a> and <a class="groops-class" href="fileFormat_instrument.html">outputfileClock</a> are written for each single receiver with the <a class="groops-ref" href="general.parser.html">variable</a> <code>{station}</code> being replaced by the receiver name.</p><p>A list of simulated observation types can be defined via <a class="groops-class" href="gnssType.html">observationType</a>. Noise can be added to both observations and clock errors via <a class="groops-class" href="noiseGeneratorType.html">noiseObervation</a> and <a class="groops-class" href="noiseGeneratorType.html">noiseClockReceiver</a>, respectively. Observation noise is interpreted as a factor that is multiplied to the accuracy derived from the accuracy pattern of the respective observation type (see <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAccuracyDefinition</a> in <a class="groops-class" href="gnssReceiverGeneratorType.html">receiver</a>).</p><p>The <a class="groops-class" href="gnssParametrizationType.html">parametrization</a> are used to simulate a priori models (e.g. troposphere, signal biases). Parameter settings and outputfiles are ignored.</p><p>If the program is run on multiple processes the <a class="groops-class" href="gnssReceiverGeneratorType.html">receiver</a>s (stations or LEO satellites) are distributed over the processes.'},
'GnssStationInfoCreate': { 'name': 'GnssStationInfoCreate', 'key': 'GnssStationInfoCreate', 'description': 'Create a  GnssStationInfo file  from scratch by defining attributes such as  markerName ,  markerNumber ,  comment ,  approxPosition ,  antenna  and  receiver . See also  GnssAntex2AntennaDefinition  and  GnssStationLog2Platform .', 'config_table': 'outputfileStationInfo filename  markerName string  markerNumber string  comment string  approxPositionX double [m] in TRF approxPositionY double [m] in TRF approxPositionZ double [m] in TRF antenna sequence  name string  serial string  radome string  comment string  timeStart time  timeEnd time  positionX double [m] ARP in north, east, up or vehicle system positionY double [m] ARP in north, east, up or vehicle system positionZ double [m] ARP in north, east, up or vehicle system rotationX angle [degree] from local/vehicle to left-handed antenna system rotationY angle [degree] from local/vehicle to left-handed antenna system rotationZ angle [degree] from local/vehicle to left-handed antenna system flipX boolean flip x-axis (after rotation) flipY boolean flip y-axis (after rotation) flipZ boolean flip z-axis (after rotation) receiver sequence  name string  serial string  version string  comment string  timeStart time  timeEnd time  referencePoint sequence e.g. center of mass in satellite frame comment string  xStart double [m] in north, east, up or vehicle system yStart double linear motion between start and end zStart double  xEnd double [m] in north, east, up or vehicle system yEnd double linear motion between start and end zEnd double  timeStart time  timeEnd time', 'display_text': 'Create a <a class="groops-file" href="fileFormat_gnssStationInfo.html">GnssStationInfo file</a> from scratch by defining attributes such as <strong class="groops-config-element">markerName</strong>, <strong class="groops-config-element">markerNumber</strong>, <strong class="groops-config-element">comment</strong>, <strong class="groops-config-element">approxPosition</strong>, <strong class="groops-config-element">antenna</strong> and <strong class="groops-config-element">receiver</strong>.</p><p>See also <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a> and <a class="groops-program" href="GnssStationLog2Platform.html">GnssStationLog2Platform</a>.'},
'InstrumentGnssReceiver2TimeSeries': { 'name': 'InstrumentGnssReceiver2TimeSeries', 'key': 'InstrumentGnssReceiver2TimeSeries', 'description': 'Convert selected GNSS observations or residuals into a simpler time series format. The  outputfileTimeSeries  is an  instrument file  (MISCVALUES). For each epoch the first data column contains the PRN, the second the satellite system, followed by a column for each GNSS   Convert selected GNSS observations or residuals into a simpler time series format. The  . As normally more than one GNSS transmitter is tracked per epoch, the output file has several lines per observed epoch (epochs with the same time, one for each transmitter). The second data column of the output contains a number representating the system    71: \'G\', GPS  82: \'R\', GLONASS  69: \'E\', GALILEO  67: \'C\', BDS  83: \'S\', SBAS  74: \'J\', QZSS  73: \'I\', IRNSS .  A  GNSS residual file  includes additional information besides the residuals, which can also be selected with   Convert selected GNSS observations or residuals into a simpler time series format. The      A1* ,  E1* : azimuth and elevation at receiver  A2* ,  E2* : azimuth and elevation at transmitter  I** : Estimated slant total electron content (STEC)  Furthermore these files may include for each residual   Convert selected GNSS observations or residuals into a simpler time series format. The   information about the redundancy and the accuracy relation   of the estimated   versus the apriori   from the least squares adjustment. The three values (residuals, redundancy,  ) are coded with the same type. To get access to all values the corresponding type must be repeated in   Convert selected GNSS observations or residuals into a simpler time series format. The  . Example: Selected GPS phase residuals (  Convert selected GNSS observations or residuals into a simpler time series format. The  =\' L1*G \' and   Convert selected GNSS observations or residuals into a simpler time series format. The  =\' L2*G \'). Plotted with  PlotGraph  with two   Convert selected GNSS observations or residuals into a simpler time series format. The   ( valueX =\' data0 \',   valueY =\' 100*data3+data1 \' and  valueY =\' 100*data4+data1 \' respectively).', 'config_table': 'outputfileTimeSeries filename Instrument (MISCVALUES): prn, system, values for each type inputfileGnssReceiver filename GNSS receiver observations or residuals type gnssType', 'display_text': 'Convert selected GNSS observations or residuals into a simpler time series format. The <strong class="groops-config-element">outputfileTimeSeries</strong> is an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES). For each epoch the first data column contains the PRN, the second the satellite system, followed by a column for each GNSS <a class="groops-class" href="gnssType.html">type</a>. As normally more than one GNSS transmitter is tracked per epoch, the output file has several lines per observed epoch (epochs with the same time, one for each transmitter).</p><p>The second data column of the output contains a number representating the system <ul>  <li>71: \'G\', GPS </li><li> 82: \'R\', GLONASS </li><li> 69: \'E\', GALILEO </li><li> 67: \'C\', BDS </li><li> 83: \'S\', SBAS </li><li> 74: \'J\', QZSS </li><li> 73: \'I\', IRNSS . </li></ul> </p><p>A <a class="groops-file" href="fileFormat_instrument.html">GNSS residual file</a> includes additional information besides the residuals, which can also be selected with <a class="groops-class" href="gnssType.html">type</a> <ul>  <li><code>A1*</code>, <code>E1*</code>: azimuth and elevation at receiver </li><li> <code>A2*</code>, <code>E2*</code>: azimuth and elevation at transmitter </li><li> <code>I**</code>: Estimated slant total electron content (STEC) </li></ul> </p><p>Furthermore these files may include for each residual <a class="groops-class" href="gnssType.html">type</a> information about the redundancy and the accuracy relation $\\sigma/\\sigma_0$ of the estimated $\\sigma$ versus the apriori $\\sigma_0$ from the least squares adjustment. The three values (residuals, redundancy, $\\sigma/\\sigma_0$) are coded with the same type. To get access to all values the corresponding type must be repeated in <a class="groops-class" href="gnssType.html">type</a>.</p><p>Example: Selected GPS phase residuals (<a class="groops-class" href="gnssType.html">type</a>=\'<code>L1*G</code>\' and <a class="groops-class" href="gnssType.html">type</a>=\'<code>L2*G</code>\'). Plotted with <a class="groops-program" href="PlotGraph.html">PlotGraph</a> with two <a class="groops-class" href="plotGraphLayerType.html">layer:linesAndPoints</a> (<strong class="groops-config-element">valueX</strong>=\'<code>data0</code>\',  <strong class="groops-config-element">valueY</strong>=\'<code>100*data3+data1</code>\' and <strong class="groops-config-element">valueY</strong>=\'<code>100*data4+data1</code>\' respectively).'},
'ParameterVector2GnssAntennaDefinition': { 'name': 'ParameterVector2GnssAntennaDefinition', 'key': 'ParameterVector2GnssAntennaDefinition', 'description': 'Updates an  GnssAntennaDefinition file  with estimated parameters which belongs to the parametrization   Updates an  . The   Updates an   contains all antennas from   Updates an  . The antenna center variations representend by the   Updates an   are added to the matching antennas. The  GnssAntennaDefinition file  can be modified to the demands before with  GnssAntennaDefinitionCreate . The following steps are used to estimate antenna center variations:    GnssAntennaDefinitionCreate  or  GnssAntex2AntennaDefinition   GnssProcessing  with  inputfileAntennaDefinition  as apriori       and writing  normal equations  with       parametrization of   Updates an    NormalsEliminate : eliminate all other than antenna parameters  NormalsAccumulate : accumulate normals over a sufficient long period  GnssAntennaNormalsConstraint : constrain unsolvable parameter linear combinations  NormalsSolverVCE : estimate the parameter vector  ParameterVector2GnssAntennaDefinition : update  inputfileAntennaDefinition   See also  ParameterVector2GnssAntennaDefinition ,  GnssAntennaNormalsConstraint .', 'config_table': 'outfileAntennaDefinition filename all apriori antennas inputfileAntennaDefinition filename apriori antennas antennaCenterVariations parametrizationGnssAntennaType  inputfileSolution filename  inputfileParameterNames filename', 'display_text': 'Updates an <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">GnssAntennaDefinition file</a> with estimated parameters which belongs to the parametrization <a class="groops-class" href="parametrizationGnssAntennaType.html">antennaCenterVariations</a>. The <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">outfileAntennaDefinition</a> contains all antennas from <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a>. The antenna center variations representend by the <a class="groops-class" href="fileFormat_matrix.html">inputfileSolution</a> are added to the matching antennas.</p><p>The <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">GnssAntennaDefinition file</a> can be modified to the demands before with <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>.</p><p>The following steps are used to estimate antenna center variations: <ul>  <li><a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a> or <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a> </li><li> <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a> with <strong class="groops-config-element">inputfileAntennaDefinition</strong> as apriori       and writing <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a> with       parametrization of <a class="groops-class" href="parametrizationGnssAntennaType.html">antennaCenterVariations</a> </li><li> <a class="groops-program" href="NormalsEliminate.html">NormalsEliminate</a>: eliminate all other than antenna parameters </li><li> <a class="groops-program" href="NormalsAccumulate.html">NormalsAccumulate</a>: accumulate normals over a sufficient long period </li><li> <a class="groops-program" href="GnssAntennaNormalsConstraint.html">GnssAntennaNormalsConstraint</a>: constrain unsolvable parameter linear combinations </li><li> <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>: estimate the parameter vector </li><li> <a class="groops-program" href="ParameterVector2GnssAntennaDefinition.html">ParameterVector2GnssAntennaDefinition</a>: update <strong class="groops-config-element">inputfileAntennaDefinition</strong> </li></ul> </p><p>See also <a class="groops-program" href="ParameterVector2GnssAntennaDefinition.html">ParameterVector2GnssAntennaDefinition</a>, <a class="groops-program" href="GnssAntennaNormalsConstraint.html">GnssAntennaNormalsConstraint</a>.'},
'EnsembleAveragingScaleModel': { 'name': 'EnsembleAveragingScaleModel', 'key': 'EnsembleAveragingScaleModel', 'description': 'This programs estimate satellite-to-satellite-tracking (SST) deterministic signals due to eclipse transits from residuals. The ensemble averaging method is used to characterize the average properties of signal shapes across all transit events. Each shape is assigned to one arc of 3 hours (default). This can be modefied by enabling  averagingInterval .', 'config_table': 'outputfileScaleModel filename  inputfileGrace1EclipseFactor filename GRACE-A eclipse factors computed with integrated orbit inputfileGrace2EclipseFactor filename GRACE-B eclipse factors computed with integrated orbit inputfileGraceResiduals filename SST Residuals timeMargin uint epochs before eclipse mode waveLength uint length of the sample wave averagingInterval sequence  nearestNeighborNumber uint', 'display_text': 'This programs estimate satellite-to-satellite-tracking (SST) deterministic signals due to eclipse transits from residuals. The ensemble averaging method is used to characterize the average properties of signal shapes across all transit events. Each shape is assigned to one arc of 3 hours (default). This can be modefied by enabling <strong class="groops-config-element">averagingInterval</strong>.'},
'GraceAntennaCenterCorrectionArcCovariance': { 'name': 'GraceAntennaCenterCorrectionArcCovariance', 'key': 'GraceAntennaCenterCorrectionArcCovariance', 'description': 'This program computes covariance information for the non-stationary noise of the KBR antenna offset correction (AOC) from the orientation covariance matrices provided in Level-1B products via variance propagation. By using the output   This program computes covariance information for the non-stationary noise of the KBR antenna offset correction (AOC) from the orientation covariance matrices provided in Level-1B products via variance propagation. By using the output   in  PreprocessingSst , noise model distinguishes between the stationary noise of ranging observations and the nonstationary AOC noise. The covariances are derived from the partial derivative of the AOC w.r.t. the roll/pitch/yaw rotations and star camera covariances   This program computes covariance information for the non-stationary noise of the KBR antenna offset correction (AOC) from the orientation covariance matrices provided in Level-1B products via variance propagation. By using the output   and   This program computes covariance information for the non-stationary noise of the KBR antenna offset correction (AOC) from the orientation covariance matrices provided in Level-1B products via variance propagation. By using the output  . The covariances for the range-rates and range-acceleration are computed by differentiating an interpolation polynomial of degree  interpolationDegree .', 'config_table': 'outputfileSatelliteTrackingCovariance filename corrections for range, range-rate, and range-accelerations sstType choice  range   rangeRate   rangeAcceleration   inputfileOrbit1 filename  inputfileOrbit2 filename  inputfileStarCamera1 filename  inputfileStarCamera2 filename  inputfileScaCovariance1 filename  inputfileScaCovariance2 filename  sigmaAccelerometerX double [rad/s^2] sigmaAccelerometerY double [rad/s^2] sigmaAccelerometerZ double [rad/s^2] antennaCenters choice KBR antenna phase center value sequence  center1X double x-coordinate of antenna position in SRF [m] for GRACEA center1Y double y-coordinate of antenna position in SRF [m] for GRACEA center1Z double z-coordinate of antenna position in SRF [m] for GRACEA center2X double x-coordinate of antenna position in SRF [m] for GRACEB center2Y double y-coordinate of antenna position in SRF [m] for GRACEB center2Z double z-coordinate of antenna position in SRF [m] for GRACEB file sequence  inputAntennaCenters filename  interpolationDegree uint differentiation by polynomial approximation of degree n', 'display_text': 'This program computes covariance information for the non-stationary noise of the KBR antenna offset correction (AOC) from the orientation covariance matrices provided in Level-1B products via variance propagation. By using the output <a class="groops-class" href="fileFormat_matrix.html">outputfileSatelliteTrackingCovariance</a> in <a class="groops-program" href="PreprocessingSst.html">PreprocessingSst</a>, noise model distinguishes between the stationary noise of ranging observations and the nonstationary AOC noise.</p><p>The covariances are derived from the partial derivative of the AOC w.r.t. the roll/pitch/yaw rotations and star camera covariances <a class="groops-class" href="fileFormat_matrix.html">inputfileScaCovariance1</a> and <a class="groops-class" href="fileFormat_matrix.html">inputfileScaCovariance2</a>.</p><p>The covariances for the range-rates and range-acceleration are computed by differentiating an interpolation polynomial of degree <strong class="groops-config-element">interpolationDegree</strong>.'},
'GraceOrbit2TransplantTimeOffset': { 'name': 'GraceOrbit2TransplantTimeOffset', 'key': 'GraceOrbit2TransplantTimeOffset', 'description': 'This program computes the time shift between two co-orbiting satellites based on dynamic orbit data. When applied to data of the first satellite, the computed time shift virtually shifts data of first satellite into the location of the second satellite. Note that  inputfileOrbit1  and  inputfileOrbit2  need velocity and acceleration data, which can be computed with  OrbitAddVelocityAndAcceleration . The program tries to find a minimum of the objective function  by applying Newton\'s method to the first derivative, thus iteratively computing  This iteration is stopped when the difference between to consecutive time shift values falls below  threshold  or  maximumIterations  is reached. An  initialGuess  of the time shift can speed up convergence. See also  OrbitAddVelocityAndAcceleration  and  InstrumentApplyTimeOffset .', 'config_table': 'outputfileTimeOffset filename estimated time offset in seconds (MISCVALUE) inputfileOrbit1 filename orbit data of satellite 1 inputfileOrbit2 filename orbit data of satellite 2 interpolationDegree uint polynomial degree for the interpolation of position, velocity and acceleration initialGuess double initial guess for the time shift [seconds] maximumIterations uint maximum number of iterations threshold double when the maximum difference between two iterations is below this value, stop [seconds]', 'display_text': 'This program computes the time shift between two co-orbiting satellites based on dynamic orbit data. When applied to data of the first satellite, the computed time shift virtually shifts data of first satellite into the location of the second satellite. Note that <strong class="groops-config-element">inputfileOrbit1</strong> and <strong class="groops-config-element">inputfileOrbit2</strong> need velocity and acceleration data, which can be computed with <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a>. The program tries to find a minimum of the objective function \\[   f(\\Delta t) = \\| r_1(t) - r_2(t + \\Delta t) \\|^2, \\]by applying Newton\'s method to the first derivative, thus iteratively computing \\[   \\Delta t_{k+1} = \\Delta t_k + \\frac{f\'(\\Delta t_k)}{f\'\'(\\Delta t_k)}. \\]This iteration is stopped when the difference between to consecutive time shift values falls below <strong class="groops-config-element">threshold</strong> or <strong class="groops-config-element">maximumIterations</strong> is reached. An <strong class="groops-config-element">initialGuess</strong> of the time shift can speed up convergence.</p><p>See also <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a> and <a class="groops-program" href="InstrumentApplyTimeOffset.html">InstrumentApplyTimeOffset</a>.'},
'GraceSstResidualAnalysis': { 'name': 'GraceSstResidualAnalysis', 'key': 'GraceSstResidualAnalysis', 'description': 'This program applies the Multi-Resolution Analysis (MRA) using Discrete Wavelet Transform (DWT) to the monthly GRACE SST post-fit residuals. First, the residuals are transferred into wavelet domain by applying an 8 level Daubechies wavelet transform (default). In the next step, detail coefficients are merged into three major groups due to their approximate frequency subbands:    Low scale details, corresponding to the frequency band above 10 mHz;  Intermediate scale details, corresponding to the approximate frequency       range above 3 mHz up to 10 mHz;  High scale details, corresponding to the approximate frequency range above 0.5 mHz up to 10 mHz.   In the last step, each group is reconstructed back into time domain.', 'config_table': 'outputfileInstrumentHighScale filename High scale details outputfileInstrumentMidScale filename Intermediate scale details outputfileInstrumentLowScale filename Low scale details inputfileInstrument filename GRACE SST Residuals inputfileWavelet filename wavelet coefficients', 'display_text': 'This program applies the Multi-Resolution Analysis (MRA) using Discrete Wavelet Transform (DWT) to the monthly GRACE SST post-fit residuals. First, the residuals are transferred into wavelet domain by applying an 8 level Daubechies wavelet transform (default). In the next step, detail coefficients are merged into three major groups due to their approximate frequency subbands: <ul>  <li>Low scale details, corresponding to the frequency band above 10 mHz; </li><li> Intermediate scale details, corresponding to the approximate frequency       range above 3 mHz up to 10 mHz; </li><li> High scale details, corresponding to the approximate frequency range above 0.5 mHz up to 10 mHz. </li></ul>  In the last step, each group is reconstructed back into time domain.'},
'GraceSstScaleModel': { 'name': 'GraceSstScaleModel', 'key': 'GraceSstScaleModel', 'description': 'This programs estimate satellite-to-satellite-tracking (SST) deterministic signals due to eclipse transits and low-SNR values from post-fit residuals. The low-SNR effects are estimated by directly using the residual values. The ensemble averaging method is used to characterize the average properties of eclipse transit signal shapes across all transit events. Each shape is assigned to one arc of 3 hours (default). This can be modefied by enabling  averagingInterval .', 'config_table': 'inputfileGraceResiduals filename SST Residuals timeMargin uint epochs before instrumental events waveLength uint length of the sample wave estimateEclipseTransitScale sequence  outputfileScaleModel filename  inputfileGrace1EclipseFactor filename GRACE-A eclipse factors computed with integrated orbit inputfileGrace2EclipseFactor filename GRACE-B eclipse factors computed with integrated orbit averagingInterval sequence  nearestNeighborNumber uint  estimateLowSnrScale sequence  outputfileScaleModel filename  inputfileGraceSstSNR filename GRACE SNR values', 'display_text': 'This programs estimate satellite-to-satellite-tracking (SST) deterministic signals due to eclipse transits and low-SNR values from post-fit residuals. The low-SNR effects are estimated by directly using the residual values. The ensemble averaging method is used to characterize the average properties of eclipse transit signal shapes across all transit events. Each shape is assigned to one arc of 3 hours (default). This can be modefied by enabling <strong class="groops-config-element">averagingInterval</strong>.'},
'GraceSstSpecialEvents': { 'name': 'GraceSstSpecialEvents', 'key': 'GraceSstSpecialEvents', 'description': 'Time-indexing deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. The events are determined by satellites\' position (  Time-indexing deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. The events are determined by satellites\' position ( ) and orientation (  Time-indexing deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. The events are determined by satellites\' position ( ). Each type of event is represented by its mid-interval point per orbit revolution and is reported in   Time-indexing deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. The events are determined by satellites\' position ( . The waveform of each event is nearly constant within one month and can be approximated by a polynomial. For the purpose of gravity field recovery, each waveform is parameterized by a polynomial and the coefficients of this polynomial are estimated as additional instrument calibration parameters in a common adjustment with all other instrument, satellite, and gravity field parameters, see   Time-indexing deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. The events are determined by satellites\' position ( .', 'config_table': 'outputfileEvents filename  outputfileIntervals filename  inputfileOrbit1 filename  inputfileOrbit2 filename  inputfileStarCamera1 filename  inputfileStarCamera2 filename  ephemerides ephemeridesType  eclipse eclipseType  marginLeft double margin size (on both sides) [seconds] marginRight double margin size (on both sides) [seconds]', 'display_text': 'Time-indexing deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. The events are determined by satellites\' position (<a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit1/2</a>) and orientation (<a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera1/2</a>). Each type of event is represented by its mid-interval point per orbit revolution and is reported in <a class="groops-class" href="fileFormat_instrument.html">outputfileEvents</a>.</p><p>The waveform of each event is nearly constant within one month and can be approximated by a polynomial. For the purpose of gravity field recovery, each waveform is parameterized by a polynomial and the coefficients of this polynomial are estimated as additional instrument calibration parameters in a common adjustment with all other instrument, satellite, and gravity field parameters, see <a class="groops-class" href="parametrizationSatelliteTrackingType.html#specialEffect">parametrizationSatelliteTracking:specialEffect</a>.'},
'GraceThrusterResponse2Accelerometer': { 'name': 'GraceThrusterResponse2Accelerometer', 'key': 'GraceThrusterResponse2Accelerometer', 'description': 'Add modeled thruster responses to accelerometer data. The epochs and durations are given in the   Add modeled thruster responses to accelerometer data. The epochs and durations are given in the   (THRUSTER). The   Add modeled thruster responses to accelerometer data. The epochs and durations are given in the   is a   matrix with the linear accelerations in the SRF ( ) in one line per pair:    Negative Yaw,  Positive Pitch,  Positive Yaw,  Negative Pitch,  Negative Roll,  Positive Roll.', 'config_table': 'outputfileAccelerometer filename ACCELEROMETER inputfileAccelerometer filename ACCELEROMETER inputfileThruster filename THRUSTER inputfileThrusterResponse filename thruster model (matrix with one line per pair)', 'display_text': 'Add modeled thruster responses to accelerometer data. The epochs and durations are given in the <a class="groops-class" href="fileFormat_instrument.html">inputfileThruster</a> (THRUSTER).</p><p>The <a class="groops-class" href="fileFormat_matrix.html">inputfileThrusterResponse</a> is a $(6\\times 3)$ matrix with the linear accelerations in the SRF ($x, y, z$) in one line per pair: <ol>  <li>Negative Yaw, </li><li> Positive Pitch, </li><li> Positive Yaw, </li><li> Negative Pitch, </li><li> Negative Roll, </li><li> Positive Roll. </li></ol>'},
'InstrumentSatelliteTrackingAntennaCenterCorrection': { 'name': 'InstrumentSatelliteTrackingAntennaCenterCorrection', 'key': 'InstrumentSatelliteTrackingAntennaCenterCorrection', 'description': 'This program computes the correction due to offset of the antenna center relative the center of mass. The offsets   and   in   This program computes the correction due to offset of the antenna center relative the center of mass. The offsets   are given in the satellite reference frame. These offsets are rotated into the the inertial frame with   and   from   This program computes the correction due to offset of the antenna center relative the center of mass. The offsets   and projected onto the line of sight (LOS)  with the unit vector in line of sight direction  The corrections for the range-rates and range-acceleration are computed by differentiating an interpolation polynomial of degree  interpolationDegree .', 'config_table': 'outputfileSatelliteTracking filename corrections for range, range-rate, and range-accelerations inputfileOrbit1 filename  inputfileOrbit2 filename  inputfileStarCamera1 filename  inputfileStarCamera2 filename  antennaCenters choice KBR antenna phase center value sequence  center1X double x-coordinate of antenna position in SRF [m] for GRACEA center1Y double y-coordinate of antenna position in SRF [m] for GRACEA center1Z double z-coordinate of antenna position in SRF [m] for GRACEA center2X double x-coordinate of antenna position in SRF [m] for GRACEB center2Y double y-coordinate of antenna position in SRF [m] for GRACEB center2Z double z-coordinate of antenna position in SRF [m] for GRACEB file sequence  inputAntennaCenters filename  interpolationDegree uint differentiation by polynomial approximation of degree n', 'display_text': 'This program computes the correction due to offset of the antenna center relative the center of mass. The offsets $\\M c_A$ and $\\M c_B$ in <a class="groops-class" href="fileFormat_matrix.html">inputfileAntennaCenters</a> are given in the satellite reference frame. These offsets are rotated into the the inertial frame with $\\M D_A$ and $\\M D_B$ from <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> and projected onto the line of sight (LOS) \\[   \\rho_{AOC} = \\M e_{AB}\\cdot(\\M D_A\\,\\M c_A - \\M D_B\\,\\M c_B), \\]with the unit vector in line of sight direction \\[   \\M e_{AB} = \\frac{\\M r_B - \\M r_A}{\\left\\lVert{\\M r_B - \\M r_A}\\right\\rVert}. \\]The corrections for the range-rates and range-acceleration are computed by differentiating an interpolation polynomial of degree <strong class="groops-config-element">interpolationDegree</strong>.'},
'InstrumentStarCameraAngularAccelerometerFusion': { 'name': 'InstrumentStarCameraAngularAccelerometerFusion', 'key': 'InstrumentStarCameraAngularAccelerometerFusion', 'description': 'This program estimates the satellites orientation from star camera data   This program estimates the satellites orientation from star camera data   and angular accelerometer data   This program estimates the satellites orientation from star camera data  . The combination of both observation types is achieved in a least square adjustment. The optimal weighting between the two different observation groups is achieved by means of VCE in combination with a robust estimator. The system of linearized observation equations within the sensor fusion approach can be formulated as:  with  The reference values   and   are derived from   This program estimates the satellites orientation from star camera data  . In the course of the estimation, the accelerometer data is calibrated, by setting a bias factor   with  accBias .', 'config_table': 'outputfileStarCamera filename combined quaternions outputfileCovariance filename epoch-wise covariance matrix outputfileCovarianceMatrix filename full arc-wise covariance matrix per arc. arc number is appended to filename outputfileEpochSigmaStarCamera filename from vce and outlier detection outputfileEpochSigmaAccelerometer filename from vce and outlier detection outputfileAngularAcc filename angular acceleration observations (bias removed) outputfileSolution filename estimated parameter (one column for each arc) inputfileStarCameraReference filename quaternions as taylor point inputfileStarCamera filename star camera observations inputfileStarCameraCovariance filename star camera observations inputfileAngularAcc filename angular acceleration observations correctAccNonQuadratic boolean apply correction (non-square proof mass) accBias parametrizationTemporalType accelerometer bias per interval and axis accScale parametrizationTemporalType accelerometer scale per interval and axis sigmaStarcamera double [rad] sigmaAccelerometerX double [rad/s^2] sigmaAccelerometerY double [rad/s^2] sigmaAccelerometerZ double [rad/s^2] estimateSigmaScaPerAxis boolean separate variance factor for roll, pitch, yaw, instead of one common factor. estimateSigmaAccPerAxis boolean separate variance factor for each accelerometer axis, instead of one common factor. huber double residuals > huber*sigma0 are downweighted huberPower double residuals > huber: sigma=(e/huber)^power*sigma0 interpolationDegree uint  iterationCount uint non linear equation solved iteratively', 'display_text': 'This program estimates the satellites orientation from star camera data <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> and angular accelerometer data <a class="groops-class" href="fileFormat_instrument.html">inputfileAngularAcc</a>. The combination of both observation types is achieved in a least square adjustment. The optimal weighting between the two different observation groups is achieved by means of VCE in combination with a robust estimator. The system of linearized observation equations within the sensor fusion approach can be formulated as: \\[   \\begin{bmatrix}   \\M l_{ACC1B}\\\\   \\M l_{SCA1B}   \\end{bmatrix}   =   \\begin{bmatrix}   \\M A_{ACC1B} & \\M B_{ACC1B}\\\\   \\M A_{SCA1B} & \\M 0   \\end{bmatrix}   \\begin{bmatrix}   \\M q\\\\   \\M b   \\end{bmatrix}   =   \\begin{bmatrix}   \\frac{\\partial \\dot{\\boldsymbol{\\omega}}}{\\partial \\M q} & \\frac{\\partial \\dot{\\boldsymbol{\\omega}}}{\\partial \\M b}\\\\   \\M I & \\M 0   \\end{bmatrix}   \\begin{bmatrix}   \\M q\\\\   \\M b   \\end{bmatrix} \\]with \\[\\begin{split}   \\M l_{ACC1B}  &= \\dot{\\boldsymbol{\\omega}}_{ACC1B} - \\dot{\\boldsymbol{\\omega}}_{0}, \\\\   \\M l_{SCA1B}  &= \\M q_{SCA1B} - \\M q_{0}, \\\\   \\M q_{Fusion} &= \\M q + \\M q_{0}. \\end{split}\\]The reference values $\\M q_{0}$ and $\\dot{\\boldsymbol{\\omega}}_{0}$ are derived from <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCameraReference</a>. In the course of the estimation, the accelerometer data is calibrated, by setting a bias factor $\\M b$ with <strong class="groops-config-element">accBias</strong>.'},
'Gravityfield2AbsoluteGravity': { 'name': 'Gravityfield2AbsoluteGravity', 'key': 'Gravityfield2AbsoluteGravity', 'description': 'This program computes the absolute value of gravity   of a   This program computes the absolute value of gravity   on a given   This program computes the absolute value of gravity  . The result is multiplicated with  factor . To get the full gravity vector in a terrestrial frame add the centrifugal part, see   This program computes the absolute value of gravity  . The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening . It is intended to compute gravity anomalies from absolute gravity observations. To visualize the results use  PlotMap .', 'config_table': 'outputfileGriddedData filename  grid gridType  gravityfield gravityfieldType  factor double the result is multiplied by this factor, set -1 to subtract the field time time at this time the gravity field will be evaluated R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program computes the absolute value of gravity $\\left\\lVert{\\M g}\\right\\rVert$ of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> on a given <a class="groops-class" href="gridType.html">grid</a>. The result is multiplicated with <strong class="groops-config-element">factor</strong>. To get the full gravity vector in a terrestrial frame add the centrifugal part, see <a class="groops-class" href="tidesType.html#centrifugal">gravityfield:tides:centrifugal</a>.</p><p>The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>.</p><p>It is intended to compute gravity anomalies from absolute gravity observations. To visualize the results use <a class="groops-program" href="PlotMap.html">PlotMap</a>.'},
'Gravityfield2AreaMeanTimeSeries': { 'name': 'Gravityfield2AreaMeanTimeSeries', 'key': 'Gravityfield2AreaMeanTimeSeries', 'description': 'This program computes a time series of time variable   This program computes a time series of time variable   functionals averaged over a given area, e.g. equivalent water heights in the amazon basin.  The type of functional (e.g gravity anomalies or geoid heights) can be choosen with   This program computes a time series of time variable  . The average is performed at each time step by a weigthed average over all   This program computes a time series of time variable   points where the weight is the associated area at each point. If  removeMean  is set the temporal mean is removed from the time series. To speed up the computation the gravity field can be converted to spherical harmonics before the computation with  convertToHarmonics . Additionally the root mean square of the values in the area at each time step can is computed if  compueRms  is set. Additionally the accuracy of the value at each time step can be computed if  compueSigma  is set. The   This program computes a time series of time variable   is an instrument file with one, two, or three data columns. First data column contains the computed functionals and the following columns contain the RMS and the accuracies (optionally). To visualize the results use  PlotGraph .', 'config_table': 'outputfileTimeSeries filename  grid gridType  timeSeries timeSeriesType  kernel kernelType  gravityfield gravityfieldType  convertToHarmonics boolean gravityfield is converted to spherical harmonics before evaluation, may accelerate the computation multiplyWithArea boolean multiply time series with total area (useful for mass estimates) removeMean boolean remove the temporal mean of the series computeRms boolean additional rms each time step computeSigma boolean additional error bars at each time step', 'display_text': 'This program computes a time series of time variable <a class="groops-class" href="gravityfieldType.html">gravityfield</a> functionals averaged over a given area, e.g. equivalent water heights in the amazon basin.  The type of functional (e.g gravity anomalies or geoid heights) can be choosen with <a class="groops-class" href="kernelType.html">kernel</a>. The average is performed at each time step by a weigthed average over all <a class="groops-class" href="gridType.html">grid</a> points where the weight is the associated area at each point. If <strong class="groops-config-element">removeMean</strong> is set the temporal mean is removed from the time series. To speed up the computation the gravity field can be converted to spherical harmonics before the computation with <strong class="groops-config-element">convertToHarmonics</strong>.</p><p>Additionally the root mean square of the values in the area at each time step can is computed if <strong class="groops-config-element">compueRms</strong> is set.</p><p>Additionally the accuracy of the value at each time step can be computed if <strong class="groops-config-element">compueSigma</strong> is set.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> is an instrument file with one, two, or three data columns. First data column contains the computed functionals and the following columns contain the RMS and the accuracies (optionally).</p><p>To visualize the results use <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.</p><p>'},
'Gravityfield2Deflections': { 'name': 'Gravityfield2Deflections', 'key': 'Gravityfield2Deflections', 'description': 'This program computes the deflections of the vertical   in north direction and   in east direction in radian according to  where   is the gravity vector from   This program computes the deflections of the vertical   in the local ellipsoidal system (north, east, up) and   is the normal gravity at that point. The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening .', 'config_table': 'outputfileGriddedData filename xi (north), eta (east) [rad] grid gridType  gravityfield gravityfieldType  time time at this time the gravity field will be evaluated R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program computes the deflections of the vertical $\\xi$ in north direction and $\\eta$ in east direction in radian according to \\[ \\xi = g_x/\\gamma \\qquad\\text{and}\\qquad \\eta=g_y/\\gamma, \\]where $\\M g=\\nabla V$ is the gravity vector from <a class="groops-class" href="gravityfieldType.html">gravityfield</a> in the local ellipsoidal system (north, east, up) and $\\gamma$ is the normal gravity at that point.</p><p>The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>.'},
'Gravityfield2DegreeAmplitudes': { 'name': 'Gravityfield2DegreeAmplitudes', 'key': 'Gravityfield2DegreeAmplitudes', 'description': 'This program computes degree amplitudes from a   This program computes degree amplitudes from a   and saves them to a  matrix  file with three columns: the degree, the degree amplitude, and the formal errors. The coefficients can be converted to different functionals with   This program computes degree amplitudes from a  . The gravity field can be evaluated at different altitudes by specifying  evaluationRadius . Polar regions can be excluded by setting  polarGap . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . See also  PotentialCoefficients2DegreeAmplitudes .', 'config_table': 'outputfileMatrix filename three column matrix with degree, signal amplitude, formal error gravityfield gravityfieldType  kernel kernelType  type choice type of variances rms  degree amplitudes (square root of degree variances) accumulation  cumulate variances over degrees median  meadian of absolute values per degree time time at this time the gravity field will be evaluated evaluationRadius double evaluate the gravity field at this radius (default: evaluate at surface polarGap angle exclude polar regions (aperture angle in degrees) minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius', 'display_text': 'This program computes degree amplitudes from a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> and saves them to a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> file with three columns: the degree, the degree amplitude, and the formal errors.</p><p>The coefficients can be converted to different functionals with <a class="groops-class" href="kernelType.html">kernel</a>. The gravity field can be evaluated at different altitudes by specifying <strong class="groops-config-element">evaluationRadius</strong>. Polar regions can be excluded by setting <strong class="groops-config-element">polarGap</strong>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>See also <a class="groops-program" href="PotentialCoefficients2DegreeAmplitudes.html">PotentialCoefficients2DegreeAmplitudes</a>.'},
'Gravityfield2DegreeAmplitudesPlotGrid': { 'name': 'Gravityfield2DegreeAmplitudesPlotGrid', 'key': 'Gravityfield2DegreeAmplitudesPlotGrid', 'description': 'This program computes a   This program computes a   of a time variable   This program computes a   and saves it as degree amplitudes. The expansion is limited in the range between  minDegree  and  maxDegree  inclusivly   The   This program computes a   is a matrix with every row containing the time, degree, degree amplitude, and the formal error. To visualize the results use  PlotGraph ). See also  Gravityfield2DegreeAmplitudes .', 'config_table': 'outputfileTimeSeries filename each row: mjd, degree, amplitude, formal error gravityfield gravityfieldType  kernel kernelType  timeSeries timeSeriesType  evaluationRadius double evaluate the gravity field at this radius (default: evaluate at surface polarGap angle exclude polar regions (aperture angle in degrees) minDegree uint minimal degree maxDegree uint maximal degree GM double Geocentric gravitational constant R double reference radius', 'display_text': 'This program computes a <a class="groops-class" href="timeSeriesType.html">timeSeries</a> of a time variable <a class="groops-class" href="gravityfieldType.html">gravityfield</a> and saves it as degree amplitudes. The expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly \\[   \\sigma_n = \\frac{GM}{R}\\left(\\frac{R}{r}\\right)^{n+1}k_n\\sqrt{\\sum_{m=0}^n c_{nm}^2+s_{nm}^2}. \\] The <a class="groops-class" href="fileFormat_matrix.html">outputfileTimeSeries</a> is a matrix with every row containing the time, degree, degree amplitude, and the formal error.</p><p>To visualize the results use <a class="groops-program" href="PlotGraph.html">PlotGraph</a>).</p><p>See also <a class="groops-program" href="Gravityfield2DegreeAmplitudes.html">Gravityfield2DegreeAmplitudes</a>.</p><p>'},
'Gravityfield2DisplacementTimeSeries': { 'name': 'Gravityfield2DisplacementTimeSeries', 'key': 'Gravityfield2DisplacementTimeSeries', 'description': 'This program computes a time series of displacements of a list of stations (  This program computes a time series of displacements of a list of stations ( ) due to the effect of time variable loading masses. The displacement   of a station is calculated according to  where   is the normal gravity, the load Love and Shida numbers   are given by   This program computes a time series of displacements of a list of stations (  and the load Love numbers   are given by   This program computes a time series of displacements of a list of stations ( . The   are the spherical harmonics expansion of the full time variable gravitational potential (potential of the loading mass + deformation potential):  Deformations due to Earth tide and due to polar tides are computed using the IERS conventions. Eq.   is not used in these cases. The  outputfileTimeSeries  is an  instrument file , MISCVALUES. The data columns contain the deformation of each station in   in a global terrestrial reference frame or alternatively in a local elliposidal frame (north, east, up) if  localReferenceFrame  is set.', 'config_table': 'outputfileTimeSeries filename x,y,z [m] per station grid gridType station list timeSeries timeSeriesType  gravityfield gravityfieldType  tides tidesType  earthRotation earthRotationType  ephemerides ephemeridesType  inputfileDeformationLoadLoveNumber filename  inputfilePotentialLoadLoveNumber filename if full potential is given and not only loading potential removeMean boolean remove the temporal mean of each coordinate localReferenceFrame boolean local left handed reference frame (north, east, up)', 'display_text': 'This program computes a time series of displacements of a list of stations (<a class="groops-class" href="gridType.html">grid</a>) due to the effect of time variable loading masses. The displacement $\\M u$ of a station is calculated according to \\[\\label{eq:displacement} \\M u(\\M r) = \\frac{1}{\\gamma}\\sum_{n=0}^\\infty \\left[\\frac{h_n}{1+k_n}V_n(\\M r)\\,\\M e_{up} + R\\frac{l_n}{1+k_n}\\left(  \\frac{\\partial V_n(\\M r)}{\\partial \\M e_{north}}\\M e_{north} +\\frac{\\partial V_n(\\M r)}{\\partial \\M e_{east}} \\M e_{east}\\right)\\right], \\]where $\\gamma$ is the normal gravity, the load Love and Shida numbers $h_n,l_n$ are given by <a class="groops-class" href="fileFormat_matrix.html">inputfileDeformationLoadLoveNumber</a> and the load Love numbers $k_n$ are given by <a class="groops-class" href="fileFormat_matrix.html">inputfilePotentialLoadLoveNumber</a>. The $V_n$ are the spherical harmonics expansion of the full time variable gravitational potential (potential of the loading mass + deformation potential): \\[ V(\\M r) = \\sum_{n=0}^\\infty V_n(\\M r). \\]Deformations due to Earth tide and due to polar tides are computed using the IERS conventions. Eq. \\eqref{eq:displacement} is not used in these cases.</p><p>The <strong class="groops-config-element">outputfileTimeSeries</strong> is an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>, MISCVALUES. The data columns contain the deformation of each station in $x,y,z$ in a global terrestrial reference frame or alternatively in a local elliposidal frame (north, east, up) if <strong class="groops-config-element">localReferenceFrame</strong> is set.'},
'Gravityfield2EmpiricalCovariance': { 'name': 'Gravityfield2EmpiricalCovariance', 'key': 'Gravityfield2EmpiricalCovariance', 'description': 'This program estimates an spatial and temporal covariance matrix from a time series of gravity fields. Firstly for every time step   a spherical harmonics vector   from the time variable gravity field is generated. The coefficients of the spherical harmonics expansion are in the sequence given by   This program estimates an spatial and temporal covariance matrix from a time series of gravity fields. . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . In the next step the empirical covariance matrix is estimated according to  where   is given by  differenceStep . From the diagonal elements of   the isotropic accuracies are computed  and a diagonal matrix is constructed  . The result is computed:', 'config_table': 'outputfileCovarianceMatrix filename  outputfilePotentialCoefficients filename  gravityfield gravityfieldType  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme for solution vector removeMean boolean  timeSeries timeSeriesType sampling of the gravityfield differenceStep uint choose dt for: x,i(t) - x,j(t+dt) factorFullMatrixPart double  factorIsotropicPart double  intervals timeSeriesType', 'display_text': 'This program estimates an spatial and temporal covariance matrix from a time series of gravity fields.</p><p>Firstly for every time step $t_i$ a spherical harmonics vector $\\M x_i$ from the time variable gravity field is generated. The coefficients of the spherical harmonics expansion are in the sequence given by <a class="groops-class" href="sphericalHarmonicsNumberingType.html">numbering</a>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>In the next step the empirical covariance matrix is estimated according to \\[ \\M\\Sigma(\\Delta i)_{full} = \\frac{1}{N}\\sum_{i=1}^N \\M x_i \\M x_{i+\\Delta i}^T, \\]where $\\Delta i$ is given by <strong class="groops-config-element">differenceStep</strong>.</p><p>From the diagonal elements of $\\M\\Sigma(\\Delta i)$ the isotropic accuracies are computed \\[ \\sigma_n^2 = \\frac{1}{2n+1}\\sum_{m=0}^n \\sigma_{cnm}^2+\\sigma_{snm}^2, \\]and a diagonal matrix is constructed $\\Sigma_{iso} = \\text{diag}(\\sigma_2^2,\\ldots,\\sigma_N^2)$. The result is computed: \\[ \\M\\Sigma(\\Delta i) = \\alpha_{full}\\M\\Sigma(\\Delta i)_{full}+\\alpha_{iso}\\M\\Sigma(\\Delta i)_{iso}. \\]'},
'Gravityfield2Gradients': { 'name': 'Gravityfield2Gradients', 'key': 'Gravityfield2Gradients', 'description': 'This program computes gravity gradients from   This program computes gravity gradients from   on a   This program computes gravity gradients from   in a global terrestrial reference frame or alternatively in a local elliposidal frame (north, east, up) if  localReferenceFrame  is set. In   This program computes gravity gradients from   the values   will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening .', 'config_table': 'outputfileGriddedData filename Vxx Vyy Vzz Vxy Vxz Vyz grid gridType  gravityfield gravityfieldType  localReferenceFrame boolean local left handed reference frame (north, east, up) time time at this time the gravity field will be evaluated R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program computes gravity gradients from <a class="groops-class" href="gravityfieldType.html">gravityfield</a> on a <a class="groops-class" href="gridType.html">grid</a> in a global terrestrial reference frame or alternatively in a local elliposidal frame (north, east, up) if <strong class="groops-config-element">localReferenceFrame</strong> is set. In <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a> the values $[Vxx, Vyy, Vzz, Vxy, Vxz, Vyz]$ will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>.'},
'Gravityfield2GridCovarianceMatrix': { 'name': 'Gravityfield2GridCovarianceMatrix', 'key': 'Gravityfield2GridCovarianceMatrix', 'description': 'This program propagates the covariance matrix of a   This program propagates the covariance matrix of a   evaluated at  time  to a   This program propagates the covariance matrix of a  . The full variance-covariance matrix is computed and written to a  matrix file :  The   This program propagates the covariance matrix of a   determines the quantity of the grid values, for example,   This program propagates the covariance matrix of a  . See also  GravityfieldCovariancesPropagation2GriddedData ,  GravityfieldVariancesPropagation2GriddedData .', 'config_table': 'outputfileMatrix filename symmetric grid covariance matrix grid gridType  kernel kernelType  gravityfield gravityfieldType  time time at this time the gravity field will be evaluated', 'display_text': 'This program propagates the covariance matrix of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> evaluated at <strong class="groops-config-element">time</strong> to a <a class="groops-class" href="gridType.html">grid</a>. The full variance-covariance matrix is computed and written to a <a class="groops-file" href="fileFormat_matrix.html">matrix file</a>: \\[ \\mathbf{\\Sigma}_\\mathbf{y} = \\mathbf{F}\\mathbf{\\Sigma}_\\mathbf{x}\\mathbf{F}^T \\]The <a class="groops-class" href="kernelType.html">kernel</a> determines the quantity of the grid values, for example, <a class="groops-class" href="kernelType.html#waterHeight">kernel:waterHeight</a>.</p><p>See also <a class="groops-program" href="GravityfieldCovariancesPropagation2GriddedData.html">GravityfieldCovariancesPropagation2GriddedData</a>, <a class="groops-program" href="GravityfieldVariancesPropagation2GriddedData.html">GravityfieldVariancesPropagation2GriddedData</a>.'},
'Gravityfield2GriddedData': { 'name': 'Gravityfield2GriddedData', 'key': 'Gravityfield2GriddedData', 'description': 'This program computes values of a   This program computes values of a   on a given   This program computes values of a  . The type of value (e.g gravity anomalies or geoid heights) can be choosen with   This program computes values of a  . If a time is given the gravity field will be evaluated at this point of time otherwise only the static part will be used. The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening . To speed up the computation the gravity field can be converted to spherical harmonics before the computation with  convertToHarmonics . To visualize the results use  PlotMap .', 'config_table': 'outputfileGriddedData filename  grid gridType  kernel kernelType  gravityfield gravityfieldType  convertToHarmonics boolean gravityfield is converted to spherical harmonics before evaluation, may accelerate the computation time time at this time the gravity field will be evaluated R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program computes values of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> on a given <a class="groops-class" href="gridType.html">grid</a>. The type of value (e.g gravity anomalies or geoid heights) can be choosen with <a class="groops-class" href="kernelType.html">kernel</a>. If a time is given the gravity field will be evaluated at this point of time otherwise only the static part will be used. The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>. To speed up the computation the gravity field can be converted to spherical harmonics before the computation with <strong class="groops-config-element">convertToHarmonics</strong>.</p><p>To visualize the results use <a class="groops-program" href="PlotMap.html">PlotMap</a>.'},
'Gravityfield2GriddedDataTimeSeries': { 'name': 'Gravityfield2GriddedDataTimeSeries', 'key': 'Gravityfield2GriddedDataTimeSeries', 'description': 'This program computes values of a   This program computes values of a   on a given   This program computes values of a   for each time step of   This program computes values of a  . The type of value (e.g gravity anomalies or geoid heights) can be choosen with   This program computes values of a  . To speed up the computation the gravity field can be converted to spherical harmonics before the computation with  convertToHarmonics . The   This program computes values of a   is an instrument (MISCVALUES) file with a data column for each grid point per epoch. This program enables the use of all instrument programs like  InstrumentFilter ,  InstrumentArcStatistics  or  InstrumentDetrend  to analyze and manipulate time series of gridded data. See also  TimeSeries2GriddedData ,  Gravityfield2GriddedData', 'config_table': 'outputfileTimeSeries filename each epoch: data of grid points (MISCVALUES) grid gridType  kernel kernelType  gravityfield gravityfieldType  convertToHarmonics boolean gravityfield is converted to spherical harmonics before evaluation, may accelerate the computation timeSeries timeSeriesType', 'display_text': 'This program computes values of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> on a given <a class="groops-class" href="gridType.html">grid</a> for each time step of <a class="groops-class" href="timeSeriesType.html">timeSeries</a>. The type of value (e.g gravity anomalies or geoid heights) can be choosen with <a class="groops-class" href="kernelType.html">kernel</a>. To speed up the computation the gravity field can be converted to spherical harmonics before the computation with <strong class="groops-config-element">convertToHarmonics</strong>. The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> is an instrument (MISCVALUES) file with a data column for each grid point per epoch.</p><p>This program enables the use of all instrument programs like <a class="groops-program" href="InstrumentFilter.html">InstrumentFilter</a>, <a class="groops-program" href="InstrumentArcStatistics.html">InstrumentArcStatistics</a> or <a class="groops-program" href="InstrumentDetrend.html">InstrumentDetrend</a> to analyze and manipulate time series of gridded data.</p><p>See also <a class="groops-program" href="TimeSeries2GriddedData.html">TimeSeries2GriddedData</a>, <a class="groops-program" href="Gravityfield2GriddedData.html">Gravityfield2GriddedData</a>'},
'Gravityfield2PotentialCoefficients': { 'name': 'Gravityfield2PotentialCoefficients', 'key': 'Gravityfield2PotentialCoefficients', 'description': 'This program evaluates a time variable   This program evaluates a time variable   at a given  time  and saves it as a  spherical harmonics file . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM .', 'config_table': 'outputfilePotentialCoefficients filename  gravityfield gravityfieldType  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius time time at this time the gravity field will be evaluated', 'display_text': 'This program evaluates a time variable <a class="groops-class" href="gravityfieldType.html">gravityfield</a> at a given <strong class="groops-config-element">time</strong> and saves it as a <a class="groops-file" href="fileFormat_potentialCoefficients.html">spherical harmonics file</a>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.'},
'Gravityfield2PotentialCoefficientsTimeSeries': { 'name': 'Gravityfield2PotentialCoefficientsTimeSeries', 'key': 'Gravityfield2PotentialCoefficientsTimeSeries', 'description': 'This program computes a   This program computes a   of a time variable   This program computes a   and converts to coefficients of a spherical harmonics expansion. The expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . The   This program computes a   contains the potential coefficients as data columns for each epoch in the sequence given by   This program computes a  .', 'config_table': 'outputfileTimeSeries filename instrument file (MISCVALUES) gravityfield gravityfieldType  timeSeries timeSeriesType  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme', 'display_text': 'This program computes a <a class="groops-class" href="timeSeriesType.html">timeSeries</a> of a time variable <a class="groops-class" href="gravityfieldType.html">gravityfield</a> and converts to coefficients of a spherical harmonics expansion. The expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> contains the potential coefficients as data columns for each epoch in the sequence given by <a class="groops-class" href="sphericalHarmonicsNumberingType.html">numbering</a>.'},
'Gravityfield2SphericalHarmonicsVector': { 'name': 'Gravityfield2SphericalHarmonicsVector', 'key': 'Gravityfield2SphericalHarmonicsVector', 'description': 'This program evaluates a time variable   This program evaluates a time variable   at a given  time  and saves a  vector  with the coefficients of a spherical harmonics expansion in the sequence given by   This program evaluates a time variable  . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusively. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . This coefficients vector can be used as a approximate solution, see  NormalsMultiplyAdd , or as pseudo oberservations for regularization, see   This program evaluates a time variable  . For back transformation use  Gravityfield2PotentialCoefficients  with   This program evaluates a time variable  .', 'config_table': 'outputfileVector filename  gravityfield gravityfieldType  startIndex uint start index to put the coefficients in the solution vector minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme for solution vector time time at this time the gravity field will be evaluated useSigma boolean use formal errors instead of coefficients', 'display_text': 'This program evaluates a time variable <a class="groops-class" href="gravityfieldType.html">gravityfield</a> at a given <strong class="groops-config-element">time</strong> and saves a <a class="groops-file" href="fileFormat_matrix.html">vector</a> with the coefficients of a spherical harmonics expansion in the sequence given by <a class="groops-class" href="sphericalHarmonicsNumberingType.html">numbering</a>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusively. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>This coefficients vector can be used as a approximate solution, see <a class="groops-program" href="NormalsMultiplyAdd.html">NormalsMultiplyAdd</a>, or as pseudo oberservations for regularization, see <a class="groops-class" href="normalEquationType.html#regularization">normalEquation:regularization</a>.</p><p>For back transformation use <a class="groops-program" href="Gravityfield2PotentialCoefficients.html">Gravityfield2PotentialCoefficients</a> with <a class="groops-class" href="gravityfieldType.html#fromParametrization">gravityfield:fromParametrization</a>.'},
'Gravityfield2TimeSplines': { 'name': 'Gravityfield2TimeSplines', 'key': 'Gravityfield2TimeSplines', 'description': 'This program estimates splines in time domain from a time variable gravity field and writes   This program estimates splines in time domain from a time variable gravity field and writes  . The   This program estimates splines in time domain from a time variable gravity field and writes   is sampled at   This program estimates splines in time domain from a time variable gravity field and writes  , converted to potential coefficients in the range between  minDegree  and  maxDegree  inclusively. The time series of spherical harmonics can be temporal filtered with   This program estimates splines in time domain from a time variable gravity field and writes  . In the next step temporal splines with  splineDegree  and nodal points given at   This program estimates splines in time domain from a time variable gravity field and writes   are adjusted to the time series in a least squares sense. This is very fast for block means (splineDegree = 0) but for other splines a large systems of equations must be solved. In the adjustment process the time series of gravity fields can be interpreted as samples at the given times or as continuous function with linear behaviour between sampled points ( linearInterpolation ). To combine a series of potential coefficients to a spline file with block means (splineDegree = 0) use the fast  PotentialCoefficients2BlockMeanTimeSplines  instead.', 'config_table': 'outputfileTimeSplines filename  gravityfield gravityfieldType  temporalFilter digitalFilterType filter sampled gravity field in time minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius sampling timeSeriesType gravity field is sampled at these times removeMean boolean remove the temporal mean of the series before estimating the splines linearInterpolation boolean assume linear behavior between sampled points splineDegree uint degree of splines splineTimeSeries timeSeriesType nodal points of splines in time domain', 'display_text': 'This program estimates splines in time domain from a time variable gravity field and writes <a class="groops-class" href="fileFormat_timeSplinesGravityField.html">outputfileTimeSplines</a>. The <a class="groops-class" href="gravityfieldType.html">gravityfield</a> is sampled at <a class="groops-class" href="timeSeriesType.html">sampling</a>, converted to potential coefficients in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusively. The time series of spherical harmonics can be temporal filtered with <a class="groops-class" href="digitalFilterType.html">temporalFilter</a>.</p><p>In the next step temporal splines with <strong class="groops-config-element">splineDegree</strong> and nodal points given at <a class="groops-class" href="timeSeriesType.html">splineTimeSeries</a> are adjusted to the time series in a least squares sense. This is very fast for block means (splineDegree = 0) but for other splines a large systems of equations must be solved. In the adjustment process the time series of gravity fields can be interpreted as samples at the given times or as continuous function with linear behaviour between sampled points (<strong class="groops-config-element">linearInterpolation</strong>).</p><p>To combine a series of potential coefficients to a spline file with block means (splineDegree = 0) use the fast <a class="groops-program" href="PotentialCoefficients2BlockMeanTimeSplines.html">PotentialCoefficients2BlockMeanTimeSplines</a> instead.'},
'Gravityfield2TrendPotentialCoefficients': { 'name': 'Gravityfield2TrendPotentialCoefficients', 'key': 'Gravityfield2TrendPotentialCoefficients', 'description': 'This program estimates   This program estimates   (e.g. mean, trend, annual) from a time variable gravity field. In a first step a time variable   This program estimates   is sampled at   This program estimates   and converted to coefficients of a spherical harmonics expansion. The expansion is limited in the range between  minDegree  and  maxDegree  inclusively. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . These coefficients serves as observations of a  robust least squares adjustment  to estimate   This program estimates   parameters. For each temporal parameter an   This program estimates   is generated.', 'config_table': 'outputfilePotentialCoefficients filename for each temporal parameter gravityfield gravityfieldType  timeSeries timeSeriesType  parametrizationTemporal parametrizationTemporalType  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius huber double for robust least squares huberPower double for robust least squares huberMaxIteration uint (maximum) number of iterations for robust estimation', 'display_text': 'This program estimates <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a> (e.g. mean, trend, annual) from a time variable gravity field.</p><p>In a first step a time variable <a class="groops-class" href="gravityfieldType.html">gravityfield</a> is sampled at <a class="groops-class" href="timeSeriesType.html">timeSeries</a> and converted to coefficients of a spherical harmonics expansion. The expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusively. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>These coefficients serves as observations of a <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a> to estimate <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a> parameters. For each temporal parameter an <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a> is generated.'},
'GravityfieldCovariancesPropagation2GriddedData': { 'name': 'GravityfieldCovariancesPropagation2GriddedData', 'key': 'GravityfieldCovariancesPropagation2GriddedData', 'description': 'This program computes the covariance between a source point given by longitude/latitude ( L ,  B ) and the points of a   This program computes the covariance between a source point given by longitude/latitude (  in terms of the functional given by   This program computes the covariance between a source point given by longitude/latitude (  from the variance-covariance matrix of a   This program computes the covariance between a source point given by longitude/latitude (  evaluated at  time . If  computeCorrelation  is set, the program returns the correlation according to  in the range of [-1, 1] instead of the covariance. See also  Gravityfield2GridCovarianceMatrix ,  GravityfieldVariancesPropagation2GriddedData .', 'config_table': 'outputfileGriddedData filename gridded data file containing the covariance betwenn source point and grid points grid gridType  kernel kernelType functional gravityfield gravityfieldType  time time at this time the gravity field will be evaluated L angle longitude of variance point B angle latitude of variance point height double ellipsoidal height of source point computeCorrelation boolean compute correlations instead of covariances R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program computes the covariance between a source point given by longitude/latitude (<strong class="groops-config-element">L</strong>, <strong class="groops-config-element">B</strong>) and the points of a <a class="groops-class" href="gridType.html">grid</a> in terms of the functional given by <a class="groops-class" href="kernelType.html">kernel</a> from the variance-covariance matrix of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> evaluated at <strong class="groops-config-element">time</strong>.</p><p>If <strong class="groops-config-element">computeCorrelation</strong> is set, the program returns the correlation according to \\[ r_{ij} = \\frac{\\sigma_{ij}}{\\sigma_i \\sigma_j} \\]in the range of [-1, 1] instead of the covariance.</p><p>See also <a class="groops-program" href="Gravityfield2GridCovarianceMatrix.html">Gravityfield2GridCovarianceMatrix</a>, <a class="groops-program" href="GravityfieldVariancesPropagation2GriddedData.html">GravityfieldVariancesPropagation2GriddedData</a>.'},
'GravityfieldReplacePotentialCoefficients': { 'name': 'GravityfieldReplacePotentialCoefficients', 'key': 'GravityfieldReplacePotentialCoefficients', 'description': 'Replaces single potential coefficients in a gravity field. Both   Replaces single potential coefficients in a gravity field. Both   and   Replaces single potential coefficients in a gravity field. Both   are evaluated at  time  and converted to spherical harmonic coefficients. Single  coefficients  are then replaced in   Replaces single potential coefficients in a gravity field. Both   by the values from   Replaces single potential coefficients in a gravity field. Both   and the result is written to   Replaces single potential coefficients in a gravity field. Both   from  minDegree  to  maxDegree ,', 'config_table': 'outputfilePotentialCoefficients filename  gravityfield gravityfieldType single coefficients are replaced by the other gravityfield gravityfieldReplacement gravityfieldType contains the coefficients for replacement coefficients choice  cnm sequence  degree uint  order uint  snm sequence  degree uint  order uint  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius time time at this time the gravity field will be evaluated', 'display_text': 'Replaces single potential coefficients in a gravity field. Both <a class="groops-class" href="gravityfieldType.html">gravityfield</a> and <a class="groops-class" href="gravityfieldType.html">gravityfieldReplacement</a> are evaluated at <strong class="groops-config-element">time</strong> and converted to spherical harmonic coefficients. Single <strong class="groops-config-element">coefficients</strong> are then replaced in <a class="groops-class" href="gravityfieldType.html">gravityfield</a> by the values from <a class="groops-class" href="gravityfieldType.html">gravityfieldReplacement</a> and the result is written to <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a> from <strong class="groops-config-element">minDegree</strong> to <strong class="groops-config-element">maxDegree</strong>,'},
'GravityfieldVariancesPropagation2GriddedData': { 'name': 'GravityfieldVariancesPropagation2GriddedData', 'key': 'GravityfieldVariancesPropagation2GriddedData', 'description': 'This program propagates variance-covariance matrix of a   This program propagates variance-covariance matrix of a   evaluated at  time  to the points of a   This program propagates variance-covariance matrix of a   in terms of the functional given by   This program propagates variance-covariance matrix of a  . The resulting  outputfileGriddedData  contains the standard deviations of the grid points. See also  Gravityfield2GridCovarianceMatrix ,  GravityfieldCovariancesPropagation2GriddedData .', 'config_table': 'outputfileGriddedData filename standard deviation at each grid point grid gridType  kernel kernelType functional gravityfield gravityfieldType  time time at this time the gravity field will be evaluated R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program propagates variance-covariance matrix of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> evaluated at <strong class="groops-config-element">time</strong> to the points of a <a class="groops-class" href="gridType.html">grid</a> in terms of the functional given by <a class="groops-class" href="kernelType.html">kernel</a>. The resulting <a class="groops-file" href="fileFormat_griddedData.html">outputfileGriddedData</a> contains the standard deviations of the grid points.</p><p>See also <a class="groops-program" href="Gravityfield2GridCovarianceMatrix.html">Gravityfield2GridCovarianceMatrix</a>, <a class="groops-program" href="GravityfieldCovariancesPropagation2GriddedData.html">GravityfieldCovariancesPropagation2GriddedData</a>.'},
'GriddedData2AreaMeanTimeSeries': { 'name': 'GriddedData2AreaMeanTimeSeries', 'key': 'GriddedData2AreaMeanTimeSeries', 'description': 'This program computes a time series of area mean values in a basin represented by   This program computes a time series of area mean values in a basin represented by   from a sequence of grid files. If a file is not found, the epoch is skipped. Per default the weighted average of all points in the given border is computed where the points are weighted by their area element. If  computeMean  is set, the time average of each grid points is subtracted before the computation. If  multiplyWithArea  is set, the weighted average is multiplied with the total basin area. This is useful for computing the total mass in the basin. The   This program computes a time series of area mean values in a basin represented by   is an instrument file, where the first columns are the mean value each data column in the grid files, followed by the the weighted RMS for each data column in the grid files if  computeRms  is set. If the number of data columns differs between the grid files, the remaining columns are padded with zeros. See also  Gravityfield2AreaMeanTimeSeries .', 'config_table': 'outputfileTimeSeries filename  inputfileGriddedData filename  border borderType  timeSeries timeSeriesType  multiplyWithArea boolean multiply time series with total area (useful for mass estimates) removeMean boolean remove the temporal mean of the series computeRms boolean additional rms each time step', 'display_text': 'This program computes a time series of area mean values in a basin represented by <a class="groops-class" href="borderType.html">border</a> from a sequence of grid files. If a file is not found, the epoch is skipped. Per default the weighted average of all points in the given border is computed where the points are weighted by their area element.</p><p>If <strong class="groops-config-element">computeMean</strong> is set, the time average of each grid points is subtracted before the computation. If <strong class="groops-config-element">multiplyWithArea</strong> is set, the weighted average is multiplied with the total basin area. This is useful for computing the total mass in the basin.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> is an instrument file, where the first columns are the mean value each data column in the grid files, followed by the the weighted RMS for each data column in the grid files if <strong class="groops-config-element">computeRms</strong> is set. If the number of data columns differs between the grid files, the remaining columns are padded with zeros.</p><p>See also <a class="groops-program" href="Gravityfield2AreaMeanTimeSeries.html">Gravityfield2AreaMeanTimeSeries</a>.'},
'GriddedData2GriddedDataStatistics': { 'name': 'GriddedData2GriddedDataStatistics', 'key': 'GriddedData2GriddedDataStatistics', 'description': 'This program assigns values   This program assigns values   to the nearest points of a new   This program assigns values  . If some of the new points are not filled in with data  emptyValue  is used instead. If multiple points of the input fall on the same node the result can be selected with  statistics  (e.g. mean, root mean square, min, max,  ). It also is possible to simply count the number of data points that were assigned to each point. Be aware in case borders are given within   This program assigns values  , the   This program assigns values   will have points excluded before the assignement of old points to the new points. The data from   This program assigns values   will not be limited by the given borders! See  GriddedDataConcatenate  to limit the   This program assigns values   to given borders.', 'config_table': 'outputfileGriddedData filename  inputfileGriddedData filename  grid gridType  statistic choice statistic used if multiple values fall on the same cell mean  mean wmean  area weighted mean rms  root mean square wrms  area weighted root mean square std  standard deviation wstd  area weighted standard deviation sum  sum min  minimum value max  maximum value count  number of values first  first value last  last value emptyValue double value for nodes without data R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'This program assigns values <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> to the nearest points of a new <a class="groops-class" href="gridType.html">grid</a>. If some of the new points are not filled in with data <strong class="groops-config-element">emptyValue</strong> is used instead. If multiple points of the input fall on the same node the result can be selected with <strong class="groops-config-element">statistics</strong> (e.g. mean, root mean square, min, max, ). It also is possible to simply count the number of data points that were assigned to each point.</p><p>Be aware in case borders are given within <a class="groops-class" href="gridType.html">grid</a>, the <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a> will have points excluded before the assignement of old points to the new points. The data from <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> will not be limited by the given borders! See <a class="groops-ref" href="GriddedDataConcatenate.html">GriddedDataConcatenate</a> to limit the <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> to given borders.</p><p>'},
'GriddedData2GriddedDataTimeSeries': { 'name': 'GriddedData2GriddedDataTimeSeries', 'key': 'GriddedData2GriddedDataTimeSeries', 'description': 'Write a series of   Write a series of   with the corresponding   Write a series of   as a single  gridded data time series file . The  splineDegree  defines the possible temporal interpolation of data in the output file. For a file with spline degree 0 (temporal block means) the time intervals in which the grids are valid are defined between adjacent points in time. Therefore one more point in time is needed than the number of input grid files for degree 0. See also  GriddedDataTimeSeries2GriddedData .', 'config_table': 'outputfileGriddedDataTimeSeries filename  inputfileGriddedData filename file count must agree with number of times+splineDegre-1 timeSeries timeSeriesType  splineDegree uint degree of splines', 'display_text': 'Write a series of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> with the corresponding <a class="groops-class" href="timeSeriesType.html">timeSeries</a> as a single <a class="groops-file" href="fileFormat_griddedDataTimeSeries.html">gridded data time series file</a>. The <strong class="groops-config-element">splineDegree</strong> defines the possible temporal interpolation of data in the output file. For a file with spline degree 0 (temporal block means) the time intervals in which the grids are valid are defined between adjacent points in time. Therefore one more point in time is needed than the number of input grid files for degree 0.</p><p>See also <a class="groops-program" href="GriddedDataTimeSeries2GriddedData.html">GriddedDataTimeSeries2GriddedData</a>.'},
'GriddedData2Matrix': { 'name': 'GriddedData2Matrix', 'key': 'GriddedData2Matrix', 'description': 'This program converts   This program converts   to   This program converts   with data columns. The grid is expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening . The content of the output matrix can be controlled by  outColumn  expressions applied to every grid point. The common data variables for grids are available, see  dataVariables .', 'config_table': 'outputfileMatrix filename point list as matrix with longitude and latitude values in columns and possible additional columns inputfileGriddedData filename  R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates outColumn expression expression (variables: longitude, latitude, height, area, data0, data1, ...)', 'display_text': 'This program converts <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> to <a class="groops-class" href="fileFormat_matrix.html">outputfileMatrix</a> with data columns. The grid is expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>. The content of the output matrix can be controlled by <strong class="groops-config-element">outColumn</strong> expressions applied to every grid point. The common data variables for grids are available, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.'},
'GriddedData2PotentialCoefficients': { 'name': 'GriddedData2PotentialCoefficients', 'key': 'GriddedData2PotentialCoefficients', 'description': 'This program estimate potential coefficients from   This program estimate potential coefficients from   gravity field functionals. It used a simple quadrature formular  or a  leastSquares  adjustment with block diagonal normal matrix (order by order). For the latter one the data must be regular distributed. The  value s   and the  weight s   are expressions using the common data variables for grids, see  dataVariables . Multiple   This program estimate potential coefficients from   can be estimated in one step. For each an indivdual  value  must be specified. The type of the gridded data (e.g gravity anomalies or geoid heights) must be set with   This program estimate potential coefficients from    . The expansion is limited in the range between  minDegree  and  maxDegree  inclusively. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . For irregular distributed data and using the full variance covariance matrix use  NormalsSolverVCE  together with   This program estimate potential coefficients from   and   This program estimate potential coefficients from  . See also  GriddedDataTimeSeries2PotentialCoefficients .', 'config_table': 'outputfilePotentialCoefficients filename one file for each value expression inputfileGriddedData filename  value expression expression to compute values (input columns are named data0, data1, ...) weight expression expression to compute values (input columns are named data0, data1, ...) kernel kernelType data type of input values minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius leastSquares boolean false: quadrature formular, true: least squares adjustment order by order', 'display_text': 'This program estimate potential coefficients from <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> gravity field functionals. It used a simple quadrature formular \\[   c_{nm} = \\frac{1}{4\\pi}\\frac{R}{GM} \\sum_i f_i \\left(\\frac{r_i}{R}\\right)^{n+1} k_n C_{nm}(\\lambda_i,\\vartheta_i)\\,\\Delta\\Phi_i \\]or a <strong class="groops-config-element">leastSquares</strong> adjustment with block diagonal normal matrix (order by order). For the latter one the data must be regular distributed.</p><p>The <strong class="groops-config-element">value</strong>s $f_i$ and the <strong class="groops-config-element">weight</strong>s $\\Delta\\Phi_i$ are expressions using the common data variables for grids, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>. Multiple <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a> can be estimated in one step. For each an indivdual <strong class="groops-config-element">value</strong> must be specified. The type of the gridded data (e.g gravity anomalies or geoid heights) must be set with <a class="groops-class" href="kernelType.html">kernel</a> $k_n$.</p><p>The expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusively. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>For irregular distributed data and using the full variance covariance matrix use <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a> together with <a class="groops-class" href="observationType.html#terrestrial">oberservation:terrestrial</a> and <a class="groops-class" href="parametrizationGravityType.html#sphericalHarmonics">parametrizationGravity:sphericalHarmonics</a>.</p><p>See also <a class="groops-program" href="GriddedDataTimeSeries2PotentialCoefficients.html">GriddedDataTimeSeries2PotentialCoefficients</a>.'},
'GriddedData2SphericalDistance': { 'name': 'GriddedData2SphericalDistance', 'key': 'GriddedData2SphericalDistance', 'description': 'Compute the spherical distance on the unit sphere in radians between all point pairs of two grids. The spherical distance is computed by  where   is the (normalized) position. This implies that all points are projected onto the unit sphere.', 'config_table': 'outputfileMatrix filename matrix containing the spherical distance between all point pairs [rad] grid1 gridType  grid2 gridType', 'display_text': 'Compute the spherical distance on the unit sphere in radians between all point pairs of two grids. The spherical distance is computed by \\[   \\psi_{12} = \\arccos(\\M n_1 \\cdot \\M n_2), \\]where $\\M n_i$ is the (normalized) position. This implies that all points are projected onto the unit sphere.'},
'GriddedData2TimeSeries': { 'name': 'GriddedData2TimeSeries', 'key': 'GriddedData2TimeSeries', 'description': 'Write a series of   Write a series of   with the corresponding   Write a series of   as a single time series file ( instrument , MISCVALUES). If  groupDataByPoints  is true the  outputfileTimeSeries  starts for each epoch with all data ( data0 ,  data1 ) for the first point, followed by all data of the second point and so on. If  groupDataByPoints  is false, the file starts with  data0  for all points, followed by all  data1  and so on. This enables the use of all instrument programs like  InstrumentFilter  or  InstrumentDetrend  to analyze and manipulate time series of gridded data. See also  TimeSeries2GriddedData .', 'config_table': 'outputfileTimeSeries filename each epoch: multiple data for points (MISCVALUES) inputfileGriddedData filename file count must agree with number of times timeSeries timeSeriesType  groupDataByPoints boolean multiple data are given point by point, otherwise: data0 for all points, followed by all data1', 'display_text': 'Write a series of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> with the corresponding <a class="groops-class" href="timeSeriesType.html">timeSeries</a> as a single time series file (<a class="groops-file" href="fileFormat_instrument.html">instrument</a>, MISCVALUES).</p><p>If <strong class="groops-config-element">groupDataByPoints</strong> is true the <strong class="groops-config-element">outputfileTimeSeries</strong> starts for each epoch with all data (<code>data0</code>, <code>data1</code>) for the first point, followed by all data of the second point and so on. If <strong class="groops-config-element">groupDataByPoints</strong> is false, the file starts with <code>data0</code> for all points, followed by all <code>data1</code> and so on.</p><p>This enables the use of all instrument programs like <a class="groops-program" href="InstrumentFilter.html">InstrumentFilter</a> or <a class="groops-program" href="InstrumentDetrend.html">InstrumentDetrend</a> to analyze and manipulate time series of gridded data.</p><p>See also <a class="groops-program" href="TimeSeries2GriddedData.html">TimeSeries2GriddedData</a>.'},
'GriddedDataCalculate': { 'name': 'GriddedDataCalculate', 'key': 'GriddedDataCalculate', 'description': 'This program manipulates  grid files  with data in columns similar to  FunctionsCalculate , see there for more details. If several  inputfile s are given the data columns are copied side by side. All  inputfile s must contain the same grid points. The columns are enumerated by  data0 ,  data1 ,  . The content of   This program manipulates   is controlled by  outColumn . The algorithm to compute the output is as follows: The expressions in  outColumn  are evaluated once for each grid point of the input. The variables  data0 ,  data1 ,  are replaced by the according values from the input columns before. Additional variables are available, e.g.  index ,  data0rms , see  dataVariables . For a simplified handling  constant s can be defined by  name=value . It is also possible to estimate  parameter s in a least squares adjustment. The  leastSquares  serves as template for observation equations for every point. The expression  leastSquares  is evaluated for each grid point. The variables  data0 ,  data1 ,  are replaced by the according values from the input columns before. In the next step the parameters are estimated in order to minimize the expressions in  leastSquares  in the sense of least squares. Afterwards grid points are removed if one of the  removalCriteria  expressions for this grid point evaluates true (not zero). An extra   This program manipulates   can be generated with one row of data. For the computation of the  outColumn  values all  dataVariables  are available (e.g.  data3mean ,  data4std ) inclusively the  constant s and estimated  parameter s but without the  data0 ,  data1 ,  itself. The variables and the numbering of the columns refers to the   This program manipulates  . See also  FunctionsCalculate ,  InstrumentArcCalculate ,  MatrixCalculate .', 'config_table': 'outputfileGriddedData filename  inputfileGriddedData filename  constant expression define a constant by name=value parameter expression define a parameter by name[=value] leastSquares expression try to minimize the expression by adjustment of the parameters removalCriteria expression points are removed if one criterion evaluates true. data0 is the first data field. longitude expression expression latitude expression expression height expression expression area expression expression: e.g. deltaL * 2.0 * sin(deltaB/2.0) * cos(latitude/rho) value expression expression to compute values (input columns are named data0, data1, ...) computeArea boolean automatically area computation of rectangular grids (overwrite area) R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates statistics sequence  outputfile filename matrix with one row, columns are user defined outColumn expression expression to compute statistics columns, data* are the outputColumns', 'display_text': 'This program manipulates <a class="groops-file" href="fileFormat_griddedData.html">grid files</a> with data in columns similar to <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a>, see there for more details. If several <strong class="groops-config-element">inputfile</strong>s are given the data columns are copied side by side. All <strong class="groops-config-element">inputfile</strong>s must contain the same grid points. The columns are enumerated by <code>data0</code>, <code>data1</code>, .</p><p>The content of <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a> is controlled by <strong class="groops-config-element">outColumn</strong>. The algorithm to compute the output is as follows: The expressions in <strong class="groops-config-element">outColumn</strong> are evaluated once for each grid point of the input. The variables <code>data0</code>, <code>data1</code>, are replaced by the according values from the input columns before. Additional variables are available, e.g. <code>index</code>, <code>data0rms</code>, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.</p><p>For a simplified handling <strong class="groops-config-element">constant</strong>s can be defined by <code>name=value</code>. It is also possible to estimate <strong class="groops-config-element">parameter</strong>s in a least squares adjustment. The <strong class="groops-config-element">leastSquares</strong> serves as template for observation equations for every point. The expression <strong class="groops-config-element">leastSquares</strong> is evaluated for each grid point. The variables <code>data0</code>, <code>data1</code>, are replaced by the according values from the input columns before. In the next step the parameters are estimated in order to minimize the expressions in <strong class="groops-config-element">leastSquares</strong> in the sense of least squares.</p><p>Afterwards grid points are removed if one of the <strong class="groops-config-element">removalCriteria</strong> expressions for this grid point evaluates true (not zero).</p><p>An extra <a class="groops-class" href="fileFormat_matrix.html">statistics:outputfile</a> can be generated with one row of data. For the computation of the <strong class="groops-config-element">outColumn</strong> values all <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available (e.g. <code>data3mean</code>, <code>data4std</code>) inclusively the <strong class="groops-config-element">constant</strong>s and estimated <strong class="groops-config-element">parameter</strong>s but without the <code>data0</code>, <code>data1</code>, itself. The variables and the numbering of the columns refers to the <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a>.</p><p>See also <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a>, <a class="groops-program" href="InstrumentArcCalculate.html">InstrumentArcCalculate</a>, <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a>.'},
'GriddedDataConcatenate': { 'name': 'GriddedDataConcatenate', 'key': 'GriddedDataConcatenate', 'description': 'This program concatenate grid from several   This program concatenate grid from several   and write it to a new   This program concatenate grid from several  . Input files must have the same number of data columns. If  sort  is enabled, the points are sorted by latitudes starting from north/west to south east. Identical points (within a  margin ) can be removed with  removeDuplicates .', 'config_table': 'outputfileGriddedData filename  inputfileGriddedData filename  border borderType  sortPoints boolean sort from north/west to south east removeDuplicates choice remove duplicate points keepFirst sequence keep first point, remove all other identicals margin double margin distance for identical points [m] keepLast sequence keep last point, remove all other identicals margin double margin distance for identical points [m] R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'This program concatenate grid from several <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> and write it to a new <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a>. Input files must have the same number of data columns. If <strong class="groops-config-element">sort</strong> is enabled, the points are sorted by latitudes starting from north/west to south east. Identical points (within a <strong class="groops-config-element">margin</strong>) can be removed with <strong class="groops-config-element">removeDuplicates</strong>.'},
'GriddedDataCreate': { 'name': 'GriddedDataCreate', 'key': 'GriddedDataCreate', 'description': 'This program creates a   This program creates a   and writes it to   This program creates a  . The grid is expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening . Extra  value  columns can be appended using expressions with the common  data variables  for gridded data.', 'config_table': 'outputfileGrid filename  grid gridType  R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates value expression expression (variables as \'longitude\', \'height\', \'area\' are taken from the gridded data)', 'display_text': 'This program creates a <a class="groops-class" href="gridType.html">grid</a> and writes it to <a class="groops-class" href="fileFormat_griddedData.html">outputfileGrid</a>. The grid is expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>. Extra <strong class="groops-config-element">value</strong> columns can be appended using expressions with the common <a class="groops-ref" href="general.parser.html#dataVariables">data variables</a> for gridded data.'},
'GriddedDataInterpolate': { 'name': 'GriddedDataInterpolate', 'key': 'GriddedDataInterpolate', 'description': 'Interpolate values of a regular rectangular   Interpolate values of a regular rectangular   to new points given by   Interpolate values of a regular rectangular   and write as   Interpolate values of a regular rectangular  . Only longitude and latitude of points are considered; the height is ignored for interpolation. (Only nearest neighbor method is implemented at the moment.)', 'config_table': 'outputfileGriddedData filename  inputfileGriddedData filename must be rectangular grid gridType  method choice  nearestNeighbor', 'display_text': 'Interpolate values of a regular rectangular <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> to new points given by <a class="groops-class" href="gridType.html">grid</a> and write as <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a>. Only longitude and latitude of points are considered; the height is ignored for interpolation.</p><p>(Only nearest neighbor method is implemented at the moment.)</p><p>'},
'GriddedDataReduceSampling': { 'name': 'GriddedDataReduceSampling', 'key': 'GriddedDataReduceSampling', 'description': 'Generate coarse grid by computing area weighted mean values. The number of points is decimated by averaging integer multiplies of grid points ( multiplierLongitude ,  multiplierLatitude ). if  volumeConserving  is set, data are interpreted as heights above ellipsoid and the tesseroid volume  is conserved, where   is the radius of the ellipsoid at grid center and   are the grid cell boundaries. This is meaninful for Digital Elevation Models (DEM). The fine grid can be written, where the first coarse grid values (data0) are additionally appended.', 'config_table': 'outputfileCoarseGridRectangular filename coarse grid outputfileFineGridRectangular filename fine grid with additional coarse grid values inputfileFineGridRectangular filename Digital Terrain Model multiplierLongitude uint Generalizing factor multiplierLatitude uint Generalizing factor volumeConserving boolean data are interpreted as heights above ellipsoid', 'display_text': 'Generate coarse grid by computing area weighted mean values. The number of points is decimated by averaging integer multiplies of grid points (<strong class="groops-config-element">multiplierLongitude</strong>, <strong class="groops-config-element">multiplierLatitude</strong>).</p><p>if <strong class="groops-config-element">volumeConserving</strong> is set, data are interpreted as heights above ellipsoid and the tesseroid volume \\[   V=\\int_r^{r+H}\\int_{\\varphi_1}^{\\varphi_2}\\int_{\\lambda_1}^{\\lambda_2} r^2\\cos\\varphi\\,d\\varphi\\,d\\lambda\\,dr \\]is conserved, where $r$ is the radius of the ellipsoid at grid center and $(\\varphi_1-\\varphi_2)\\times(\\lambda_1-\\lambda_2)$ are the grid cell boundaries. This is meaninful for Digital Elevation Models (DEM).</p><p>The fine grid can be written, where the first coarse grid values (data0) are additionally appended.'},
'GriddedDataTimeSeries2GriddedData': { 'name': 'GriddedDataTimeSeries2GriddedData', 'key': 'GriddedDataTimeSeries2GriddedData', 'description': 'Read a   Read a   and write for each epoch a  gridded data file  where the  variableLoopTime  and  variableLoopIndex  are expanded for each point of the given   Read a   to create the file name for this epoch (see  text parser ). If   Read a   is not set the temporal nodal points from the inputfile are used. See also  GriddedData2GriddedDataTimeSeries .', 'config_table': 'outputfilesGriddedData filename for each epoch variableLoopTime string variable with time of each epoch variableLoopIndex string variable with index of current epoch (starts with zero) variableLoopCount string variable with total number of epochs inputfileGriddedDataTimeSeries filename  timeSeries timeSeriesType otherwise times from inputfile are used', 'display_text': 'Read a <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">inputfileGriddedDataTimeSeries</a> and write for each epoch a <a class="groops-file" href="fileFormat_griddedData.html">gridded data file</a> where the <strong class="groops-config-element">variableLoopTime</strong> and <strong class="groops-config-element">variableLoopIndex</strong> are expanded for each point of the given <a class="groops-class" href="timeSeriesType.html">timeSeries</a> to create the file name for this epoch (see <a class="groops-ref" href="general.parser.html#text">text parser</a>).</p><p>If <a class="groops-class" href="timeSeriesType.html">timeSeries</a> is not set the temporal nodal points from the inputfile are used.</p><p>See also <a class="groops-program" href="GriddedData2GriddedDataTimeSeries.html">GriddedData2GriddedDataTimeSeries</a>.'},
'GriddedDataTimeSeries2PotentialCoefficients': { 'name': 'GriddedDataTimeSeries2PotentialCoefficients', 'key': 'GriddedDataTimeSeries2PotentialCoefficients', 'description': 'This program estimate potential coefficients from   This program estimate potential coefficients from   in the same way as  GriddedData2PotentialCoefficients  but not only for one grid but for each epoch of   This program estimate potential coefficients from   of if not set for the temporal nodal points from the inputfile. The   This program estimate potential coefficients from   (one for each  value ) are written for each epoch with the expansion of  variableLoopTime  and  variableLoopIndex  (see  text parser ). See also  GriddedData2PotentialCoefficients .', 'config_table': 'outputfilesPotentialCoefficients filename for each epoch variableLoopTime string variable with time of each epoch variableLoopIndex string variable with index of current epoch (starts with zero) variableLoopCount string variable with total number of epochs inputfileGriddedDataTimeSeries filename  timeSeries timeSeriesType otherwise times from inputfile are used value expression expression (variables: longitude, latitude, height, area, data0, data1, ...) weight expression expression to compute values (input columns are named data0, data1, ...) kernel kernelType kernel in which the grid values are given minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius for potential coefficients leastSquares boolean false: quadrature formular, true: least squares adjustment order by order', 'display_text': 'This program estimate potential coefficients from <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">inputfileGriddedDataTimeSeries</a> in the same way as <a class="groops-program" href="GriddedData2PotentialCoefficients.html">GriddedData2PotentialCoefficients</a> but not only for one grid but for each epoch of <a class="groops-class" href="timeSeriesType.html">timeSeries</a> of if not set for the temporal nodal points from the inputfile. The <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a> (one for each <strong class="groops-config-element">value</strong>) are written for each epoch with the expansion of <strong class="groops-config-element">variableLoopTime</strong> and <strong class="groops-config-element">variableLoopIndex</strong> (see <a class="groops-ref" href="general.parser.html#text">text parser</a>).</p><p>See also <a class="groops-program" href="GriddedData2PotentialCoefficients.html">GriddedData2PotentialCoefficients</a>.'},
'GriddedTopography2AtmospherePotentialCoefficients': { 'name': 'GriddedTopography2AtmospherePotentialCoefficients', 'key': 'GriddedTopography2AtmospherePotentialCoefficients', 'description': 'Estimate interior and exterior potential coefficients for atmosphere above digital terrain models. Coefficients for interior   and exterior ( ) are computed. The density of the atmosphere is assumed to be (Sjberg, 1998)  where   is the radial distance of the ellipsoid at each point,   the radial height above the ellipsoid,   is  densitySeaLevel  and  nu    is a constant factor. The density is integrated from  radialLowerBound  and  upperAtmosphericBoundary  above the ellipsoid. The  radialLowerBound  is typically the topography and can be computed as expression at every point from   Estimate interior and exterior potential coefficients for atmosphere above digital terrain models. Coefficients for interior  .', 'config_table': 'outputfilePotentialCoefficientsExterior filename  outputfilePotentialCoefficientsInterior filename  inputfileGriddedData filename Digital Terrain Model densitySeaLevel double [kg/m**3] ny double Constant for Atmosphere radialLowerBound expression expression (variables \'L\', \'B\', \'height\', \'data\', and \'area\' are taken from the gridded data upperAtmosphericBoundary double constant upper bound [m] factor double the result is multiplied by this factor, set -1 to subtract the field minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius', 'display_text': 'Estimate interior and exterior potential coefficients for atmosphere above digital terrain models. Coefficients for interior $(1/r)^{n+1}$ and exterior ($r^n$) are computed. The density of the atmosphere is assumed to be (Sjberg, 1998) \\[ \\rho_0\\left(\\frac{R}{R+h}\\right)^\\nu, \\]where $R$ is the radial distance of the ellipsoid at each point, $h$ the radial height above the ellipsoid, $\\rho_0$ is <strong class="groops-config-element">densitySeaLevel</strong> and <strong class="groops-config-element">nu</strong> $\\nu$ is a constant factor. The density is integrated from <strong class="groops-config-element">radialLowerBound</strong> and <strong class="groops-config-element">upperAtmosphericBoundary</strong> above the ellipsoid. The <strong class="groops-config-element">radialLowerBound</strong> is typically the topography and can be computed as expression at every point from <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>.'},
'GriddedTopography2PotentialCoefficients': { 'name': 'GriddedTopography2PotentialCoefficients', 'key': 'GriddedTopography2PotentialCoefficients', 'description': 'Estimate potential coefficients from digital terrain models. Coefficients for interior   and exterior ( ) are computed.', 'config_table': 'outputfilePotentialCoefficients filename  outputfilePotentialCoefficientsInterior filename  inputfileGriddedData filename Digital Terrain Model density expression expression [kg/m^3] radialUpperBound expression expression (variables \'L\', \'B\', \'height\', \'data\', and \'area\' are taken from the gridded data radialLowerBound expression expression (variables \'L\', \'B\', \'height\', \'data\', and \'area\' are taken from the gridded data factor double the result is multiplied by this factor minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius', 'display_text': 'Estimate potential coefficients from digital terrain models. Coefficients for interior $(1/r)^{n+1}$ and exterior ($r^n$) are computed.'},
'GriddedTopographyEllipsoidal2Radial': { 'name': 'GriddedTopographyEllipsoidal2Radial', 'key': 'GriddedTopographyEllipsoidal2Radial', 'description': 'Interpolate digital terrain models from ellipoidal heights to radial heights.', 'config_table': 'outputfileGriddedData filename  inputfileGriddedData filename Digital Terrain Model', 'display_text': 'Interpolate digital terrain models from ellipoidal heights to radial heights.'},
'Matrix2GriddedData': { 'name': 'Matrix2GriddedData', 'key': 'Matrix2GriddedData', 'description': 'This program reads a  matrix file  with data in columns and convert into  gridded data . The input columns are enumerated by  data0 ,  data1 ,  , see  dataVariables .', 'config_table': 'outputfileGriddedData filename  inputfileMatrix filename  points choice  ellipsoidal sequence  longitude expression expression latitude expression expression height expression expression cartesian sequence  x expression expression y expression expression z expression expression area expression expression (e.g. deltaL*2*sin(deltaB/2)*cos(data1/RHO)) value expression expression sortPoints boolean sort from north/west to south east computeArea boolean the area can be computed automatically for rectangular grids R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'This program reads a <a class="groops-file" href="fileFormat_matrix.html">matrix file</a> with data in columns and convert into <a class="groops-file" href="fileFormat_griddedData.html">gridded data</a>. The input columns are enumerated by <code>data0</code>, <code>data1</code>, , see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.'},
'MatrixRectangular2GriddedData': { 'name': 'MatrixRectangular2GriddedData', 'key': 'MatrixRectangular2GriddedData', 'description': 'Read gridded data (matrix).', 'config_table': 'outputfileGriddedData filename  inputfileMatrix filename  rowMajor boolean true: data is ordered row by row, false: columnwise startLongitude angle longitude of upper left corner of the grid startLatitude angle latitude of upper left corner of the grid deltaLongitude angle sampling, negative for east to west data deltaLatitude angle sampling, negative for south to north data R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'Read gridded data (matrix).'},
'TimeSeries2GriddedData': { 'name': 'TimeSeries2GriddedData', 'key': 'TimeSeries2GriddedData', 'description': 'Interpret the data columns of   Interpret the data columns of   as data points of a corresponding   Interpret the data columns of  . For each epoch a  gridded data file  is written where the  variableLoopTime  and  variableLoopIndex  are expanded for each point of the given time series to create the file name for this epoch (see  text parser ). The number of input data columns must be a multiple of the number   of grid points. If  isGroupedDataByPoint  is true the   Interpret the data columns of   starts with all data ( data0 ,  data1 ) for the first point, followed by all data of the second point and so on. If  isGroupedDataByPoint  is false, the file starts with  data0  for all points, followed by all  data1  and so on. See also  GriddedData2TimeSeries .', 'config_table': 'outputfilesGriddedData filename for each epoch variableLoopTime string variable with time of each epoch variableLoopIndex string variable with index of current epoch (starts with zero) variableLoopCount string variable with total number of epochs inputfileTimeSeries filename each epoch: multiple data for points (MISCVALUES) grid gridType corresponding grid points isDataGroupedByPoint boolean multiple data are given point by point, otherwise: first data0 for all points, followed by all data1 R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'Interpret the data columns of <a class="groops-class" href="fileFormat_instrument.html">inputfileTimeSeries</a> as data points of a corresponding <a class="groops-class" href="gridType.html">grid</a>.</p><p>For each epoch a <a class="groops-file" href="fileFormat_griddedData.html">gridded data file</a> is written where the <strong class="groops-config-element">variableLoopTime</strong> and <strong class="groops-config-element">variableLoopIndex</strong> are expanded for each point of the given time series to create the file name for this epoch (see <a class="groops-ref" href="general.parser.html#text">text parser</a>).</p><p>The number of input data columns must be a multiple of the number $n$ of grid points. If <strong class="groops-config-element">isGroupedDataByPoint</strong> is true the <a class="groops-class" href="fileFormat_instrument.html">inputfileTimeSeries</a> starts with all data (<code>data0</code>, <code>data1</code>) for the first point, followed by all data of the second point and so on. If <strong class="groops-config-element">isGroupedDataByPoint</strong> is false, the file starts with <code>data0</code> for all points, followed by all <code>data1</code> and so on.</p><p>See also <a class="groops-program" href="GriddedData2TimeSeries.html">GriddedData2TimeSeries</a>.'},
'Instrument2AllanVariance': { 'name': 'Instrument2AllanVariance', 'key': 'Instrument2AllanVariance', 'description': 'This program computes the overlapping Allan variance from an   This program computes the overlapping Allan variance from an  . The estimate is averaged over all arcs (arcs are assumed to contain no data gaps). The overlapping Allan variance is defined as  where   is the averaging interval defined by the median sampling  .', 'config_table': 'outputfileAllanVariance filename column 0: averaging interval [seconds], column 1-(n-1): Allan variance for each data column inputfileInstrument filename', 'display_text': 'This program computes the overlapping Allan variance from an <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a>. The estimate is averaged over all arcs (arcs are assumed to contain no data gaps).</p><p>The overlapping Allan variance is defined as \\[   \\sigma^2(m\\tau_0) = \\frac{1}{2(m\\tau_0)^2(N-2m)} \\sum_{n=1}^{N-2m}(x_{n+2m}-2x_{n+m}+x_n)^2, \\]where $m\\tau_0$ is the averaging interval defined by the median sampling $\\tau_0$.'},
'Instrument2CovarianceFunctionVCE': { 'name': 'Instrument2CovarianceFunctionVCE', 'key': 'Instrument2CovarianceFunctionVCE', 'description': 'This estimates a covariance function of   This estimates a covariance function of   for all selected columns with  startDataFields  and  countDataFields . The estimation is performed robustly via variance component estimation. Bad arcs are downweigthed and the accuracies can be written with   This estimates a covariance function of  . The length of the covariance functions are determined by the longest arc. Additionaly the data can be detrended with   This estimates a covariance function of   and   This estimates a covariance function of  .', 'config_table': 'outputfileCovarianceFunction filename covariance functions outputfileSigmasPerArc filename accuracies of each arc outputfileResiduals filename  outputfileSolution filename estimated parameter vector (global part only) inputfileInstrument filename  startDataFields uint start countDataFields uint number of data fields (default: all after start) parameter parametrizationTemporalType data is reduced by temporal representation parameterPerArc parametrizationTemporalType data is reduced by temporal representation iterationCount uint number of iterations for the estimation', 'display_text': 'This estimates a covariance function of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> for all selected columns with <strong class="groops-config-element">startDataFields</strong> and <strong class="groops-config-element">countDataFields</strong>. The estimation is performed robustly via variance component estimation. Bad arcs are downweigthed and the accuracies can be written with <a class="groops-class" href="fileFormat_matrix.html">outputfileSigmasPerArc</a>. The length of the covariance functions are determined by the longest arc. Additionaly the data can be detrended with <a class="groops-class" href="parametrizationTemporalType.html">parameter</a> and <a class="groops-class" href="parametrizationTemporalType.html">parameterPerArc</a>.'},
'Instrument2CrossCorrelationFunction': { 'name': 'Instrument2CrossCorrelationFunction', 'key': 'Instrument2CrossCorrelationFunction', 'description': 'This program computes the cross correlation between all corresponding data columns in two  instrument files . The instrument files must be synchronized ( InstrumentSynchronize ). The   This program computes the cross correlation between all corresponding data columns in two   is a matrix with the first column containing the time lag followed by cross-correlation function for each data column. The maximum lag is defined by the maximum arc length. The correlation is based on the unbiased estimate of the cross-covariance between data columns   and  ,  which is averaged over all arcs. From this estimate, the correlation for each lag is then computed via  which is the ratio between the biased estimates of the cross-covariance at lag   and the auto-covariance of the individual data columns. For instrument with data gaps, lag bins without any data are set to NAN.', 'config_table': 'outputfileCorrelation filename column 1: time lag, column 2..n cross-correlation inputfileInstrument filename  inputfileInstrumentReference filename', 'display_text': 'This program computes the cross correlation between all corresponding data columns in two <a class="groops-file" href="fileFormat_instrument.html">instrument files</a>. The instrument files must be synchronized (<a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>). The <a class="groops-class" href="fileFormat_matrix.html">outputfileCorrelation</a> is a matrix with the first column containing the time lag followed by cross-correlation function for each data column. The maximum lag is defined by the maximum arc length.</p><p>The correlation is based on the unbiased estimate of the cross-covariance between data columns $x$ and $y$, \\[   \\sigma_{xy}(h) = \\frac{1}{N}\\sum_{k=1} x_{k+h} y_k, \\]which is averaged over all arcs. From this estimate, the correlation for each lag is then computed via \\[   r_{xy}(h) = \\frac{\\sigma_{xy}(h)}{\\sigma_x(0)\\sigma_y(0)}, \\]which is the ratio between the biased estimates of the cross-covariance at lag $h$ and the auto-covariance of the individual data columns.</p><p>For instrument with data gaps, lag bins without any data are set to NAN.'},
'Instrument2Histogram': { 'name': 'Instrument2Histogram', 'key': 'Instrument2Histogram', 'description': 'This program computes the arc-wise histogram from an  instrument file . The output is a  matrix  with the first column containing the lower bound of each bin. The other columns contain the histograms for each arc.', 'config_table': 'outputfileMatrix filename column 1: lower bin bound; columns 2 to N: histogram of each arc inputfileInstrument filename  selectDataField uint select channel for histogram computation binCount uint (default: Freedman-Diaconis\' choice, maximum of all channels) lowerBound expression lower bound for bins (default: global minimum, data values outside are ignored) upperBound expression upper bound for bins (default: global maximum, data values outside are ignored) relative boolean output relative frequencies cumulative boolean accumulate frequencies', 'display_text': 'This program computes the arc-wise histogram from an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>. The output is a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> with the first column containing the lower bound of each bin. The other columns contain the histograms for each arc.</p><p>'},
'Instrument2PowerSpectralDensity': { 'name': 'Instrument2PowerSpectralDensity', 'key': 'Instrument2PowerSpectralDensity', 'description': 'This program computes the power spectral density (PSD) for all data fields in an  instrument file . The PSD is computed using Lomb\'s method. For each arc and each frequency  , a sinusoid is fit to the data   The PSD for this frequency is then computed by forming the square sum of adjusted observations:   The resulting PSD is the average over all arcs. For regularly sampled time series, this method yields the same results as FFT based PSD estimates. A regular frequency grid based on the longest arc and the median sampling is computed. The maximum number of epochs per arc is determined by  the Nyquist frequency is given by   If it is suspected that   This program computes the power spectral density (PSD) for all data fields in an   contains secular variations, the input should be detrended using  InstrumentDetrend . See also  Instrument2CovarianceFunctionVCE ,  CovarianceFunction2PowerSpectralDensity ,  PowerSpectralDensity2CovarianceFunction .', 'config_table': 'outputfilePSD filename estimated PSD: column 0: frequency vector, column 1-(n-1): PSD estimate for each channel inputfileInstrument filename', 'display_text': 'This program computes the power spectral density (PSD) for all data fields in an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>. The PSD is computed using Lomb\'s method. For each arc and each frequency $f$, a sinusoid is fit to the data \\[   l_i = a \\cos(2\\pi f t_i) + b \\sin(2\\pi f t_i) + e_i \\] The PSD for this frequency is then computed by forming the square sum of adjusted observations: \\[   P(f) = \\sum_i \\hat{l}^2_i. \\] The resulting PSD is the average over all arcs. For regularly sampled time series, this method yields the same results as FFT based PSD estimates.</p><p>A regular frequency grid based on the longest arc and the median sampling is computed. The maximum number of epochs per arc is determined by \\[   N = \\frac{t_{\\text{end}} - t_{\\text{start}}}{\\Delta t_{\\text{median}} } + 1, \\]the Nyquist frequency is given by \\[   f_{\\text{nyq}} = \\frac{1}{2\\Delta t_{\\text{median}}}. \\] If it is suspected that <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> contains secular variations, the input should be detrended using <a class="groops-program" href="InstrumentDetrend.html">InstrumentDetrend</a>.</p><p>See also <a class="groops-program" href="Instrument2CovarianceFunctionVCE.html">Instrument2CovarianceFunctionVCE</a>, <a class="groops-program" href="CovarianceFunction2PowerSpectralDensity.html">CovarianceFunction2PowerSpectralDensity</a>, <a class="groops-program" href="PowerSpectralDensity2CovarianceFunction.html">PowerSpectralDensity2CovarianceFunction</a>.'},
'Instrument2RmsPlotGrid': { 'name': 'Instrument2RmsPlotGrid', 'key': 'Instrument2RmsPlotGrid', 'description': 'This program computes an RMS plot grid from one or more   This program computes an RMS plot grid from one or more   containing 3D data (e.g. orbits or station positions), which can then be plotted as gridded data in  PlotGraph . The RMS is computed from the difference between   This program computes an RMS plot grid from one or more   and   This program computes an RMS plot grid from one or more  . All instrument files must be synchronized (see  InstrumentSynchronize ). Each separate   This program computes an RMS plot grid from one or more   represents an entry (e.g. a satellite or station) in the resulting grid. Therefore, providing, for example, 32 orbit files of GPS satellites results in a grid with columns: mjd, id (0-31), rms. The first three data columns of the instrument data are considered for computation of the RMS values. The  factor  can be set to, for example, sqrt(3) to get 3D instead of 1D RMS values. If   This program computes an RMS plot grid from one or more   are provided, each   This program computes an RMS plot grid from one or more   and   This program computes an RMS plot grid from one or more   serves as a template with variable  loopTime . This allows concatenation of instrument files, for example to create a month-long RMS plot grid from daily GPS orbit files (see below). Helmert parameters between the two frames can be estimated each epoch optionally if  estimateShift ,  estimateScale , or  estimateRotation  are set. It uses a  robust least squares adjustment .', 'config_table': 'outputfileRmsPlotGrid filename columns: mjd, id, rms outputfileHelmertTimeSeries filename columns: mjd, tx, ty, tz, scale, rx, ry, rz inputfileInstrument filename one file per satellite/station inputfileInstrumentReference filename one file per satellite/station, same order as above timeIntervals timeSeriesType for {loopTime} variable in inputfile factor double e.g. sqrt(3) for 3D RMS estimateShift boolean coordinate center every epoch estimateScale boolean scale factor of position every epoch estimateRotation boolean rotation every epoch huber double for robust least squares huberPower double for robust least squares huberMaxIteration uint (maximum) number of iterations for robust estimation', 'display_text': 'This program computes an RMS plot grid from one or more <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> containing 3D data (e.g. orbits or station positions), which can then be plotted as gridded data in <a class="groops-program" href="PlotGraph.html">PlotGraph</a>. The RMS is computed from the difference between <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> and <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrumentReference</a>. All instrument files must be synchronized (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).</p><p>Each separate <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> represents an entry (e.g. a satellite or station) in the resulting grid. Therefore, providing, for example, 32 orbit files of GPS satellites results in a grid with columns: mjd, id (0-31), rms.</p><p>The first three data columns of the instrument data are considered for computation of the RMS values. The <strong class="groops-config-element">factor</strong> can be set to, for example, sqrt(3) to get 3D instead of 1D RMS values.</p><p>If <a class="groops-class" href="timeSeriesType.html">timeIntervals</a> are provided, each <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> and <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrumentReference</a> serves as a template with variable <code>loopTime</code>. This allows concatenation of instrument files, for example to create a month-long RMS plot grid from daily GPS orbit files (see below).</p><p>Helmert parameters between the two frames can be estimated each epoch optionally if <strong class="groops-config-element">estimateShift</strong>, <strong class="groops-config-element">estimateScale</strong>, or <strong class="groops-config-element">estimateRotation</strong> are set. It uses a <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a>.</p><p>'},
'Instrument2Scaleogram': { 'name': 'Instrument2Scaleogram', 'key': 'Instrument2Scaleogram', 'description': 'This program computes the wavelet transform of a time series up to a  maxLevel . The scalogram is written to a matrix which can be plotted by using a gridded layer in  PlotGraph . Individual detail levels can be written to matrix files by setting   This program computes the wavelet transform of a time series up to a  . The data column to be decomposed must be set by  selectDataField . The wavelet transform is implemented as a filter bank, so care should be taken when the input contains data gaps. Low/highpass wavelet filters are applied in forward and backward direction, input is padded symmetric. See   This program computes the wavelet transform of a time series up to a   for details.', 'config_table': 'outputfileScaleogram filename matrix columns: mjd, level, value outputfileLevels filename use loopLevel as variable inputfileInstrument filename  inputfileWavelet filename wavelet coefficients selectDataField uint data column to transform maxLevel uint maximum level of decomposition (default: full)', 'display_text': 'This program computes the wavelet transform of a time series up to a <strong class="groops-config-element">maxLevel</strong>. The scalogram is written to a matrix which can be plotted by using a gridded layer in <a class="groops-program" href="PlotGraph.html">PlotGraph</a>. Individual detail levels can be written to matrix files by setting <a class="groops-class" href="fileFormat_matrix.html">outputfileLevels</a>. The data column to be decomposed must be set by <strong class="groops-config-element">selectDataField</strong>.</p><p>The wavelet transform is implemented as a filter bank, so care should be taken when the input contains data gaps. Low/highpass wavelet filters are applied in forward and backward direction, input is padded symmetric. See <a class="groops-class" href="digitalFilterType.html">digitalFilter</a> for details.</p><p>'},
'Instrument2SpectralCoherence': { 'name': 'Instrument2SpectralCoherence', 'key': 'Instrument2SpectralCoherence', 'description': 'This program computes the spectral coherence between two  instrument files . The (magnitude-squared) coherence is defined as  and is a measure in the range [0, 1] for the similarity of the signals   and   in frequency domain.   is the cross-spectral density between   and   and  ,   are auto-spectral densities. Auto- and cross-spectral densities are computed using Lomb\'s method (see  Instrument2PowerSpectralDensity  for details). The resulting PSD is the average over all arcs. For regularly sampled time series, this method yields the same results as FFT based PSD estimates. A regular frequency grid based on the longest arc and the median sampling is computed. The maximum number of epochs per arc is determined by  the Nyquist frequency is given by   If it is suspected that   This program computes the spectral coherence between two   contains secular variations, the input should be detrended using  InstrumentDetrend . The   This program computes the spectral coherence between two   contains a matrix with the frequency vector as first column, the coherence for each instrument channel is saved in the following columns.', 'config_table': 'outputfileCoherence filename column 1: frequency, column 2-n coherence inputfileInstrument filename  inputfileInstrumentReference filename', 'display_text': 'This program computes the spectral coherence between two <a class="groops-file" href="fileFormat_instrument.html">instrument files</a>.</p><p>The (magnitude-squared) coherence is defined as \\[   C_{xy}(f) = \\frac{|P_{xy}(f)|^2}{P_{xx}(f)P_{yy}(f)} \\]and is a measure in the range [0, 1] for the similarity of the signals $x$ and $y$ in frequency domain. $P_{xy}$ is the cross-spectral density between $x$ and $y$ and $P_{xx}$, $P_{yy}$ are auto-spectral densities. Auto- and cross-spectral densities are computed using Lomb\'s method (see <a class="groops-program" href="Instrument2PowerSpectralDensity.html">Instrument2PowerSpectralDensity</a> for details).</p><p>The resulting PSD is the average over all arcs. For regularly sampled time series, this method yields the same results as FFT based PSD estimates.</p><p>A regular frequency grid based on the longest arc and the median sampling is computed. The maximum number of epochs per arc is determined by \\[   N = \\frac{t_{\\text{end}} - t_{\\text{start}}}{\\Delta t_{\\text{median}} } + 1, \\]the Nyquist frequency is given by \\[   f_{\\text{nyq}} = \\frac{1}{2\\Delta t_{\\text{median}}}. \\] If it is suspected that <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> contains secular variations, the input should be detrended using <a class="groops-program" href="InstrumentDetrend.html">InstrumentDetrend</a>.</p><p>The <a class="groops-class" href="fileFormat_matrix.html">outputfileCoherence</a> contains a matrix with the frequency vector as first column, the coherence for each instrument channel is saved in the following columns.'},
'Instrument2Spectrogram': { 'name': 'Instrument2Spectrogram', 'key': 'Instrument2Spectrogram', 'description': 'This program applies the Short Time Fourier Transform (STFT) to selected data columns of   This program applies the Short Time Fourier Transform (STFT) to selected data columns of   and computes the spectrogram. The STFT is computed at centered   This program applies the Short Time Fourier Transform (STFT) to selected data columns of   with an (possible overlapping) rectangular window with  windowLength  seconds. Data gaps are zero padded within the window. The   This program applies the Short Time Fourier Transform (STFT) to selected data columns of   is a matrix with each row the time (MJD), the frequency  , and the amplitudes   for the selected data columns. It can be plotted with  PlotGraph .', 'config_table': 'outputfileSpectrogram filename mjd, freq, ampl0, ampl1, ... inputfileInstrument filename  timeSeries timeSeriesType center of SFFT window windowLength double [seconds] startDataFields uint start countDataFields uint number of data fields (default: all)', 'display_text': 'This program applies the Short Time Fourier Transform (STFT) to selected data columns of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> and computes the spectrogram. The STFT is computed at centered <a class="groops-class" href="timeSeriesType.html">timeSeries</a> with an (possible overlapping) rectangular window with <strong class="groops-config-element">windowLength</strong> seconds. Data gaps are zero padded within the window.</p><p>The <a class="groops-class" href="fileFormat_matrix.html">outputfileSpectrogram</a> is a matrix with each row the time (MJD), the frequency $[Hz]$, and the amplitudes $[unit/\\sqrt{Hz}]$ for the selected data columns. It can be plotted with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.</p><p>'},
'InstrumentAccelerometer2ThermosphericDensity': { 'name': 'InstrumentAccelerometer2ThermosphericDensity', 'key': 'InstrumentAccelerometer2ThermosphericDensity', 'description': 'This program estimates neutral mass densities along the satellite trajectory based on  accelerometer data . In order to determine the neutral mass density the accelerometer input should only reflect the accelerations due to drag (e.g.   This program estimates neutral mass densities along the satellite trajectory based on  ). Thus, influences from solar and Earth radiation pressure must be reduced beforehand.', 'config_table': 'outputfileDensity filename MISCVALUE (kg/m^3) satelliteModel filename satellite macro model inputfileOrbit filename  inputfileStarCamera filename  inputfileAccelerometer filename add non-gravitational forces in satellite reference frame thermosphere thermosphereType used to compute temperature and wind considerTemperature boolean compute drag and lift, otherwise simple drag coefficient is used considerWind boolean  earthRotation earthRotationType  ephemerides ephemeridesType', 'display_text': 'This program estimates neutral mass densities along the satellite trajectory based on <a class="groops-file" href="fileFormat_instrument.html">accelerometer data</a>. In order to determine the neutral mass density the accelerometer input should only reflect the accelerations due to drag (e.g. <a class="groops-class" href="miscAccelerationsType.html#atmosphericDrag">miscAccelerations:atmosphericDrag</a>). Thus, influences from solar and Earth radiation pressure must be reduced beforehand.'},
'InstrumentAccelerometerApplyEstimatedParameters': { 'name': 'InstrumentAccelerometerApplyEstimatedParameters', 'key': 'InstrumentAccelerometerApplyEstimatedParameters', 'description': 'This program evaluates estimated satellite parameters and writes the result to an accelerometer file.', 'config_table': 'outputfileAccelerometer filename  inputfileSatelliteModel filename satellite macro model inputfileOrbit filename  inputfileStarCamera filename  inputfileAccelerometer filename add non-gravitational forces in satellite reference frame earthRotation earthRotationType  ephemerides ephemeridesType may be needed by parametrizationAcceleration parametrizationAcceleration parametrizationAccelerationType orbit force parameters inputfileParameter filename estimated orbit force parameters indexStart int position in the solution vector rightSide int if solution contains several right hand sides, select one factor double the result is multiplied by this factor', 'display_text': 'This program evaluates estimated satellite parameters and writes the result to an accelerometer file.'},
'InstrumentAccelerometerEstimateBiasScale': { 'name': 'InstrumentAccelerometerEstimateBiasScale', 'key': 'InstrumentAccelerometerEstimateBiasScale', 'description': 'This program calibrates   This program calibrates   with respect to simulated accelerometer data, see  SimulateAccelerometer . The parameters   This program calibrates   of   This program calibrates   are estimated and the effect is reduced to calibrate the  accelerometer data . If   This program calibrates   is given, the corresponding epochs (within  marginThruster ) are not used for the parameter estimation, but the accelerometer epochs are still calibrated afterwards. An arbitrary instrument file is allowed here. The   This program calibrates  ,   This program calibrates  ,   This program calibrates  ,   This program calibrates  , and   This program calibrates   are only needed for some special parametrizations.', 'config_table': 'outputfileAccelerometer filename  outputfileSolution filename  inputfileAccelerometer filename  inputfileAccelerometerSim filename  inputfileThruster filename remove thruster events marginThruster double margin size (on both sides) [seconds] inputfileOrbit filename  inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType may be needed by parametrizationAcceleration inputfileSatelliteModel filename satellite macro model parametrizationAcceleration parametrizationAccelerationType', 'display_text': 'This program calibrates <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> with respect to simulated accelerometer data, see <a class="groops-program" href="SimulateAccelerometer.html">SimulateAccelerometer</a>. The parameters <a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a> of <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a> are estimated and the effect is reduced to calibrate the <a class="groops-file" href="fileFormat_instrument.html">accelerometer data</a>.</p><p>If <a class="groops-class" href="fileFormat_instrument.html">inputfileThruster</a> is given, the corresponding epochs (within <strong class="groops-config-element">marginThruster</strong>) are not used for the parameter estimation, but the accelerometer epochs are still calibrated afterwards. An arbitrary instrument file is allowed here.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>, <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>, <a class="groops-class" href="earthRotationType.html">earthRotation</a>, <a class="groops-class" href="ephemeridesType.html">ephemerides</a>, and <a class="groops-class" href="fileFormat_satelliteModel.html">satelliteModel</a> are only needed for some special parametrizations.'},
'InstrumentAccelerometerEstimateParameters': { 'name': 'InstrumentAccelerometerEstimateParameters', 'key': 'InstrumentAccelerometerEstimateParameters', 'description': 'This program estimates calibration parameters for acceleration data given given an optional reference acceleration. Specifically, the program solves the equation  for the unknown parameters  , where   is given in   This program estimates calibration parameters for acceleration data given given an optional reference acceleration. Specifically, the program solves the equation   and   is given in    This program estimates calibration parameters for acceleration data given given an optional reference acceleration. Specifically, the program solves the equation  . The parametrization of   can be set via   This program estimates calibration parameters for acceleration data given given an optional reference acceleration. Specifically, the program solves the equation  . Optionally, the empirical covariance functions for the accelerations   can be estimated by enabling  estimateCovarianceFunctions . The estimated parameters are written to the file   This program estimates calibration parameters for acceleration data given given an optional reference acceleration. Specifically, the program solves the equation   and can be used by  InstrumentAccelerometerApplyEstimatedParameters  to calibrate accelerometer measurements.', 'config_table': 'outputfileSolution filename values for estimated parameters outputfileParameterNames filename names of the estimated parameters estimateArcSigmas sequence  outputfileArcSigmas filename accuracies of each arc estimateEpochSigmas sequence  outputfileEpochSigmas filename estimated epoch-wise sigmas estimateCovarianceFunctions sequence  outputfileCovarianceFunction filename covariance functions for x, y, z direction inputfileAccelerometer filename  inputfileAccelerometerReference filename if not given, reference acceleration is assumed zero inputfileOrbit filename may be needed by parametrizationAcceleration inputfileStarCamera filename may be needed by parametrizationAcceleration inputfileSatelliteModel filename satellite macro model (may be needed by parametrizationAcceleration) earthRotation earthRotationType may be needed by parametrizationAcceleration ephemerides ephemeridesType may be needed by parametrizationAcceleration parametrizationAcceleration parametrizationAccelerationType  sigmaX double apriori accuracy in x-axis sigmaY double apriori accuracy in y-axis sigmaZ double apriori accuracy in z-axis iterationCount uint iteration count for determining the covariance function', 'display_text': 'This program estimates calibration parameters for acceleration data given given an optional reference acceleration. Specifically, the program solves the equation \\[   \\mathbf{a} - \\mathbf{a}_\\text{ref} = \\mathbf{f}(\\mathbf{x}) + \\mathbf{e} \\]for the unknown parameters $\\mathbf{x}$, where $\\mathbf{a}$ is given in <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> and $\\mathbf{a}_\\text{ref}$ is given in  <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometerReference</a>. The parametrization of $\\mathbf{x}$ can be set via <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a>. Optionally, the empirical covariance functions for the accelerations $\\mathbf{a}$ can be estimated by enabling <strong class="groops-config-element">estimateCovarianceFunctions</strong>.</p><p>The estimated parameters are written to the file <a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a> and can be used by <a class="groops-program" href="InstrumentAccelerometerApplyEstimatedParameters.html">InstrumentAccelerometerApplyEstimatedParameters</a> to calibrate accelerometer measurements.'},
'InstrumentApplyTimeOffset': { 'name': 'InstrumentApplyTimeOffset', 'key': 'InstrumentApplyTimeOffset', 'description': 'This program applies a   This program applies a   (MISCVALUE) to an   This program applies a  . The time offsets in seconds are multiplicated with a  factor . The instrument files must be synchronized (see  InstrumentSynchronize ).', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  inputfileTimeOffset filename MISCVALUE with time offset in seconds factor double applied to time offset', 'display_text': 'This program applies a <a class="groops-class" href="fileFormat_instrument.html">inputfileTimeOffset</a> (MISCVALUE) to an <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a>. The time offsets in seconds are multiplicated with a <strong class="groops-config-element">factor</strong>. The instrument files must be synchronized (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).'},
'InstrumentArcCalculate': { 'name': 'InstrumentArcCalculate', 'key': 'InstrumentArcCalculate', 'description': 'This program manipulates the data columns every arc of an  instrument file  similar to  FunctionsCalculate , see there for more details. If several   This program manipulates the data columns every arc of an  s are given the data columns are copied side by side. For this the instrument files must be synchronized (see  InstrumentSynchronize ). For the data columns the standard data variables are available, see  dataVariables . For the time column (MJD) a variable  epoch  (together with  epochmean ,  epochmin ,  ) is defined additionally. The content of   This program manipulates the data columns every arc of an   is controlled by  outColumn . The number of  outColumn  must agree with the selected   This program manipulates the data columns every arc of an  . The algorithm to compute the output is as follows: The expressions in  outColumn  are evaluated once for each epoch of the input. The variables  data0 ,  data1 ,  are replaced by the according values from the input columns before. If no  outColumn  are specified all input columns are used instead directly. The   This program manipulates the data columns every arc of an   can be specified with  outType  and must be agree with the number of columns. An extra  statistics  file can be generated with one mid epoch per arc. For the computation of the  outColumn  values all  dataVariables  are available (e.g.  epochmin ,  data0mean ,  data1std ,  ) inclusively the  constant s and estimated  parameter s but without the  data0 ,  data1 ,  itself. The variables and the numbering of the columns refers to the   This program manipulates the data columns every arc of an  . See also  FunctionsCalculate ,  MatrixCalculate .', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename data columns are appended to the right constant expression define a constant by name=value parameter expression define a parameter by name[=value] leastSquares expression try to minimize the expression by adjustment of the parameters removalCriteria expression row is removed if one criterion evaluates true. outType instrumentTypeType  outColumn expression expression of output columns, extra \'epoch\' variable statistics sequence  outputfileInstrument filename instrument file with mid epoch per arc, data columns are user defined outColumn expression expression to compute statistics columns, data* are from outColumn', 'display_text': 'This program manipulates the data columns every arc of an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> similar to <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a>, see there for more details. If several <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a>s are given the data columns are copied side by side. For this the instrument files must be synchronized (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>). For the data columns the standard data variables are available, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>. For the time column (MJD) a variable <code>epoch</code> (together with <code>epochmean</code>, <code>epochmin</code>, ) is defined additionally.</p><p>The content of <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrument</a> is controlled by <strong class="groops-config-element">outColumn</strong>. The number of <strong class="groops-config-element">outColumn</strong> must agree with the selected <a class="groops-class" href="instrumentTypeType.html">outType</a>. The algorithm to compute the output is as follows: The expressions in <strong class="groops-config-element">outColumn</strong> are evaluated once for each epoch of the input. The variables <code>data0</code>, <code>data1</code>, are replaced by the according values from the input columns before. If no <strong class="groops-config-element">outColumn</strong> are specified all input columns are used instead directly. The <a class="groops-class" href="instrumentTypeType.html">instrument type</a> can be specified with <strong class="groops-config-element">outType</strong> and must be agree with the number of columns.</p><p>An extra <strong class="groops-config-element">statistics</strong> file can be generated with one mid epoch per arc. For the computation of the <strong class="groops-config-element">outColumn</strong> values all <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available (e.g. <code>epochmin</code>, <code>data0mean</code>, <code>data1std</code>, ) inclusively the <strong class="groops-config-element">constant</strong>s and estimated <strong class="groops-config-element">parameter</strong>s but without the <code>data0</code>, <code>data1</code>, itself. The variables and the numbering of the columns refers to the <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrument</a>.</p><p>See also <a class="groops-program" href="FunctionsCalculate.html">FunctionsCalculate</a>, <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a>.'},
'InstrumentArcCrossStatistics': { 'name': 'InstrumentArcCrossStatistics', 'key': 'InstrumentArcCrossStatistics', 'description': 'Computes statistics of selected data columns between two  instrument files  arc wise. The   Computes statistics of selected data columns between two   contains for every arc one (mid) epoch with statistics column(s). Possible statistics are      Correlation       Error RMS       Nash-Sutcliffe coefficient (NSC)     With  removeArcMean  the mean of each data column of each arc is reduced before. With  perColumn  separate statistics for each selected data column are computed, otherwise an overall value is computed. See also  InstrumentArcStatistics ,  InstrumentStatisticsTimeSeries .', 'config_table': 'outputfileStatisticsTimeSeries filename statistics column(s) per arc, MISCVALUES inputfileInstrument filename  inputfileInstrumentReference filename  statistics choice  correlation   errorRMS  rms of differences nashSutcliffe  with respect to reference field removeArcMean boolean  startDataFields uint start countDataFields uint number of data fields (default: all) perColumn boolean compute statistic per column', 'display_text': 'Computes statistics of selected data columns between two <a class="groops-file" href="fileFormat_instrument.html">instrument files</a> arc wise. The <a class="groops-class" href="fileFormat_instrument.html">outputfileStatisticsTimeSeries</a> contains for every arc one (mid) epoch with statistics column(s). Possible statistics are <ul>    <li>Correlation   \\[     \\rho = \\frac{\\sum_i x_i y_i}{\\sqrt{(\\sum_i x_i^2) (\\sum_i y_i^2})},   \\]  </li><li> Error RMS   \\[     rms = \\sqrt{\\frac{1}{N}\\sum_i (x_i-y_i)^2},   \\]  </li><li> Nash-Sutcliffe coefficient (NSC)   \\[     nsc = 1- \\frac{\\sum_i (x_i-y_i)^2}{\\sum_i (y_i-\\bar{y})^2}.   \\]</li></ul>  With <strong class="groops-config-element">removeArcMean</strong> the mean of each data column of each arc is reduced before.</p><p>With <strong class="groops-config-element">perColumn</strong> separate statistics for each selected data column are computed, otherwise an overall value is computed.</p><p>See also <a class="groops-program" href="InstrumentArcStatistics.html">InstrumentArcStatistics</a>, <a class="groops-program" href="InstrumentStatisticsTimeSeries.html">InstrumentStatisticsTimeSeries</a>.'},
'InstrumentArcStatistics': { 'name': 'InstrumentArcStatistics', 'key': 'InstrumentArcStatistics', 'description': 'Computes statistics of selected data columns of   Computes statistics of selected data columns of   arc wise. The   Computes statistics of selected data columns of   contains for every arc one (mid) epoch with statistics column(s). Possible statistics are root mean square, standard deviation, mean, median, min, and max. With  perColumn  separate statistics for each selected data column are computed, otherwise an overall value is computed. See also  InstrumentArcCrossStatistics ,  InstrumentStatisticsTimeSeries .', 'config_table': 'outputfileStatisticsTimeSeries filename columns: mjd, statistics column(s) per instrument file inputfileInstrument filename  statistics choice  rootMeanSquare   standardDeviation   mean   median   min   max   epochCount   startDataFields uint start countDataFields uint number of data fields (default: all) perColumn boolean compute statistic per column ignoreNan boolean ignore NaN values in input', 'display_text': 'Computes statistics of selected data columns of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> arc wise. The <a class="groops-class" href="fileFormat_instrument.html">outputfileStatisticsTimeSeries</a> contains for every arc one (mid) epoch with statistics column(s). Possible statistics are root mean square, standard deviation, mean, median, min, and max.</p><p>With <strong class="groops-config-element">perColumn</strong> separate statistics for each selected data column are computed, otherwise an overall value is computed.</p><p>See also <a class="groops-program" href="InstrumentArcCrossStatistics.html">InstrumentArcCrossStatistics</a>, <a class="groops-program" href="InstrumentStatisticsTimeSeries.html">InstrumentStatisticsTimeSeries</a>.'},
'InstrumentConcatenate': { 'name': 'InstrumentConcatenate', 'key': 'InstrumentConcatenate', 'description': 'This program concatenate the arcs from several  instrument files  and write it to a new  file . Input files must be of the same type. The arcs are merged to one arc even though there is a gap inbetween. To split the data into arcs use  InstrumentSynchronize . Three options are available:  sort ,  removeDuplicates  and  checkForNaNs . If  sort  is enabled, the program reads all files, no matter if they are sorted correctly in time, and then sorts the epochs. If  removeDuplicates  is enabled, the program checks the whole data set for epochs that are contained twice. And if  checkForNaNs  is enabled the data set is checked for invalid epochs containing NaNs.', 'config_table': 'outputfile filename  inputfile filename  sort boolean sort epochs with increasing time removeDuplicates choice remove duplicate epochs keepFirst sequence keep first epoch with the same time stamp, remove all others margin double margin for identical times [seconds] keepLast sequence keep last epoch with the same time stamp, remove all others margin double margin for identical times [seconds] checkForNaNs boolean remove epochs with NaN values in one of the data fields', 'display_text': 'This program concatenate the arcs from several <a class="groops-file" href="fileFormat_instrument.html">instrument files</a> and write it to a new <a class="groops-file" href="fileFormat_instrument.html">file</a>. Input files must be of the same type. The arcs are merged to one arc even though there is a gap inbetween. To split the data into arcs use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>. Three options are available: <strong class="groops-config-element">sort</strong>, <strong class="groops-config-element">removeDuplicates</strong> and <strong class="groops-config-element">checkForNaNs</strong>. If <strong class="groops-config-element">sort</strong> is enabled, the program reads all files, no matter if they are sorted correctly in time, and then sorts the epochs. If <strong class="groops-config-element">removeDuplicates</strong> is enabled, the program checks the whole data set for epochs that are contained twice. And if <strong class="groops-config-element">checkForNaNs</strong> is enabled the data set is checked for invalid epochs containing NaNs.'},
'InstrumentCovarianceCheck': { 'name': 'InstrumentCovarianceCheck', 'key': 'InstrumentCovarianceCheck', 'description': 'This program checks   This program checks   3x3 covariance matrices if they are invertible or not and removes the invalid epochs.', 'config_table': 'outputfileCovariance3d filename  inputfileCovariance3d filename', 'display_text': 'This program checks <a class="groops-class" href="fileFormat_instrument.html">inputfileCovariance3d</a> 3x3 covariance matrices if they are invertible or not and removes the invalid epochs.'},
'InstrumentDetrend': { 'name': 'InstrumentDetrend', 'key': 'InstrumentDetrend', 'description': 'Reduces   Reduces   (e.g. const, trend, polynomial) per arc from selected data columns of   Reduces   using a robust  robust least squares adjustment . The   Reduces   contains for every arc one (mid) epoch with the estimated parameters. The order is: first all data ( data0 ,  data1 ,  ) of first temporal parameter, followed by all data of the second temporal parameter and so on.', 'config_table': 'outputfileInstrument filename detrended instrument time series outputfileTimeSeriesArcParameters filename time series of estimated parameters per arc inputfileInstrument filename  parametrizationTemporal parametrizationTemporalType per arc, data is reduced by temporal representation startDataFields uint start countDataFields uint number of data fields (default: all after start) huber double for robust least squares huberPower double for robust least squares huberMaxIteration uint (maximum) number of iterations for robust estimation', 'display_text': 'Reduces <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a> (e.g. const, trend, polynomial) per arc from selected data columns of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> using a robust <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a>.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeriesArcParameters</a> contains for every arc one (mid) epoch with the estimated parameters. The order is: first all data (<code>data0</code>, <code>data1</code>, ) of first temporal parameter, followed by all data of the second temporal parameter and so on.'},
'InstrumentEarthRotation': { 'name': 'InstrumentEarthRotation', 'key': 'InstrumentEarthRotation', 'description': 'Precompute Earth rotation matrix from celestial to terrestrial frame and save as  StarCamera file .', 'config_table': 'outputfileStarCamera filename rotation from CRF to TRF earthRotation earthRotationType  timeSeries timeSeriesType', 'display_text': 'Precompute Earth rotation matrix from celestial to terrestrial frame and save as <a class="groops-file" href="fileFormat_instrument.html">StarCamera file</a>.'},
'InstrumentEstimateEmpiricalCovariance': { 'name': 'InstrumentEstimateEmpiricalCovariance', 'key': 'InstrumentEstimateEmpiricalCovariance', 'description': 'This program estimates the empirical auto- and cross-covariance of selected data columns per arc of   This program estimates the empirical auto- and cross-covariance of selected data columns per arc of  . The maximum computed lag is determined by the number of   This program estimates the empirical auto- and cross-covariance of selected data columns per arc of   specified (for a single output file only the auto-covariance is determined, for two output files auto- and cross-covariance is computed and so on). Stationarity is assumed for the input time series, which means the temporal covariance matrix has Toeplitz structure.   The matrix for lag   describes the covariance between   and  , i.e.  . To get a reliable estimate,  InstrumentDetrend  should be called first.', 'config_table': 'outputfileCovarianceMatrix filename  inputfileInstrument filename  startDataFields uint start countDataFields uint number of data fields (default: all after start)', 'display_text': 'This program estimates the empirical auto- and cross-covariance of selected data columns per arc of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a>. The maximum computed lag is determined by the number of <a class="groops-class" href="fileFormat_matrix.html">outputfileCovarianceMatrix</a> specified (for a single output file only the auto-covariance is determined, for two output files auto- and cross-covariance is computed and so on).</p><p>Stationarity is assumed for the input time series, which means the temporal covariance matrix has Toeplitz structure. \\[ \\begin{bmatrix} \\Sigma & \\Sigma_{\\Delta_1} & \\Sigma_{\\Delta_2} & \\Sigma_{\\Delta_3} & \\Sigma_{\\Delta_4} \\\\        & \\Sigma            & \\Sigma_{\\Delta_1} & \\Sigma_{\\Delta_2} & \\Sigma_{\\Delta_3} \\\\        &                   & \\Sigma            & \\Sigma_{\\Delta_1} & \\Sigma_{\\Delta_2} \\\\        &                   &                   & \\Sigma            & \\Sigma_{\\Delta_1} \\\\        &                   &                   &                   & \\Sigma            \\\\ \\end{bmatrix} \\] The matrix for lag $h$ describes the covariance between $x_{t-h}$ and $x_{t}$, i.e. $\\Sigma(t-h, t)$.</p><p>To get a reliable estimate, <a class="groops-program" href="InstrumentDetrend.html">InstrumentDetrend</a> should be called first.'},
'InstrumentEstimateHelmertTransformation': { 'name': 'InstrumentEstimateHelmertTransformation', 'key': 'InstrumentEstimateHelmertTransformation', 'description': 'This program estimates a 3D Helmert transformation between two networks (frame realizations, e.g. GNSS satellite or station network). Each separate  data  represents a satellite/station/ (e.g. 32 GPS satellites). The instrument data (x,y,z position) considered can be set with  startData . The Helmert parameters are set up according to   This program estimates a 3D Helmert transformation between two networks (frame realizations, e.g. GNSS satellite or station network). Each separate   for each   This program estimates a 3D Helmert transformation between two networks (frame realizations, e.g. GNSS satellite or station network). Each separate   and are estimated using a  robust least squares adjustment .', 'config_table': 'outputfileHelmertTimeSeries filename columns: mjd, Tx,Ty,Tz,s,Rx,Ry,Rz according to temporal parametrization data sequence e.g. satellite, station outputfileInstrument filename transformed positions as instrument type Vector3d outputfileInstrumentDiff filename position difference as instrument type Vector3d inputfileInstrument filename  inputfileInstrumentReference filename  startDataFields uint start index of position (x,y,z) columns timeIntervals timeSeriesType parameters are estimated per interval parametrizationTemporal parametrizationTemporalType temporal parametrization estimateShift boolean coordinate center estimateScale boolean scale factor of position estimateRotation boolean rotation huber double for robust least squares huberPower double for robust least squares huberMaxIteration uint (maximum) number of iterations for robust estimation', 'display_text': 'This program estimates a 3D Helmert transformation between two networks (frame realizations, e.g. GNSS satellite or station network). Each separate <strong class="groops-config-element">data</strong> represents a satellite/station/(e.g. 32 GPS satellites). The instrument data (x,y,z position) considered can be set with <strong class="groops-config-element">startData</strong>. The Helmert parameters are set up according to <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a> for each <a class="groops-class" href="timeSeriesType.html">timeIntervals</a> and are estimated using a <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a>.'},
'InstrumentFilter': { 'name': 'InstrumentFilter', 'key': 'InstrumentFilter', 'description': 'This program filter selected data columns of   This program filter selected data columns of   with   This program filter selected data columns of   arc wise.', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  digitalFilter digitalFilterType  startDataFields uint start countDataFields uint number of data fields (default: all after start)', 'display_text': 'This program filter selected data columns of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> with <a class="groops-class" href="digitalFilterType.html">digitalFilter</a> arc wise.'},
'InstrumentInsertNAN': { 'name': 'InstrumentInsertNAN', 'key': 'InstrumentInsertNAN', 'description': 'This program inserts NAN epochs into   This program inserts NAN epochs into   files, either at specific   This program inserts NAN epochs into   or where gaps in the instrument are detected.', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  times timeSeriesType Insert NAN at specific times. atGaps boolean Insert NAN where epochs are more than 1.5 times the median sampling apart. atArcEnds boolean Insert one epoch with data NAN at arc ends', 'display_text': 'This program inserts NAN epochs into <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> files, either at specific <a class="groops-class" href="timeSeriesType.html">times</a> or where gaps in the instrument are detected.'},
'InstrumentMultiplyAdd': { 'name': 'InstrumentMultiplyAdd', 'key': 'InstrumentMultiplyAdd', 'description': 'This program multiply  instrument data  with a factor and add them together. Afterwards the mean of each arc and data column can be removed with  removeArcMean . The instrument files must be synchronized ( InstrumentSynchronize ). See also  InstrumentArcCalculate .', 'config_table': 'outputfileInstrument filename  instrument sequence  inputfileInstrument filename  factor double  removeArcMean boolean remove mean value of each arc', 'display_text': 'This program multiply <a class="groops-file" href="fileFormat_instrument.html">instrument data</a> with a factor and add them together. Afterwards the mean of each arc and data column can be removed with <strong class="groops-config-element">removeArcMean</strong>. The instrument files must be synchronized (<a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).</p><p>See also <a class="groops-program" href="InstrumentArcCalculate.html">InstrumentArcCalculate</a>.'},
'InstrumentReduceSampling': { 'name': 'InstrumentReduceSampling', 'key': 'InstrumentReduceSampling', 'description': 'This program reduce the sampling of a instrument file. Only epochs with a time stamp with a division by  sampling  without remainder are kept (inside  margin ).', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  sampling double new sampling in seconds margin double margin around the new sampling in seconds relative2FirstEpoch boolean compute sampling relative to time of first epoch', 'display_text': 'This program reduce the sampling of a instrument file. Only epochs with a time stamp with a division by <strong class="groops-config-element">sampling</strong> without remainder are kept (inside <strong class="groops-config-element">margin</strong>).'},
'InstrumentRemoveEpochsByCriteria': { 'name': 'InstrumentRemoveEpochsByCriteria', 'key': 'InstrumentRemoveEpochsByCriteria', 'description': 'This program removes epochs from   This program removes epochs from   by evaluating a set of  removalCriteria  expressions. For the data columns the standard data variables are available, see  dataVariables . The instrument data can be reduced by data from   This program removes epochs from   prior to evaluation of the expressions. To reduce the data by its median, use an expression like  data1-data1mean . To remove epochs that deviate by more than 3 sigma use  abs(data1)>3*data1std  or  abs(data0-data0median)>3*1.4826*data0mad . All arcs in the input instrument file are concatenated, meaning expressions like  data1mean  refer to the complete dataset. The removed epochs can be saved in a separate   This program removes epochs from  .', 'config_table': 'outputfileInstrument filename all data is stored in one arc outputfileInstrumentRemovedEpochs filename all data is stored in one arc inputfileInstrument filename arcs are concatenated for processing inputfileInstrumentReference filename if given, the reference data is reduced prior to the expressions being evaluated removalCriteria expression epochs are removed if one criterion evaluates true. data0 is the first data field. margin double remove data around identified epochs (on both sides) [seconds]', 'display_text': 'This program removes epochs from <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> by evaluating a set of <strong class="groops-config-element">removalCriteria</strong> expressions. For the data columns the standard data variables are available, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.</p><p>The instrument data can be reduced by data from <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrumentReference</a> prior to evaluation of the expressions.</p><p>To reduce the data by its median, use an expression like <code>data1-data1mean</code>. To remove epochs that deviate by more than 3 sigma use <code>abs(data1)>3*data1std</code> or <code>abs(data0-data0median)>3*1.4826*data0mad</code>.</p><p>All arcs in the input instrument file are concatenated, meaning expressions like <code>data1mean</code> refer to the complete dataset. The removed epochs can be saved in a separate <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrumentRemovedEpochs</a>.'},
'InstrumentRemoveEpochsByTimes': { 'name': 'InstrumentRemoveEpochsByTimes', 'key': 'InstrumentRemoveEpochsByTimes', 'description': 'This program compares an  instrument file  with a   This program compares an  . Epochs contained within the time series (including a defined margin) are removed from the instrument file. The margin is added on both sides of the epochs. The arcs of the instrument file are concatenated to one arc. The removed epochs can be saved in a separate instrument file.', 'config_table': 'outputfileInstrument filename all epochs are concatenated in one arc outputfileInstrumentRemovedEpochs filename all epochs are concatenated in one arc inputfileInstrument filename  timePoints timeSeriesType  margin double margin size (on both sides) [seconds]', 'display_text': 'This program compares an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> with a <a class="groops-class" href="timeSeriesType.html">time series</a>. Epochs contained within the time series (including a defined margin) are removed from the instrument file. The margin is added on both sides of the epochs. The arcs of the instrument file are concatenated to one arc. The removed epochs can be saved in a separate instrument file.'},
'InstrumentRemoveEpochsThruster': { 'name': 'InstrumentRemoveEpochsThruster', 'key': 'InstrumentRemoveEpochsThruster', 'description': 'This program remove epochs from an  instrument file . The epochs are defined by a  thruster file  plus a defined margin before and after the thruster firings. The arcs of the instrument file are concatenated to one arc. The removed epochs can be saved in a separate instrument file.', 'config_table': 'outputfileInstrument filename all epochs are concatenated in one arc outputfileInstrumentRemovedEpochs filename all epochs are concatenated in one arc inputfileInstrument filename  inputfileThruster filename THRUSTER marginBefore double margin before start of firing [seconds] marginAfter double margin after end of firing [seconds]', 'display_text': 'This program remove epochs from an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>. The epochs are defined by a <a class="groops-file" href="fileFormat_instrument.html">thruster file</a> plus a defined margin before and after the thruster firings. The arcs of the instrument file are concatenated to one arc. The removed epochs can be saved in a separate instrument file.'},
'InstrumentResample': { 'name': 'InstrumentResample', 'key': 'InstrumentResample', 'description': 'This program resamples  instrument data  to a given   This program resamples   using a resampling   This program resamples  . This program can also be used to reduce the sampling of an instrument file, but a better way to reduce the sampling of noisy data with regular sampling is to use a low pass filter first with  InstrumentFilter  and then thin out the data with  InstrumentReduceSampling .', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  method interpolatorTimeSeriesType resampling method timeSeries timeSeriesType resampled points in time', 'display_text': 'This program resamples <a class="groops-file" href="fileFormat_instrument.html">instrument data</a> to a given <a class="groops-class" href="timeSeriesType.html">timeSeries</a> using a resampling <a class="groops-class" href="interpolatorTimeSeriesType.html">method</a>.</p><p>This program can also be used to reduce the sampling of an instrument file, but a better way to reduce the sampling of noisy data with regular sampling is to use a low pass filter first with <a class="groops-program" href="InstrumentFilter.html">InstrumentFilter</a> and then thin out the data with <a class="groops-program" href="InstrumentReduceSampling.html">InstrumentReduceSampling</a>.'},
'InstrumentRotate': { 'name': 'InstrumentRotate', 'key': 'InstrumentRotate', 'description': 'This program rotates  instrument data  into a new reference frame (using   This program rotates  ). The rotation is usually done from satellite frame into inertial frame. To apply Earth rotation to orbits use  Orbit2EarthFixedOrbit  For other instrument data use  InstrumentEarthRotation  before.', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  inputfileStarCamera filename  inverseRotate boolean', 'display_text': 'This program rotates <a class="groops-file" href="fileFormat_instrument.html">instrument data</a> into a new reference frame (using <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>). The rotation is usually done from satellite frame into inertial frame.</p><p>To apply Earth rotation to orbits use <a class="groops-program" href="Orbit2EarthFixedOrbit.html">Orbit2EarthFixedOrbit</a> For other instrument data use <a class="groops-program" href="InstrumentEarthRotation.html">InstrumentEarthRotation</a> before.'},
'InstrumentSetType': { 'name': 'InstrumentSetType', 'key': 'InstrumentSetType', 'description': 'Convert  instrument data  into instrument data with new   Convert  . The selected number of data columns must agree with the   Convert  .', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  type instrumentTypeType  startDataFields uint start countDataFields uint number of data fields (default: all after start)', 'display_text': 'Convert <a class="groops-file" href="fileFormat_instrument.html">instrument data</a> into instrument data with new <a class="groops-class" href="instrumentTypeType.html">type</a>. The selected number of data columns must agree with the <a class="groops-class" href="instrumentTypeType.html">type</a>.'},
'InstrumentStarCamera2AccAngularRate': { 'name': 'InstrumentStarCamera2AccAngularRate', 'key': 'InstrumentStarCamera2AccAngularRate', 'description': 'This program derivate from a time series of quaternions a series of angular rates and angular accelerations. The derivatives are computed by a polynomial interpolation with  interpolationDegree  of the quaternions.', 'config_table': 'outputfileAngularRate filename [rad/s], VECTOR3D outputfileAngularAcc filename [rad/s**2], VECTOR3D inputfileStarCamera filename  interpolationDegree uint derivation by polynomial interpolation of degree n', 'display_text': 'This program derivate from a time series of quaternions a series of angular rates and angular accelerations. The derivatives are computed by a polynomial interpolation with <strong class="groops-config-element">interpolationDegree</strong> of the quaternions.'},
'InstrumentStarCamera2RollPitchYaw': { 'name': 'InstrumentStarCamera2RollPitchYaw', 'key': 'InstrumentStarCamera2RollPitchYaw', 'description': 'Compute roll, pitch, yaw angles from   Compute roll, pitch, yaw angles from   data. Optional the angles are computed relative to a   Compute roll, pitch, yaw angles from  . See also  SimulateStarCamera .', 'config_table': 'outputfileInstrument filename roll, pitch, yaw [rad], VECTOR3D inputfileStarCamera filename  inputfileStarCameraReference filename nominal orientation', 'display_text': 'Compute roll, pitch, yaw angles from <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> data. Optional the angles are computed relative to a <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCameraReference</a>.</p><p>See also <a class="groops-program" href="SimulateStarCamera.html">SimulateStarCamera</a>.'},
'InstrumentStarCamera2RotaryMatrix': { 'name': 'InstrumentStarCamera2RotaryMatrix', 'key': 'InstrumentStarCamera2RotaryMatrix', 'description': 'Write   Write   rotations as   Write   rotary matrices (for each epoch  ).', 'config_table': 'outputfileInstrument filename xx, xy, xz, yx, yy, yz, zx, zy, zz (MISCVALUES) inputfileStarCamera filename', 'display_text': 'Write <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> rotations as <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrument</a> rotary matrices (for each epoch $xx, xy, xz, yx, yy, yz, zx, zy, zz$).'},
'InstrumentStarCameraMultiply': { 'name': 'InstrumentStarCameraMultiply', 'key': 'InstrumentStarCameraMultiply', 'description': 'This program applies several rotations given by   This program applies several rotations given by  . The resulting rotation is written as   This program applies several rotations given by  . All instrument files must be synchronized ( InstrumentSynchronize ).', 'config_table': 'outputfileStarCamera filename  instrument sequence  inputfileStarCamera filename  inverse boolean', 'display_text': 'This program applies several rotations given by <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>. The resulting rotation is written as <a class="groops-class" href="fileFormat_instrument.html">outputfileStarCamera</a>. All instrument files must be synchronized (<a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).'},
'InstrumentStatisticsTimeSeries': { 'name': 'InstrumentStatisticsTimeSeries', 'key': 'InstrumentStatisticsTimeSeries', 'description': 'This program computes a time series of statistics for one or more instrument files. Possible statistics are root mean square, standard deviation, mean, median, min, and max. The columns of the output time series are defined either as one per   This program computes a time series of statistics for one or more instrument files. Possible statistics are root mean square, standard deviation, mean, median, min, and max. The columns of the output time series are defined either as one per   or, if  perColumn  is true, statistics are computed per column for each file. Providing e.g. 32 orbit files of GPS satellites results in a time series matrix with columns: mjd, statisticsG01, statisticsG02, ..., statisticsG32. If  intervals  are provided, the input data is split into these intervals and one statistic is computed per interval. Otherwise, overall statistics are computed. The instrument data considered for computation of the component-wise statistics can be set with  startDataFields  and  countDataFields . The  factor  can be set to e.g. sqrt(3) to get 3D instead of 1D RMS values. See also  InstrumentArcStatistics ,  InstrumentArcCrossStatistics .', 'config_table': 'outputfileStatisticsTimeSeries filename columns: mjd, statistics column(s) per instrument file inputfileInstrument filename  statistics choice  rootMeanSquare   standardDeviation   mean   median   sum   min   max   epochCount   startDataFields uint start countDataFields uint number of data fields (default: all) perColumn boolean compute statistic per column ignoreNan boolean ignore NaN values in statistic computation intervals timeSeriesType intervals for statistics computation (one statistic per interval) factor double e.g. sqrt(3) for 3D RMS', 'display_text': 'This program computes a time series of statistics for one or more instrument files. Possible statistics are root mean square, standard deviation, mean, median, min, and max. The columns of the output time series are defined either as one per <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> or, if <strong class="groops-config-element">perColumn</strong> is true, statistics are computed per column for each file. Providing e.g. 32 orbit files of GPS satellites results in a time series matrix with columns: mjd, statisticsG01, statisticsG02, ..., statisticsG32. If <strong class="groops-config-element">intervals</strong> are provided, the input data is split into these intervals and one statistic is computed per interval. Otherwise, overall statistics are computed. The instrument data considered for computation of the component-wise statistics can be set with <strong class="groops-config-element">startDataFields</strong> and <strong class="groops-config-element">countDataFields</strong>. The <strong class="groops-config-element">factor</strong> can be set to e.g. sqrt(3) to get 3D instead of 1D RMS values.</p><p>See also <a class="groops-program" href="InstrumentArcStatistics.html">InstrumentArcStatistics</a>, <a class="groops-program" href="InstrumentArcCrossStatistics.html">InstrumentArcCrossStatistics</a>.'},
'InstrumentSynchronize': { 'name': 'InstrumentSynchronize', 'key': 'InstrumentSynchronize', 'description': 'This program reads several  instrument files  and synchronize the data. Every epoch with some missing data will be deleted so the remaining epochs have data from every instrument. In a second step the epochs are divided into arcs with maximal epochs (or  maxArcLen ) without having a gap inside an arc. A Gap is defined by a time step with at least  minGap  seconds between consecutive epochs or if not set the 1.5 of the median sampling. Arc with an epoch count less than  minArcLen  will be rejected. A specific region can be selected with   This program reads several  . In this case one of the instrument data must an orbit. If   This program reads several   is given the data are also divided into time bins. The assignment of arcs to the bins can be saved in   This program reads several  . This file can be used for the variational equation approach or  KalmanBuildNormals . Instrument files from  irregularData  are not synchronized but divided into the same number of arcs within the same time intervals. Data outside the defined arcs will be deleted.', 'config_table': 'data sequence  outputfileInstrument filename  inputfileInstrument filename  margin double margin for identical times [seconds] minGap double minimal time to define a gap and to begin a new arc, 0: no dividing [seconds], if not set 1.5*median sampling is used minArcLength uint minimal number of epochs of an arc maxArcLength uint maximal number of epochs of an arc arcType choice all arcs or only ascending or descending arcs are selected ascending   descending   border borderType only data in a specific region is selected timeIntervals timeSeriesType divide data into time bins outputfileArcList filename arc and time bin mapping irregularData sequence instrument files with irregular sampling outputfileInstrument filename  inputfileInstrument filename  minArcLength uint minimal number of epochs in an arc', 'display_text': 'This program reads several <a class="groops-file" href="fileFormat_instrument.html">instrument files</a> and synchronize the data. Every epoch with some missing data will be deleted so the remaining epochs have data from every instrument.</p><p>In a second step the epochs are divided into arcs with maximal epochs (or <strong class="groops-config-element">maxArcLen</strong>) without having a gap inside an arc. A Gap is defined by a time step with at least <strong class="groops-config-element">minGap</strong> seconds between consecutive epochs or if not set the 1.5 of the median sampling. Arc with an epoch count less than <strong class="groops-config-element">minArcLen</strong> will be rejected.</p><p>A specific region can be selected with <a class="groops-class" href="borderType.html">border</a>. In this case one of the instrument data must an orbit.</p><p>If <a class="groops-class" href="timeSeriesType.html">timeIntervals</a> is given the data are also divided into time bins. The assignment of arcs to the bins can be saved in <a class="groops-class" href="fileFormat_arcList.html">outputfileArcList</a>. This file can be used for the variational equation approach or <a class="groops-program" href="KalmanBuildNormals.html">KalmanBuildNormals</a>.</p><p>Instrument files from <strong class="groops-config-element">irregularData</strong> are not synchronized but divided into the same number of arcs within the same time intervals. Data outside the defined arcs will be deleted.'},
'InstrumentWaveletDecomposition': { 'name': 'InstrumentWaveletDecomposition', 'key': 'InstrumentWaveletDecomposition', 'description': 'This program performs a multilevel one-dimensional wavelet analysis on one  selectDataField  data column of   This program performs a multilevel one-dimensional wavelet analysis on one  . The   This program performs a multilevel one-dimensional wavelet analysis on one   contains the decomposed levels in time domain', 'config_table': 'outputfileInstrument filename MISCVALUES, decomposed levels in time domain a_J,d_J,...,d_1 inputfileInstrument filename  selectDataField uint select a data column for decomposition inputfileWavelet filename wavelet coefficients level uint level of decomposition', 'display_text': 'This program performs a multilevel one-dimensional wavelet analysis on one <strong class="groops-config-element">selectDataField</strong> data column of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a>. The <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrument</a> contains the decomposed levels in time domain ${a_J,d_J,...,d_1}$'},
'LocalLevelFrame2StarCamera': { 'name': 'LocalLevelFrame2StarCamera', 'key': 'LocalLevelFrame2StarCamera', 'description': 'Compute rotation ( StarCamera file ) from local level frame (ellipsoidal north, east, down) to TRF for positions given in   Compute rotation (  (first 3 data columns).', 'config_table': 'outputfileStarCamera filename rotation matrix from local level frame (ellipsoidal north, east, down) to TRF inputfileInstrument filename origin of local level frame constantOriginPerArc boolean use constant origin for all epochs of an arc (median position) R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates, 0: spherical coordinates', 'display_text': 'Compute rotation (<a class="groops-file" href="fileFormat_instrument.html">StarCamera file</a>) from local level frame (ellipsoidal north, east, down) to TRF for positions given in <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> (first 3 data columns).'},
'KalmanBuildNormals': { 'name': 'KalmanBuildNormals', 'key': 'KalmanBuildNormals', 'description': 'This program sets up normal equations based on   This program sets up normal equations based on   for short-term gravity field variations. It computes the normal equations based on the intervals   given in the   This program sets up normal equations based on  . It sets up the least squares adjustment  and subsequently computes the normal equations   for each interval. If  eliminateNonGravityParameters  is true, all non-gravity parameters are eliminated before the normals are written to   This program sets up normal equations based on  . For each time interval in  arcList  a single  normal equation file  is written. This program computes the input normals for  KalmanFilter  and  KalmanSmootherLeastSquares .', 'config_table': 'outputfileNormalEquation filename outputfile for normal equations observation observationType  inputfileArcList filename list to correspond points of time to arc numbers eliminateNonGravityParameters boolean eliminate additional parameters from normals, 0: all parameter are saved', 'display_text': 'This program sets up normal equations based on <a class="groops-class" href="observationType.html">observation</a> for short-term gravity field variations. It computes the normal equations based on the intervals $i \\in \\{1, ..., N\\}$ given in the <a class="groops-class" href="fileFormat_arcList.html">arcList</a>. It sets up the least squares adjustment \\[     \\begin{bmatrix}     \\mathbf{l}_1 \\\\     \\mathbf{l}_2 \\\\     \\vdots \\\\     \\mathbf{l}_N \\\\   \\end{bmatrix}   =   \\begin{bmatrix}     \\mathbf{A}_1  &  & & \\\\     & \\mathbf{A}_2  & &\\\\     &  & \\ddots & \\\\     & & & \\mathbf{A}_N \\\\   \\end{bmatrix}   \\begin{bmatrix}     \\mathbf{x}^{(1)} \\\\     \\mathbf{x}^{(2)} \\\\     \\vdots \\\\     \\mathbf{x}^{(N)} \\\\   \\end{bmatrix}   +   \\begin{bmatrix}     \\mathbf{e}_1 \\\\     \\mathbf{e}_2 \\\\     \\vdots \\\\     \\mathbf{e}_N \\\\   \\end{bmatrix}, \\]and subsequently computes the normal equations $\\mathbf{N}_i, \\mathbf{n}_i$ for each interval. If <strong class="groops-config-element">eliminateNonGravityParameters</strong> is true, all non-gravity parameters are eliminated before the normals are written to <a class="groops-class" href="fileFormat_normalEquation.html">outputfileNormalEquation</a>. For each time interval in <strong class="groops-config-element">arcList</strong> a single <a class="groops-file" href="fileFormat_normalEquation.html">normal equation file</a> is written.</p><p>This program computes the input normals for <a class="groops-program" href="KalmanFilter.html">KalmanFilter</a> and <a class="groops-program" href="KalmanSmootherLeastSquares.html">KalmanSmootherLeastSquares</a>.'},
'KalmanFilter': { 'name': 'KalmanFilter', 'key': 'KalmanFilter', 'description': 'The program computes time variable gravity fields using the Kalman filter approach of Kurtenbach, E., Eicker, A., Mayer-Grr, T., Holschneider, M., Hayn, M., Fuhrmann, M., and Kusche, J. (2012). Improved daily GRACE gravity field solutions using a Kalman smoother. Journal of Geodynamics, 5960, 3948.  https://doi.org/10.1016/j.jog.2012.02.006 . The updated state   is determined by solving the least squares adjustment  In normal equation form this can be written as  where   and   are the predicted state and its covariance matrix. The process dynamic   is represented as an  autoregressive model , and passed to the program through   The program computes time variable gravity fields using the Kalman filter approach of . The sequence of normal equations   are given as list of   The program computes time variable gravity fields using the Kalman filter approach of , which can be generated using   The program computes time variable gravity fields using the Kalman filter approach of . In the same way, the  matrix files  for  outputfileUpdatedState  and  inputfileUpdatedStateCovariance  can also be specified using   The program computes time variable gravity fields using the Kalman filter approach of . If no   The program computes time variable gravity fields using the Kalman filter approach of  is set, a zero vector with appropriate dimensions is used. The   The program computes time variable gravity fields using the Kalman filter approach of  however must be given. See also  KalmanBuildNormals ,  KalmanSmoother .', 'config_table': 'outputfileUpdatedState filename estimated state x+ (nx1-matrix) outputfileUpdatedStateCovarianceMatrix filename estimated state\' s covariance matrix Cov(x+) inputfileNormalEquations filename normal equations input file inputfileInitialState filename initial state x0 inputfileInitialStateCovarianceMatrix filename initial state\'s covariance matrix Cov(x0) inputfileAutoregressiveModel filename file name of autoregressive model', 'display_text': 'The program computes time variable gravity fields using the Kalman filter approach of</p><p>Kurtenbach, E., Eicker, A., Mayer-Grr, T., Holschneider, M., Hayn, M., Fuhrmann, M., and Kusche, J. (2012). Improved daily GRACE gravity field solutions using a Kalman smoother. Journal of Geodynamics, 5960, 3948. <a href="https://doi.org/10.1016/j.jog.2012.02.006" target="_blank">https://doi.org/10.1016/j.jog.2012.02.006</a>.</p><p>The updated state $\\mathbf{x}_t^+$ is determined by solving the least squares adjustment \\[ \\mathbf{l}_t = \\mathbf{A}_t \\mathbf{x}_t + \\mathbf{e}_t \\hspace{25pt} \\mathbf{e}_t \\sim \\mathcal{N}(0, \\mathbf{R}_t)\\\\ \\mathbf{B} \\mathbf{x}^+_{t-1} = \\mathbf{I} \\mathbf{x}_t + \\mathbf{v}_t\\hspace{25pt} \\mathbf{v} \\sim \\mathcal{N}(0,\\mathbf{Q} + \\mathbf{B} \\mathbf{P}^+_{t-1}\\mathbf{B}^T). \\]In normal equation form this can be written as \\[ \\hat{\\mathbf{x}}_t = \\mathbf{x}^+_t = (\\mathbf{N}_t + \\mathbf{P}^{-^{-1}}_t)^{-1}(\\mathbf{n}_t + \\mathbf{P}^{-^{-1}}_t \\mathbf{x}^-_t), \\]where $\\mathbf{x}_t^- = \\mathbf{B} \\mathbf{x}^+_{t-1}$ and $\\mathbf{P}_t^{-} = \\mathbf{Q} + \\mathbf{B} \\mathbf{P}^+_{t-1}\\mathbf{B}^T$ are the predicted state and its covariance matrix.</p><p>The process dynamic $\\mathbf{B}, \\mathbf{Q}$ is represented as an <a class="groops-ref" href="fundamentals.autoregressiveModel.html">autoregressive model</a>, and passed to the program through <a class="groops-class" href="fileFormat_matrix.html">inputfileAutoregressiveModel</a>. The sequence of normal equations $\\mathbf{N}_t, \\mathbf{n}_t$ are given as list of <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquations</a>, which can be generated using <a class="groops-class" href="loopType.html">loops</a>. In the same way, the <a class="groops-file" href="fileFormat_matrix.html">matrix files</a> for <strong class="groops-config-element">outputfileUpdatedState</strong> and <strong class="groops-config-element">inputfileUpdatedStateCovariance</strong> can also be specified using <a class="groops-class" href="loopType.html">loops</a>.</p><p>If no <a class="groops-class" href="fileFormat_matrix.html">inputfileInitialState</a> is set, a zero vector with appropriate dimensions is used. The <a class="groops-class" href="fileFormat_matrix.html">inputfileInitialStateCovarianceMatrix</a> however must be given.</p><p>See also <a class="groops-program" href="KalmanBuildNormals.html">KalmanBuildNormals</a>, <a class="groops-program" href="KalmanSmoother.html">KalmanSmoother</a>.'},
'KalmanSmoother': { 'name': 'KalmanSmoother', 'key': 'KalmanSmoother', 'description': 'Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by  KalmanFilter . This is the implementation of the approach presented in Kurtenbach, E., Eicker, A., Mayer-Grr, T., Holschneider, M., Hayn, M., Fuhrmann, M., and Kusche, J. (2012). Improved daily GRACE gravity field solutions using a Kalman smoother. Journal of Geodynamics, 5960, 3948.  https://doi.org/10.1016/j.jog.2012.02.006 . The result has zero phase and the squared magnitude response of   Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by   (see  autoregressiveModel  for details).   Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by   and   Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by   are the output of a  KalmanFilter  forward sweep. The matrix files for  Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by  ,   Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by   and   Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by   can also be specified using   Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by  . See also  KalmanBuildNormals ,  KalmanFilter  and  KalmanSmootherLeastSquares .', 'config_table': 'outputfileState filename estimated parameters (nx1-matrix) outputfileStateCovarianceMatrix filename estimated parameters\' covariance matrix inputfileUpdatedState filename  inputfileUpdatedStateCovarianceMatrix filename  inputfileAutoregressiveModel filename file name of autoregressive model', 'display_text': 'Apply the Rauch-Tung-Striebel smoother to a gravity field time series computed by <a class="groops-program" href="KalmanFilter.html">KalmanFilter</a>. This is the implementation of the approach presented in</p><p>Kurtenbach, E., Eicker, A., Mayer-Grr, T., Holschneider, M., Hayn, M., Fuhrmann, M., and Kusche, J. (2012). Improved daily GRACE gravity field solutions using a Kalman smoother. Journal of Geodynamics, 5960, 3948. <a href="https://doi.org/10.1016/j.jog.2012.02.006" target="_blank">https://doi.org/10.1016/j.jog.2012.02.006</a>.</p><p>The result has zero phase and the squared magnitude response of <a class="groops-class" href="fileFormat_matrix.html">inputfileAutoregressiveModel</a> (see <a class="groops-ref" href="fundamentals.autoregressiveModel.html">autoregressiveModel</a> for details). <a class="groops-class" href="fileFormat_matrix.html">inputfileUpdatedState</a> and <a class="groops-class" href="fileFormat_matrix.html">inputfileUpdatedStateCovariance</a> are the output of a <a class="groops-program" href="KalmanFilter.html">KalmanFilter</a> forward sweep. The matrix files for<a class="groops-class" href="fileFormat_matrix.html">outputfileUpdatedState</a>, <a class="groops-class" href="fileFormat_matrix.html">inputfileUpdatedState</a> and <a class="groops-class" href="fileFormat_matrix.html">inputfileUpdatedStateCovariance</a> can also be specified using <a class="groops-class" href="loopType.html">loops</a>.</p><p>See also <a class="groops-program" href="KalmanBuildNormals.html">KalmanBuildNormals</a>, <a class="groops-program" href="KalmanFilter.html">KalmanFilter</a> and <a class="groops-program" href="KalmanSmootherLeastSquares.html">KalmanSmootherLeastSquares</a>.'},
'KalmanSmootherLeastSquares': { 'name': 'KalmanSmootherLeastSquares', 'key': 'KalmanSmootherLeastSquares', 'description': 'This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a   This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a   which represent a stationary random process (see the  autoregressive model description ) for details. The output files for the estimated gravity field (  This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a  ), the corresponding standard deviations (  This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a  ) and the full covariance matrix (  This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a  ) can be specified using   This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a  . Similarly, the   This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a   can also be specified using   This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a  . See also  KalmanBuildNormals ,  KalmanFilter  and KalmanSmoother', 'config_table': 'outputfileSolution filename file name of solution vector (use time tags) outputfileSigmax filename file name of sigma vector (use time tags) outputfileCovariance filename file name of full covariance matrix (use time tags) inputfileNormalEquations filename input normal equations (loopTime will be expanded) autoregressiveModelSequence autoregressiveModelSequenceType file containing AR model for spatiotemporal constraint', 'display_text': 'This program estimates temporal gravity field variations with a constraint least squares adjustment. Prior information is introduced by means of a <a class="groops-class" href="autoregressiveModelSequenceType.html">autoregressiveModelSequence</a> which represent a stationary random process (see the <a class="groops-ref" href="fundamentals.autoregressiveModel.html">autoregressive model description</a>) for details.</p><p>The output files for the estimated gravity field (<a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a>), the corresponding standard deviations (<a class="groops-class" href="fileFormat_matrix.html">outputfileSigmax</a>) and the full covariance matrix (<a class="groops-class" href="fileFormat_matrix.html">outputfileCovariance</a>) can be specified using <a class="groops-class" href="loopType.html">loops</a>. Similarly, the <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquations</a> can also be specified using <a class="groops-class" href="loopType.html">loops</a>.</p><p>See also <a class="groops-program" href="KalmanBuildNormals.html">KalmanBuildNormals</a>, <a class="groops-program" href="KalmanFilter.html">KalmanFilter</a> and<a class="groops-program" href="KalmanSmoother.html">KalmanSmoother</a>'},
'DigitalFilter2FrequencyResponse': { 'name': 'DigitalFilter2FrequencyResponse', 'key': 'DigitalFilter2FrequencyResponse', 'description': 'Compute amplitude-, phase-, group delay and frequency response of a   Compute amplitude-, phase-, group delay and frequency response of a   cascade. The   Compute amplitude-, phase-, group delay and frequency response of a   is a matrix with following columns: freq  , ampl, phase  , group delay  , real, imag. When  unwrapPhase  is set to true,   jumps of the phase response are removed before writing the output to file. The response of the filter cascade is given by the product of each individual frequency response:  Amplitude and phase response are computed from the frequency response via  The group delay is computed by numerically differentiating the phase response  The frequency vector for a  length    and a  sampling    is given by   See also  DigitalFilter2ImpulseResponse .', 'config_table': 'outputfileResponse filename columns: freq [Hz], ampl, phase [rad], group delay [-], real, imag digitalFilter digitalFilterType  length uint length of the data series in time domain sampling double sampling to determine frequency [seconds] skipZeroFrequency boolean omit zero frequency when writing to file unwrapPhase boolean unwrap phase response', 'display_text': 'Compute amplitude-, phase-, group delay and frequency response of a <a class="groops-class" href="digitalFilterType.html">digitalFilter</a> cascade. The <a class="groops-class" href="fileFormat_matrix.html">outputfileResponse</a> is a matrix with following columns: freq $[Hz]$, ampl, phase $[rad]$, group delay $[-]$, real, imag.</p><p>When <strong class="groops-config-element">unwrapPhase</strong> is set to true, $2\\pi$ jumps of the phase response are removed before writing the output to file.</p><p>The response of the filter cascade is given by the product of each individual frequency response: \\[   H(f) = \\prod_f H_j(f). \\]Amplitude and phase response are computed from the frequency response via \\[   A(f) = |H(f)| \\hspace{5pt}\\text{and}\\hspace{5pt} \\Phi(f) = \\arctan \\frac{\\mathcal{I}(H(f))}{\\mathcal{R}(H(f))}. \\]The group delay is computed by numerically differentiating the phase response \\[   \\tau_g(f_k) = \\frac{1}{2} \\left[\\frac{\\Phi(f_k) - \\Phi(f_{k-1})}{2\\pi(f_k-f_{k-1})} + \\frac{\\Phi(f_{k+1}) - \\Phi(f_{k})}{2\\pi(f_{k+1}-f_{k})}\\right] \\approx \\frac{d\\Phi}{df}\\frac{df}{d\\omega}. \\]The frequency vector for a <strong class="groops-config-element">length</strong> $N$ and a <strong class="groops-config-element">sampling</strong> $\\Delta t$ is given by \\[   f_k = \\frac{k}{N \\Delta t}, \\hspace{15pt} k \\in \\{0, \\dots, \\left\\lfloor\\frac{N+2}{2}\\right\\rfloor-1\\}. \\] See also <a class="groops-program" href="DigitalFilter2ImpulseResponse.html">DigitalFilter2ImpulseResponse</a>.'},
'DigitalFilter2ImpulseResponse': { 'name': 'DigitalFilter2ImpulseResponse', 'key': 'DigitalFilter2ImpulseResponse', 'description': 'Impulse response of a   Impulse response of a   cascade. The impulse response is computed by filtering a sequence with  length  samples and a unit impulse at index  pulseLag . The   Impulse response of a   is a matrix with the time stamp (zero at  pulseLag ) in the first column and the impulse response   in the second column. See also  DigitalFilter2FrequencyResponse .', 'config_table': 'outputfileResponse filename columns: time [seconds], response digitalFilter digitalFilterType  length uint length of the impulse response pulseLag uint start of the pulse in the data series sampling double [seconds]', 'display_text': 'Impulse response of a <a class="groops-class" href="digitalFilterType.html">digitalFilter</a> cascade. The impulse response is computed by filtering a sequence with <strong class="groops-config-element">length</strong> samples and a unit impulse at index <strong class="groops-config-element">pulseLag</strong>.</p><p>The <a class="groops-class" href="fileFormat_matrix.html">outputfileResponse</a> is a matrix with the time stamp (zero at <strong class="groops-config-element">pulseLag</strong>) in the first column and the impulse response $h_k$ in the second column.</p><p>See also <a class="groops-program" href="DigitalFilter2FrequencyResponse.html">DigitalFilter2FrequencyResponse</a>.'},
'EarthOrientationParameterTimeSeries': { 'name': 'EarthOrientationParameterTimeSeries', 'key': 'EarthOrientationParameterTimeSeries', 'description': 'Computes a   Computes a   (GPS time) of Earth Orientation Parameter (EOP). The  instrument file  (MISCVALUES) contains the elements at each epoch in the following order:     [rad]   [rad]   [rad]   [seconds]  length of day (LOD) [seconds]   [rad]   [rad]   [rad]   The values are in situ values with all corrections and models applied. The time series can be used to precompute Earth rotation with a low temporal resolution (e.g. 10 min) and reuse the file in   Computes a   to interpolate the data to the needed epochs (e.g. to rotate orbit data). As some Earth rotation models are quite slow this can accelerate the computation.', 'config_table': 'outputfileEOP filename each row: mjd(GPS), xp, yp, sp, dUT1, LOD, X, Y, S earthRotation earthRotationType  timeSeries timeSeriesType', 'display_text': 'Computes a <a class="groops-class" href="timeSeriesType.html">timeSeries</a> (GPS time) of Earth Orientation Parameter (EOP). The <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES) contains the elements at each epoch in the following order: <ul>  <li>$x_p$ [rad] </li><li> $y_p$ [rad] </li><li> $s_p$ [rad] </li><li> $UT1-UTC$ [seconds] </li><li> length of day (LOD) [seconds] </li><li> $X$ [rad] </li><li> $Y$ [rad] </li><li> $S$ [rad] </li></ul>  The values are in situ values with all corrections and models applied. The time series can be used to precompute Earth rotation with a low temporal resolution (e.g. 10 min) and reuse the file in <a class="groops-class" href="earthRotationType.html#file">earthRotation:file</a> to interpolate the data to the needed epochs (e.g. to rotate orbit data). As some Earth rotation models are quite slow this can accelerate the computation.'},
'EarthRotaryVectorTimeSeries': { 'name': 'EarthRotaryVectorTimeSeries', 'key': 'EarthRotaryVectorTimeSeries', 'description': 'Computes a   Computes a   of Earth\'s rotary axis and its temporal derivative at   Computes a   (GPS time). The  instrument file  (MISCVALUES) contains the elements at each epoch in the following order:              .', 'config_table': 'outputfileTimeSeries filename wx, wy, wz [rad], dwx, dwy, dwz [rad/s^2] earthRotation earthRotationType  timeSeries timeSeriesType  inTRF boolean terrestrial reference frame, otherwise celestial', 'display_text': 'Computes a <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> of Earth\'s rotary axis and its temporal derivative at <a class="groops-class" href="timeSeriesType.html">timeSeries</a> (GPS time). The <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES) contains the elements at each epoch in the following order: <ul>  <li>$\\omega_x [rad/s]$ </li><li> $\\omega_y [rad/s]$ </li><li> $\\omega_z [rad/s]$ </li><li> $\\dot{\\omega}_x [rad/s^2]$ </li><li> $\\dot{\\omega}_y [rad/s^2]$ </li><li> $\\dot{\\omega}_z [rad/s^2]$. </li></ul>'},
'EclipseFactor2GriddedData': { 'name': 'EclipseFactor2GriddedData', 'key': 'EclipseFactor2GriddedData', 'description': 'This program converts the output of a   This program converts the output of a   model on a given   This program converts the output of a  . The time for the evaluation can be specified in  time . The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening .', 'config_table': 'outputfileGriddedData filename eclipse factor grid gridType  eclipse eclipseType  ephemerides ephemeridesType  earthRotation earthRotationType  time time  R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program converts the output of a <a class="groops-class" href="eclipseType.html">eclipse</a> model on a given <a class="groops-class" href="gridType.html">grid</a>. The time for the evaluation can be specified in <strong class="groops-config-element">time</strong>. The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>.'},
'FilterMatrixWindowedPotentialCoefficients': { 'name': 'FilterMatrixWindowedPotentialCoefficients', 'key': 'FilterMatrixWindowedPotentialCoefficients', 'description': 'Create a spherical harmonic window matrix. The window matrix   is generated in space domain through spherical harmonic synthesis and analysis matrices. The resulting linear operator can be written as  Here,   is a diagonal matrix with the   Create a spherical harmonic window matrix. The window matrix   coefficients on the main diagonal,   is the spherical harmonic synthesis matrix,   is defined by the values in  inputfileGriddedData  and the expression  value ,   is the spherical harmonic analysis matrix. The resulting window matrix is written to a  matrix  file. The spherical harmonic degree range, and coefficient numbering are defined by  minDegree ,  maxDegree , and   Create a spherical harmonic window matrix. The window matrix  . Note that a proper window function   should contain values in the range [0, 1]. The window function   can feature a smooth transition between 0 and 1 to avoid ringing effects.', 'config_table': 'outputfileWindowMatrix filename  inputfileGriddedData filename gridded data which defines the window function in space domain value expression expression to compute the window function (input columns are named data0, data1, ...) kernel kernelType kernel for windowing minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme for solution vector', 'display_text': 'Create a spherical harmonic window matrix. The window matrix $\\mathbf{W}$ is generated in space domain through spherical harmonic synthesis and analysis matrices. The resulting linear operator can be written as \\[ \\mathbf{W} = \\mathbf{K} \\mathbf{A} \\mathbf{\\Omega} \\mathbf{S} \\mathbf{K}^{-1}. \\]Here, $\\mathbf{K}$ is a diagonal matrix with the <a class="groops-class" href="kernelType.html">kernel</a> coefficients on the main diagonal, $\\mathbf{S}$ is the spherical harmonic synthesis matrix, $\\mathbf{\\Omega}$ is defined by the values in <a class="groops-file" href="fileFormat_griddedData.html">inputfileGriddedData</a> and the expression <strong class="groops-config-element">value</strong>, $\\mathbf{A}$ is the spherical harmonic analysis matrix. The resulting window matrix is written to a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> file.</p><p>The spherical harmonic degree range, and coefficient numbering are defined by <strong class="groops-config-element">minDegree</strong>, <strong class="groops-config-element">maxDegree</strong>, and <a class="groops-class" href="sphericalHarmonicsNumberingType.html">numbering</a>.</p><p>Note that a proper window function $\\mathbf{\\Omega}$ should contain values in the range [0, 1]. The window function $\\mathbf{\\Omega}$ can feature a smooth transition between 0 and 1 to avoid ringing effects.'},
'FunctionsCalculate': { 'name': 'FunctionsCalculate', 'key': 'FunctionsCalculate', 'description': 'This program manipulates  matrix files  with data in columns. If several  inputfile s are given the data columns are copied side by side. All  inputfile s must contain the same number of rows. The columns are enumerated by  data0 ,  data1 ,  . The content of   This program manipulates   is controlled by  outColumn . The algorithm to compute the output is as follows: The expressions in  outColumn  are evaluated once for each row of the input. The variables  data0 ,  data1 ,  are replaced by the according values from the input columns before. Additional variables are available, e.g.  index ,  data0rms , see  dataVariables . If no  outColumn  are specified all input columns are used instead directly. For a simplified handling  constant s can be defined by  name=value , e.g.  annual=365.25 . It is also possible to estimate  parameter s in a least squares adjustment. The  leastSquares  serves as template for observation equations for every row. The expression  leastSquares  is evaluated for each row in the  inputfile . The variables  data0 ,  data1 ,  are replaced by the according values from the input columns before. In the next step the parameters are estimated in order to minimize the expressions in  leastSquares  in the sense of least squares. Afterwards complete rows are removed if one of the  removalCriteria  expressions for this row evaluates true (not zero). An extra  statistics  file can be generated with one row of data. For the computation of the  outColumn  values all  dataVariables  are available (e.g.  data3mean ,  data4std ) inclusively the  constant s and estimated  parameter s but without the  data0 ,  data1 ,  itself. The variables and the numbering of the columns refers to the   This program manipulates  . First example: To calculate the mean of two values at each row set  outColumn  to  0.5*(data1+data0) . Second example: An input file contain a column with times and a column with values. To remove a trend from the values define the  parameter s  trend  and  bias . The observation equation in  leastSquares  is  data1 - (trend*data0+bias) . For output you can define the following columns for example:    outColumn = data0 : points in time.  outColumn = data1 : the values itself.  outColumn = trend*data0+bias : the linear fit.  outColumn = data1-trend*data0-bias : the residuals.   The extra statistics file could contain in this case:    outColumn = data0max-data0min : time span.  outColumn = bias : estimated parameter.  outColumn = trend : estimated parameter.  outColumn = data3rms : root mean square of the residuals.  See also  InstrumentArcCalculate ,  GriddedDataCalculate ,  MatrixCalculate .', 'config_table': 'outputfile filename  inputfile filename  constant expression define a constant by name=value parameter expression define a parameter by name[=value] leastSquares expression try to minimize the expression by adjustment of the parameters removalCriteria expression row is removed if one criterion evaluates true. outColumn expression expression to compute output columns (input columns are named data0, data1, ...) statistics sequence  outputfile filename matrix with one row, columns are user defined outColumn expression expression to compute statistics columns, data* are the outputColumns', 'display_text': 'This program manipulates <a class="groops-file" href="fileFormat_matrix.html">matrix files</a> with data in columns. If several <strong class="groops-config-element">inputfile</strong>s are given the data columns are copied side by side. All <strong class="groops-config-element">inputfile</strong>s must contain the same number of rows. The columns are enumerated by <code>data0</code>, <code>data1</code>, .</p><p>The content of <a class="groops-class" href="fileFormat_matrix.html">outputfile</a> is controlled by <strong class="groops-config-element">outColumn</strong>. The algorithm to compute the output is as follows: The expressions in <strong class="groops-config-element">outColumn</strong> are evaluated once for each row of the input. The variables <code>data0</code>, <code>data1</code>, are replaced by the according values from the input columns before. Additional variables are available, e.g. <code>index</code>, <code>data0rms</code>, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>. If no <strong class="groops-config-element">outColumn</strong> are specified all input columns are used instead directly.</p><p>For a simplified handling <strong class="groops-config-element">constant</strong>s can be defined by <code>name=value</code>, e.g. <code>annual=365.25</code>. It is also possible to estimate <strong class="groops-config-element">parameter</strong>s in a least squares adjustment. The <strong class="groops-config-element">leastSquares</strong> serves as template for observation equations for every row. The expression <strong class="groops-config-element">leastSquares</strong> is evaluated for each row in the <strong class="groops-config-element">inputfile</strong>. The variables <code>data0</code>, <code>data1</code>, are replaced by the according values from the input columns before. In the next step the parameters are estimated in order to minimize the expressions in <strong class="groops-config-element">leastSquares</strong> in the sense of least squares.</p><p>Afterwards complete rows are removed if one of the <strong class="groops-config-element">removalCriteria</strong> expressions for this row evaluates true (not zero).</p><p>An extra <strong class="groops-config-element">statistics</strong> file can be generated with one row of data. For the computation of the <strong class="groops-config-element">outColumn</strong> values all <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available (e.g. <code>data3mean</code>, <code>data4std</code>) inclusively the <strong class="groops-config-element">constant</strong>s and estimated <strong class="groops-config-element">parameter</strong>s but without the <code>data0</code>, <code>data1</code>, itself. The variables and the numbering of the columns refers to the <a class="groops-class" href="fileFormat_matrix.html">outputfile</a>.</p><p>First example: To calculate the mean of two values at each row set <strong class="groops-config-element">outColumn</strong> to <code>0.5*(data1+data0)</code>.</p><p>Second example: An input file contain a column with times and a column with values. To remove a trend from the values define the <strong class="groops-config-element">parameter</strong>s <code>trend</code> and <code>bias</code>. The observation equation in <strong class="groops-config-element">leastSquares</strong> is <code>data1 - (trend*data0+bias)</code>. For output you can define the following columns for example: <ul>  <li><strong class="groops-config-element">outColumn</strong>=<code>data0</code>: points in time. </li><li> <strong class="groops-config-element">outColumn</strong>=<code>data1</code>: the values itself. </li><li> <strong class="groops-config-element">outColumn</strong>=<code>trend*data0+bias</code>: the linear fit. </li><li> <strong class="groops-config-element">outColumn</strong>=<code>data1-trend*data0-bias</code>: the residuals. </li></ul>  The extra statistics file could contain in this case: <ul>  <li><strong class="groops-config-element">outColumn</strong>=<code>data0max-data0min</code>: time span. </li><li> <strong class="groops-config-element">outColumn</strong>=<code>bias</code>: estimated parameter. </li><li> <strong class="groops-config-element">outColumn</strong>=<code>trend</code>: estimated parameter. </li><li> <strong class="groops-config-element">outColumn</strong>=<code>data3rms</code>: root mean square of the residuals. </li></ul> </p><p>See also <a class="groops-program" href="InstrumentArcCalculate.html">InstrumentArcCalculate</a>, <a class="groops-program" href="GriddedDataCalculate.html">GriddedDataCalculate</a>, <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a>.'},
'Grs2PotentialCoefficients': { 'name': 'Grs2PotentialCoefficients', 'key': 'Grs2PotentialCoefficients', 'description': 'This program creates potential coefficients from the defining constants of a Geodetic Reference System (GRS). The potential coeffiencts excludes the centrifugal part. The form of the reference ellipsoid is either determined by the dynamical form factor  J2 , or the geometric  inverseFlattening . One of those form parameters must be specified. The default values create the GRS80.', 'config_table': 'outputfilePotentialCoefficients filename  maxDegree uint  GM double Geocentric gravitational constant R double reference radius omega double Angular velocity of rotation J2 double Dynamical form factor inverseFlattening double Geometric inverse flattening of reference ellipsoid (0: sphere, ignored when J2 is set)', 'display_text': 'This program creates potential coefficients from the defining constants of a Geodetic Reference System (GRS). The potential coeffiencts excludes the centrifugal part. The form of the reference ellipsoid is either determined by the dynamical form factor <strong class="groops-config-element">J2</strong>, or the geometric <strong class="groops-config-element">inverseFlattening</strong>. One of those form parameters must be specified.</p><p>The default values create the GRS80.'},
'Kaula2SigmaPotentialCoefficients': { 'name': 'Kaula2SigmaPotentialCoefficients', 'key': 'Kaula2SigmaPotentialCoefficients', 'description': 'Create signal standard deviations of potential coefficients according Kaula\'s rule of thumb  with the degree  , the  factor   , and the  power   . The standard deviations are written as formal errors of    Create signal standard deviations of potential coefficients according Kaula\'s rule of thumb  .', 'config_table': 'outputfilePotentialCoefficients filename  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius power double sigma = factor/degree^power factor double sigma = factor/degree^power', 'display_text': 'Create signal standard deviations of potential coefficients according Kaula\'s rule of thumb \\[   \\sigma_n = \\frac{f}{n^p}, \\]with the degree $n$, the <strong class="groops-config-element">factor</strong> $f$, and the <strong class="groops-config-element">power</strong> $p$.</p><p>The standard deviations are written as formal errors of  <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a>.'},
'Kernel2Coefficients': { 'name': 'Kernel2Coefficients', 'key': 'Kernel2Coefficients', 'description': 'This program computes and returns the coefficients and inverse coefficients of a   This program computes and returns the coefficients and inverse coefficients of a   from from  minDegree  to  maxDegree  at a given  height . The main purpose is for visualization with  PlotGraph .', 'config_table': 'outputfileMatrix filename matrix with columns degree, coefficients and inverse coefficients kernel kernelType  minDegree uint minimum degree of returned coefficients maxDegre uint compute coefficients up to maxDegree height double evaluate kernel at R+height [m] R double reference radius', 'display_text': 'This program computes and returns the coefficients and inverse coefficients of a <a class="groops-class" href="kernelType.html">kernel</a> from from <strong class="groops-config-element">minDegree</strong> to <strong class="groops-config-element">maxDegree</strong> at a given <strong class="groops-config-element">height</strong>.</p><p>The main purpose is for visualization with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.'},
'Kernel2SigmaPotentialCoefficients': { 'name': 'Kernel2SigmaPotentialCoefficients', 'key': 'Kernel2SigmaPotentialCoefficients', 'description': 'Create variances of spherical harmonics by convolution a kernel with white noise, e.g. to display filter coefficients of a Gaussian filter. The coefficients are written as formal errors of   Create variances of spherical harmonics by convolution a kernel with white noise, e.g. to display filter coefficients of a Gaussian filter. The coefficients are written as formal errors of  .', 'config_table': 'outputfilePotentialCoefficients filename  kernel kernelType  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius factor double', 'display_text': 'Create variances of spherical harmonics by convolution a kernel with white noise, e.g. to display filter coefficients of a Gaussian filter. The coefficients are written as formal errors of <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a>.'},
'KernelEvaluate': { 'name': 'KernelEvaluate', 'key': 'KernelEvaluate', 'description': 'Compute   Compute   values for distant angles. The main purpose is for visualization with  PlotGraph .', 'config_table': 'outputfileMatrix filename matrix with first column the angle [degree], second the kernel value kernel kernelType  minAngle angle [degree] maxAngle angle [degree] sampling angle [degree] height double evaluate at R+height [m] R double reference radius', 'display_text': 'Compute <a class="groops-class" href="kernelType.html">kernel</a> values for distant angles. The main purpose is for visualization with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.'},
'MagneticField2GriddedData': { 'name': 'MagneticField2GriddedData', 'key': 'MagneticField2GriddedData', 'description': 'Computes x, y, z of the magentic field vector.', 'config_table': 'outputfileGriddedData filename x, y, z [Tesla = kg/A/s**2] magnetosphere magnetosphereType  grid gridType  time time  localReferenceFrame boolean local left handed reference frame (north, east, up) R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'Computes x, y, z of the magentic field vector.'},
'MatrixCalculate': { 'name': 'MatrixCalculate', 'key': 'MatrixCalculate', 'description': 'This program creates a  matrix  from multiple matrices. All   This program creates a   are summed up. The size of the resulting matrix is exandeded to fit all matrices. The class   This program creates a   allows complex matrix operations before.', 'config_table': 'outputfileMatrix filename  matrix matrixGeneratorType', 'display_text': 'This program creates a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> from multiple matrices. All <a class="groops-class" href="matrixGeneratorType.html">matrices</a> are summed up. The size of the resulting matrix is exandeded to fit all matrices. The class <a class="groops-class" href="matrixGeneratorType.html">matrixGenerator</a> allows complex matrix operations before.'},
'ObservationEquations2Files': { 'name': 'ObservationEquations2Files', 'key': 'ObservationEquations2Files', 'description': 'This program computes the linearized and decorrelated equation system for each arc  :  using class   This program computes the linearized and decorrelated equation system for each arc   and writes  ,   and   as  matrix  files.', 'config_table': 'outputfileObservationVector filename one file for each arc outputfileDesignMatrix filename one file for each arc, without arc related parameters outputfileDesignMatrixArc filename one file for each arc, arc related parameters variableArc string variable with arc number outputfileParameterNames filename without arc related parameters observation observationType', 'display_text': 'This program computes the linearized and decorrelated equation system for each arc $i$: \\[ \\M l_i  = \\M A_i \\M x + \\M B_i \\M y_i + \\M e_i \\]using class <a class="groops-class" href="observationType.html">observation</a> and writes $\\M A_i$, $\\M B_i$ and $\\M l_i$ as <a class="groops-file" href="fileFormat_matrix.html">matrix</a> files.'},
'PlatformCreate': { 'name': 'PlatformCreate', 'key': 'PlatformCreate', 'description': 'Create a  Platform file  from scratch by defining attributes such as  markerName ,  markerNumber ,  comment ,  approxPosition ,  equipment . See also  GnssAntex2AntennaDefinition  and  GnssStationLog2Platform .', 'config_table': 'outputfilePlatform filename  markerName string  markerNumber string  comment string  approxPositionX double [m] in TRF approxPositionY double [m] in TRF approxPositionZ double [m] in TRF equipment choice  gnssAntenna sequence  name string  serial string  radome string  comment string  timeStart time  timeEnd time  positionX double [m] ARP in north, east, up or vehicle system positionY double [m] ARP in north, east, up or vehicle system positionZ double [m] ARP in north, east, up or vehicle system rotationX angle [degree] from local/vehicle to left-handed antenna system rotationY angle [degree] from local/vehicle to left-handed antenna system rotationZ angle [degree] from local/vehicle to left-handed antenna system flipX boolean flip x-axis (after rotation) flipY boolean flip y-axis (after rotation) flipZ boolean flip z-axis (after rotation) gnssReceiver sequence  name string  serial string  version string  comment string  timeStart time  timeEnd time  other sequence  name string  serial string  comment string  timeStart time  timeEnd time  positionX double [m] in north, east, up or vehicle system positionY double [m] in north, east, up or vehicle system positionZ double [m] in north, east, up or vehicle system referencePoint sequence e.g. center of mass in satellite frame comment string  xStart double [m] in north, east, up or vehicle system yStart double linear motion between start and end zStart double  xEnd double [m] in north, east, up or vehicle system yEnd double linear motion between start and end zEnd double  timeStart time  timeEnd time', 'display_text': 'Create a <a class="groops-file" href="fileFormat_platform.html">Platform file</a> from scratch by defining attributes such as <strong class="groops-config-element">markerName</strong>, <strong class="groops-config-element">markerNumber</strong>, <strong class="groops-config-element">comment</strong>, <strong class="groops-config-element">approxPosition</strong>, <strong class="groops-config-element">equipment</strong>.</p><p>See also <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a> and <a class="groops-program" href="GnssStationLog2Platform.html">GnssStationLog2Platform</a>.</p><p>'},
'PotentialCoefficients2BlockMeanTimeSplines': { 'name': 'PotentialCoefficients2BlockMeanTimeSplines', 'key': 'PotentialCoefficients2BlockMeanTimeSplines', 'description': 'This program is a simplified version of  Gravityfield2TimeSplines . It reads a series of potential coefficient files (  This program is a simplified version of  ) and creates a time splines file with spline degree 0 (temporal block means) or degree 1 (linear splines). The time intervals in which the potential coefficients are valid are defined between adjacent points in time given by  splineTimeSeries . Therefore one more point in time is needed than the number of potential coefficient files for degree 0. The coefficients can be filtered with   This program is a simplified version of  . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . This program is useful e.g. to combine monthly GRACE solutions to one file.', 'config_table': 'outputfileTimeSplines filename  outputfileTimeSplinesCovariance filename only the variances are saved inputfilePotentialCoefficients filename  filter sphericalHarmonicsFilterType  minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius removeMean boolean remove the temporal mean of the series before estimating the splines interpolate boolean interpolate missing files splineTimeSeries timeSeriesType input files must be between points in time splineDegree uint degree of splines', 'display_text': 'This program is a simplified version of <a class="groops-program" href="Gravityfield2TimeSplines.html">Gravityfield2TimeSplines</a>. It reads a series of potential coefficient files (<a class="groops-class" href="fileFormat_potentialCoefficients.html">inputfilePotentialCoefficients</a>) and creates a time splines file with spline degree 0 (temporal block means) or degree 1 (linear splines). The time intervals in which the potential coefficients are valid are defined between adjacent points in time given by <strong class="groops-config-element">splineTimeSeries</strong>. Therefore one more point in time is needed than the number of potential coefficient files for degree 0.</p><p>The coefficients can be filtered with <a class="groops-class" href="sphericalHarmonicsFilterType.html">filter</a>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>This program is useful e.g. to combine monthly GRACE solutions to one file.'},
'PotentialCoefficients2DegreeAmplitudes': { 'name': 'PotentialCoefficients2DegreeAmplitudes', 'key': 'PotentialCoefficients2DegreeAmplitudes', 'description': 'This program computes degree amplitudes from  potentialCoefficients files  and saves them to a  matrix  file. The coefficients can be filtered with   This program computes degree amplitudes from   and converted to different functionals with   This program computes degree amplitudes from  . The gravity field can be evaluated at different altitudes by specifying  evaluationRadius . Polar regions can be excluded by setting  polarGap . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The coefficients are related to the reference radius  R  and the Earth gravitational constant  GM . The   This program computes degree amplitudes from   contains in the first 3 columns the degree, the degree amplitude, and the formal errors. For each additional   This program computes degree amplitudes from   three columns are appended: the degree amplitude, the formal errors, and the difference to the first file. For example the data columns for 4   This program computes degree amplitudes from   are    degree= data0   PotentialCoefficients0: signal= data1 , error= data2 ,  PotentialCoefficients1: signal= data3 , error= data4 ,  difference= data5 ,  PotentialCoefficients2: signal= data6 , error= data7 ,  difference= data8 ,  PotentialCoefficients3: signal= data9 , error= data10 , difference= data11 .  See also  Gravityfield2DegreeAmplitudes .', 'config_table': 'outputfileMatrix filename matrix with degree, signal amplitude, formal error, differences inputfilePotentialCoefficients filename  kernel kernelType  filter sphericalHarmonicsFilterType filter the coefficients type choice type of variances rms  degree amplitudes (square root of degree variances) accumulation  cumulate variances over degrees evaluationRadius double evaluate the gravity field at this radius (default: evaluate at surface polarGap angle exclude polar regions (aperture angle in degrees) minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius', 'display_text': 'This program computes degree amplitudes from <a class="groops-file" href="fileFormat_potentialCoefficients.html">potentialCoefficients files</a> and saves them to a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> file.</p><p>The coefficients can be filtered with <a class="groops-class" href="sphericalHarmonicsFilterType.html">filter</a> and converted to different functionals with <a class="groops-class" href="kernelType.html">kernel</a>. The gravity field can be evaluated at different altitudes by specifying <strong class="groops-config-element">evaluationRadius</strong>. Polar regions can be excluded by setting <strong class="groops-config-element">polarGap</strong>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The coefficients are related to the reference radius <strong class="groops-config-element">R</strong> and the Earth gravitational constant <strong class="groops-config-element">GM</strong>.</p><p>The <a class="groops-class" href="fileFormat_matrix.html">outputfileMatrix</a> contains in the first 3 columns the degree, the degree amplitude, and the formal errors. For each additional <a class="groops-class" href="fileFormat_potentialCoefficients.html">inputfilePotentialCoefficients</a> three columns are appended: the degree amplitude, the formal errors, and the difference to the first file.</p><p>For example the data columns for 4 <a class="groops-class" href="fileFormat_potentialCoefficients.html">inputfilePotentialCoefficients</a> are <ul>  <li>degree=<code>data0</code> </li><li> PotentialCoefficients0: signal=<code>data1</code>, error=<code>data2</code>, </li><li> PotentialCoefficients1: signal=<code>data3</code>, error=<code>data4</code>,  difference=<code>data5</code>, </li><li> PotentialCoefficients2: signal=<code>data6</code>, error=<code>data7</code>,  difference=<code>data8</code>, </li><li> PotentialCoefficients3: signal=<code>data9</code>, error=<code>data10</code>, difference=<code>data11</code>. </li></ul> </p><p>See also <a class="groops-program" href="Gravityfield2DegreeAmplitudes.html">Gravityfield2DegreeAmplitudes</a>.'},
'RadialBasisSplines2KernelCoefficients': { 'name': 'RadialBasisSplines2KernelCoefficients', 'key': 'RadialBasisSplines2KernelCoefficients', 'description': 'This program calculates the coefficients   of a   This program calculates the coefficients   according to  from a given   This program calculates the coefficients  , with  R  and  GM  describing the reference radius and the geocentric constant, respectively. The   stand for the gravity field accuracies (from degree  minDegree  to  maxDegree ), if they are given. If no accuracies are provided, the   represent the square root of the degree variances of the gravity field. If  maxDegree  exceeds the maximum degree given by   This program calculates the coefficients  , the higher degrees are complemented by Kaula\'s rule The output of the coefficients is given in the file    This program calculates the coefficients  .', 'config_table': 'outputfileCoefficients filename  gravityfield gravityfieldType use sigmas, if not given use signal (cnm,snm), if not given use kaulas rule minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius kaulaPower double sigma = kaulaFactor/degree^kaulaPower kaulaFactor double sigma = kaulaFactor/degree^kaulaPower', 'display_text': 'This program calculates the coefficients $k_n$ of a <a class="groops-class" href="kernelType.html#coefficients">kernel:coefficients</a> according to \\[   k_n = \\frac{GM}{4\\pi R}\\frac{\\sigma_n}{\\sqrt{2n+1}}. \\]from a given <a class="groops-class" href="gravityfieldType.html">gravityfield</a>, with <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">GM</strong> describing the reference radius and the geocentric constant, respectively. The $\\sigma_n$ stand for the gravity field accuracies (from degree <strong class="groops-config-element">minDegree</strong> to <strong class="groops-config-element">maxDegree</strong>), if they are given. If no accuracies are provided, the $\\sigma_n$ represent the square root of the degree variances of the gravity field. If <strong class="groops-config-element">maxDegree</strong> exceeds the maximum degree given by <a class="groops-class" href="gravityfieldType.html">gravityfield</a>, the higher degrees are complemented by Kaula\'s rule The output of the coefficients is given in the file  <a class="groops-class" href="fileFormat_matrix.html">outputfileCoefficients</a>.'},
'SatelliteModelCreate': { 'name': 'SatelliteModelCreate', 'key': 'SatelliteModelCreate', 'description': 'This program creates a satellite macro model for the estimation of non-gravitational accelerations acting on a satellite. Mandatory input values are the  satelliteName ,  mass ,  coefficientDrag  and information about the satellite  surfaces . For low Earth orbiting satellites, like GRACE for instance, a good guess for the drag coefficient could be 2.3. Apart from that, it is latter on possible to estimate a more precise variable drag coefficient (e.g.   This program creates a satellite macro model for the estimation of non-gravitational accelerations acting on a satellite. Mandatory input values are the  ), which will override this initial guess. Concerning the satellite surfaces an external file must be imported which must contain information about each single  satellite plate in terms of plate  area , the associated plate normal and re-radiation properties (reflexion, diffusion and absorption) properties in the visible and IR part. Examplarily, a description of the macro model for GRACE can be found under:  https://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/docs/ProdSpecDoc_v4.6.pdf  Additionally, it is possible to add further information like antennaThrust, solar panel, temporal mass changes and massInstrument using the modules option.', 'config_table': 'outputfileSatelliteModel filename  satellite sequence  satelliteName string  mass double  coefficientDrag double  surfaces sequence  inputfile filename each line must contain one surface element type expression 0: plate, 1: sphere, 2: cylinder area expression [m^2] normalX expression  normalY expression  normalZ expression  reflexionVisible expression  diffusionVisible expression  absorptionVisible expression  reflexionInfrared expression  diffusionInfrared expression  absorptionInfrared expression  specificHeatCapacity expression 0: no thermal radiation, -1: direct reemission [Ws/K/m^2] module choice  antennaThrust sequence  thrustX double  thrustY double  thrustZ double  solarPanel sequence  rotationAxisX double  rotationAxisY double  rotationAxisZ double  normalX double Direction to sun normalY double Direction to sun normalZ double Direction to sun indexSurface uint index of solar panel surfaces massChange sequence  time time  mass double  massInstrument sequence  inputfileInstrument filename', 'display_text': 'This program creates a satellite macro model for the estimation of non-gravitational accelerations acting on a satellite. Mandatory input values are the <strong class="groops-config-element">satelliteName</strong>, <strong class="groops-config-element">mass</strong>, <strong class="groops-config-element">coefficientDrag</strong> and information about the satellite <strong class="groops-config-element">surfaces</strong>. For low Earth orbiting satellites, like GRACE for instance, a good guess for the drag coefficient could be 2.3. Apart from that, it is latter on possible to estimate a more precise variable drag coefficient (e.g. <a class="groops-class" href="miscAccelerationsType.html#atmosphericDrag">miscAccelerations:atmosphericDrag</a>), which will override this initial guess. Concerning the satellite surfaces an external file must be imported which must contain information about each single  satellite plate in terms of plate <strong class="groops-config-element">area</strong>, the associated plate normal and re-radiation properties (reflexion, diffusion and absorption) properties in the visible and IR part. Examplarily, a description of the macro model for GRACE can be found under: <a href="https://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/docs/ProdSpecDoc_v4.6.pdf" target="_blank">https://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/docs/ProdSpecDoc_v4.6.pdf</a> Additionally, it is possible to add further information like antennaThrust, solar panel, temporal mass changes and massInstrument using the modules option.'},
'TemporalRepresentation2TimeSeries': { 'name': 'TemporalRepresentation2TimeSeries', 'key': 'TemporalRepresentation2TimeSeries', 'description': 'This program computes the design matrix of temporal representation at a given time series. The output matrix contains the time steps in MJD in the first column, the other columns contain the design matrix. The intention of this program is to visualize the parametrization together with  PlotGraph .', 'config_table': 'outputfileMatrix filename Time (MJD) in first column, design matrix follows timeSeries timeSeriesType  temporal parametrizationTemporalType', 'display_text': 'This program computes the design matrix of temporal representation at a given time series. The output matrix contains the time steps in MJD in the first column, the other columns contain the design matrix. The intention of this program is to visualize the parametrization together with <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.'},
'ThermosphericState2GriddedData': { 'name': 'ThermosphericState2GriddedData', 'key': 'ThermosphericState2GriddedData', 'description': 'This program converts the output (neutral mass density,temperature) of an empirical thermosphere model (e.g. JB2008) on a given   This program converts the output (neutral mass density,temperature) of an empirical thermosphere model (e.g. JB2008) on a given  . Additionally, also the thermospheric winds estimated by using the horizontal wind model HWM 2014 can be assessed. The time for the evaluation can be specified in  time . The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening .', 'config_table': 'outputfileGriddedData filename density [kg/m**3], temperature [K], wind (x, y, z) [m/s**2] thermosphere thermosphereType  grid gridType  time time  localReferenceFrame boolean wind in local north, east, up, otherwise global terrestrial R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates', 'display_text': 'This program converts the output (neutral mass density,temperature) of an empirical thermosphere model (e.g. JB2008) on a given <a class="groops-class" href="gridType.html">grid</a>. Additionally, also the thermospheric winds estimated by using the horizontal wind model HWM 2014 can be assessed. The time for the evaluation can be specified in <strong class="groops-config-element">time</strong>. The values will be saved together with points expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>.'},
'TimeSeries2PotentialCoefficients': { 'name': 'TimeSeries2PotentialCoefficients', 'key': 'TimeSeries2PotentialCoefficients', 'description': 'Interpret the data columns of   Interpret the data columns of   as potential coefficients. The sequence of coefficients is given by   Interpret the data columns of   starting from data column  startDataFields . For each epoch a   Interpret the data columns of   is written where the  variableLoopTime  and  variableLoopIndex  are expanded for each point of the given time series to create the file name for this epoch, see  text parser . See also  Gravityfield2PotentialCoefficientsTimeSeries .', 'config_table': 'outputfilesPotentialCoefficients filename for each epoch variableLoopTime string variable with time of each epoch variableLoopIndex string variable with index of current epoch (starts with zero) variableLoopCount string variable with total number of epochs inputfileTimeSeries filename each epoch: multiple data for points (MISCVALUES) startDataFields uint first data column minDegree uint minimal degree maxDegree uint maximal degree GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme', 'display_text': 'Interpret the data columns of <a class="groops-class" href="fileFormat_instrument.html">inputfileTimeSeries</a> as potential coefficients. The sequence of coefficients is given by <a class="groops-class" href="sphericalHarmonicsNumberingType.html">numbering</a> starting from data column <strong class="groops-config-element">startDataFields</strong>.</p><p>For each epoch a <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilesPotentialCoefficients</a> is written where the <strong class="groops-config-element">variableLoopTime</strong> and <strong class="groops-config-element">variableLoopIndex</strong> are expanded for each point of the given time series to create the file name for this epoch, see <a class="groops-ref" href="general.parser.html#text">text parser</a>.</p><p>See also <a class="groops-program" href="Gravityfield2PotentialCoefficientsTimeSeries.html">Gravityfield2PotentialCoefficientsTimeSeries</a>.'},
'TimeSeriesCreate': { 'name': 'TimeSeriesCreate', 'key': 'TimeSeriesCreate', 'description': 'This program generates an  instrument file , containing a time series.', 'config_table': 'outputfileTimeSeries filename instrument file timeSeries timeSeriesType time series to be created data expression expression of output columns, extra \'epoch\' variable', 'display_text': 'This program generates an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>, containing a time series.'},
'Variational2OrbitAndStarCamera': { 'name': 'Variational2OrbitAndStarCamera', 'key': 'Variational2OrbitAndStarCamera', 'description': 'Extracts the reference   Extracts the reference  ,   Extracts the reference  , and   Extracts the reference   from   Extracts the reference  .', 'config_table': 'outputfileOrbit filename output orbit (instrument) file outputfileStarCamera filename output satellite attidude as star camera (instrument) file outputfileEarthRotation filename output Earth rotation as star camera (instrument) file inputfileVariational filename input variational file', 'display_text': 'Extracts the reference <a class="groops-class" href="fileFormat_instrument.html">outputfileOrbit</a>, <a class="groops-class" href="fileFormat_instrument.html">outputfileStarCamera</a>, and <a class="groops-class" href="fileFormat_instrument.html">outputfileEarthRotation</a> from <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a>.'},
'NormalsAccumulate': { 'name': 'NormalsAccumulate', 'key': 'NormalsAccumulate', 'description': 'This program accumulates normal equations and writes the total combined system to   This program accumulates normal equations and writes the total combined system to  . The   This program accumulates normal equations and writes the total combined system to  s must have all the same size and the same block structure. This program is the simplified and fast version of the more general program  NormalsBuild .', 'config_table': 'outputfileNormalEquation filename  inputfileNormalEquation filename', 'display_text': 'This program accumulates normal equations and writes the total combined system to <a class="groops-class" href="fileFormat_normalEquation.html">outputfileNormalequation</a>. The <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a>s must have all the same size and the same block structure. This program is the simplified and fast version of the more general program <a class="groops-program" href="NormalsBuild.html">NormalsBuild</a>.'},
'NormalsBuild': { 'name': 'NormalsBuild', 'key': 'NormalsBuild', 'description': 'This program accumulates   This program accumulates  s and writes the total combined system to   This program accumulates  . For a detailed description of the used algorithm see   This program accumulates  . Large normal equation systems can be divided into blocks with  normalsBlockSize . A simplifed and fast version of this program is  NormalsAccumulate . To solve the system of normal equations use  NormalsSolverVCE .', 'config_table': 'outputfileNormalEquation filename  normalEquation normalEquationType  normalsBlockSize uint block size for distributing the normal equations, 0: one block', 'display_text': 'This program accumulates <a class="groops-class" href="normalEquationType.html">normalEquation</a>s and writes the total combined system to <a class="groops-class" href="fileFormat_normalEquation.html">outputfileNormalequation</a>. For a detailed description of the used algorithm see <a class="groops-class" href="normalEquationType.html">normalEquation</a>. Large normal equation systems can be divided into blocks with <strong class="groops-config-element">normalsBlockSize</strong>.</p><p>A simplifed and fast version of this program is <a class="groops-program" href="NormalsAccumulate.html">NormalsAccumulate</a>. To solve the system of normal equations use <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>.'},
'NormalsBuildShortTimeStaticLongTime': { 'name': 'NormalsBuildShortTimeStaticLongTime', 'key': 'NormalsBuildShortTimeStaticLongTime', 'description': 'This program sets up normal equations based on   This program sets up normal equations based on  . Additionally short time and long time variations can be parametrized based on the static parameters in   This program sets up normal equations based on   in an efficient way. The observation equations are divided into time intervals   (e.g. daily) as defined in   This program sets up normal equations based on  . With  estimateLongTimeVariations  additional temporal variations can be co-estimated for a subset of the parameters selected by   This program sets up normal equations based on  . These parameters might be spherical harmonic coefficients with a limited maximum degree. The temporal variations are represented by base functions   (e.g. trend and annual oscillation) given by   This program sets up normal equations based on  . The temporal base functions are evaluated at the mid time   of each interval  , multiplicated with the design matrix   of the selected parameters, and the design matrix is extended accordingly. With  estimateShortTimeVariations  short time variations of the gravity field can be co-estimated. Their purpose is to mitigate temporal aliasing. The short time parameters selected by   This program sets up normal equations based on   (e.g. daily constant or linear splines every 6 hour) are constrained by an   This program sets up normal equations based on  . If only a static parameter set is selected the coressponding part of the design matrix is copied and modeled as a constant value per interval in   This program sets up normal equations based on   additionally so the corresponding temporal factor can be expressed as   Before writing the normal equations to   This program sets up normal equations based on   short time gravity and satellite specific parameters can be eliminated with  eliminateParameter . Example: For the computation of the mean gravity field ITSG-Grace2018s with additional trend and annual signal the normal equations are computed month by month and accumulated afterwards (see  NormalsAccumulate ). The observations were divided into daily intervals with   This program sets up normal equations based on  . The static gravity field has been parametrized as spherical harmonics up to degree   in   This program sets up normal equations based on  . The trend and annual signals defined by   This program sets up normal equations based on   were estimated for selected parameters up to degree  . To mitigate temporal aliasing daily gravity fields up to degree   were setup and constrained with an   This program sets up normal equations based on   up to order three. A detailed description of the approach is given in: Kvas, A., Mayer-Grr, T. GRACE gravity field recovery with background model uncertainties. J Geod 93, 25432552 (2019).  https://doi.org/10.1007/s00190-019-01314-1 .', 'config_table': 'outputfileNormalEquation filename outputfile for normal equations observation observationType  estimateShortTimeVariations sequence co-estimate short time gravity field variations autoregressiveModelSequence autoregressiveModelSequenceType AR model sequence for constraining short time gravity variations parameterSelection parameterSelectorType parameters describing the short time gravity field estimateLongTimeVariations sequence co-estimate long time gravity field variations parametrizationTemporal parametrizationTemporalType parametrization of time variations (trend, annual, ...) parameterSelection parameterSelectorType parameters describing the long time gravity field inputfileArcList filename list to correspond points of time to arc numbers defaultBlockSize uint block size for distributing the normal equations, 0: one block eliminateParameter boolean eliminate short time and state parameter', 'display_text': 'This program sets up normal equations based on <a class="groops-class" href="observationType.html">observation</a>. Additionally short time and long time variations can be parametrized based on the static parameters in <a class="groops-class" href="observationType.html">observation</a> in an efficient way. The observation equations are divided into time intervals $i \\in \\{1, ..., N\\}$ (e.g. daily) as defined in <a class="groops-class" href="fileFormat_arcList.html">inputfileArcList</a>.</p><p>With <strong class="groops-config-element">estimateLongTimeVariations</strong> additional temporal variations can be co-estimated for a subset of the parameters selected by <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a>. These parameters might be spherical harmonic coefficients with a limited maximum degree. The temporal variations are represented by base functions $\\Phi_k(t_i)$ (e.g. trend and annual oscillation) given by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>. The temporal base functions are evaluated at the mid time $t_i$ of each interval $i$, multiplicated with the design matrix $\\M A_i$ of the selected parameters, and the design matrix is extended accordingly.</p><p></p><p>With <strong class="groops-config-element">estimateShortTimeVariations</strong> short time variations of the gravity field can be co-estimated. Their purpose is to mitigate temporal aliasing. The short time parameters selected by <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a> (e.g. daily constant or linear splines every 6 hour) are constrained by an <a class="groops-class" href="autoregressiveModelSequenceType.html">autoregressiveModelSequence</a>. If only a static parameter set is selected the coressponding part of the design matrix is copied and modeled as a constant value per interval in <a class="groops-class" href="fileFormat_arcList.html">inputfileArcList</a> additionally so the corresponding temporal factor can be expressed as \\[   \\Phi_i(t)  =   \\begin{cases}     1 &\\text{if} \\hspace{5pt} t \\in [t_i, t_{i+1}) \\\\     0 & \\text{otherwise}   \\end{cases}. \\] Before writing the normal equations to <a class="groops-class" href="fileFormat_normalEquation.html">outputfileNormalEquation</a> short time gravity and satellite specific parameters can be eliminated with <strong class="groops-config-element">eliminateParameter</strong>.</p><p>Example: For the computation of the mean gravity field ITSG-Grace2018s with additional trend and annual signal the normal equations are computed month by month and accumulated afterwards (see <a class="groops-program" href="NormalsAccumulate.html">NormalsAccumulate</a>). The observations were divided into daily intervals with <a class="groops-class" href="fileFormat_arcList.html">inputfileArcList</a>. The static gravity field has been parametrized as spherical harmonics up to degree $n=200$ in <a class="groops-class" href="parametrizationGravityType.html">observation:parametrizationGravity</a>. The trend and annual signals defined by <a class="groops-class" href="parametrizationTemporalType.html">estimateLongTimeVariations:parametrizationTemporal</a> were estimated for selected parameters up to degree $n=120$. To mitigate temporal aliasing daily gravity fields up to degree $n=40$ were setup and constrained with an <a class="groops-class" href="autoregressiveModelSequenceType.html">autoregressiveModelSequence</a> up to order three.</p><p>A detailed description of the approach is given in: Kvas, A., Mayer-Grr, T. GRACE gravity field recovery with background model uncertainties. J Geod 93, 25432552 (2019). <a href="https://doi.org/10.1007/s00190-019-01314-1" target="_blank">https://doi.org/10.1007/s00190-019-01314-1</a>.'},
'NormalsCreate': { 'name': 'NormalsCreate', 'key': 'NormalsCreate', 'description': 'Create  normal equations  from calculated matrices (  Create  ). The   Create   can be created with  ParameterNamesCreate . The   Create   must be symmetric. The   Create   must have the same number of rows and can contain multiple columns for multiple solutions. The Vector   is the quadratic sum of observations for each column of the right hand side. It is used to determine the aposteriori accuracy  If the vector is not given, it is automatically determined by assuming  . The number of observations   is given by the expression  observationCount . The variable  observationCount  can be used, if it is set by a normal equation file   Create  .', 'config_table': 'outputfileNormalEquation filename  inputfileParameterNames filename  normalMatrix matrixGeneratorType  rightHandSide matrixGeneratorType  lPl matrixGeneratorType vector with size of rhs columns inputfileNormalEquationObsCount filename sets the variable observationCount observationCount expression (variables: rows, columns (rhs), observationCount)', 'display_text': 'Create <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a> from calculated matrices (<a class="groops-class" href="matrixGeneratorType.html">matrixGenerator</a>).</p><p>The <a class="groops-class" href="fileFormat_parameterName.html">inputfileParameterNames</a> can be created with <a class="groops-program" href="ParameterNamesCreate.html">ParameterNamesCreate</a>.</p><p>The <a class="groops-class" href="matrixGeneratorType.html">normalMatrix</a> must be symmetric. The <a class="groops-class" href="matrixGeneratorType.html">rightHandSide</a> must have the same number of rows and can contain multiple columns for multiple solutions.</p><p>The Vector $\\M l^T\\M P\\M l$ is the quadratic sum of observations for each column of the right hand side. It is used to determine the aposteriori accuracy \\[ \\hat{\\sigma}^2 = \\frac{\\hat{\\M e}^T\\M P\\hat{\\M e}}{n-m} = \\frac{\\M l^T\\M P\\M l - \\M n^T\\hat{\\M x}}{n-m}. \\]If the vector is not given, it is automatically determined by assuming $\\hat{\\sigma}^2=1$.</p><p>The number of observations $n$ is given by the expression <strong class="groops-config-element">observationCount</strong>. The variable <code>observationCount</code> can be used, if it is set by a normal equation file <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquationObsCount</a>.'},
'NormalsEliminate': { 'name': 'NormalsEliminate', 'key': 'NormalsEliminate', 'description': 'This program eliminates parameters from a system of   This program eliminates parameters from a system of  s. To just remove (cutting out) parameters use  NormalsReorder . The   This program eliminates parameters from a system of   allows the selection of parameters that will remain, all others will be eliminated. The order of remaining parameters can be modified via the parameter selection. Block size of the output normal matrix can be adjusted with  outBlockSize . If it is set to zero, the   This program eliminates parameters from a system of   is written to a single block file. For example the normal equations are divided into two groups of parameters   and   according to  and   shall be eliminated, the reduced system of normal equations is given by   See also  NormalsReorder .', 'config_table': 'outputfileNormalEquation filename  inputfileNormalEquation filename  remainingParameters parameterSelectorType parameter order/selection of output normal equations outBlockSize uint block size for distributing the normal equations, 0: one block', 'display_text': 'This program eliminates parameters from a system of <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a>s. To just remove (cutting out) parameters use <a class="groops-program" href="NormalsReorder.html">NormalsReorder</a>.</p><p>The <a class="groops-class" href="parameterSelectorType.html">remainingParameters</a> allows the selection of parameters that will remain, all others will be eliminated. The order of remaining parameters can be modified via the parameter selection. Block size of the output normal matrix can be adjusted with <strong class="groops-config-element">outBlockSize</strong>. If it is set to zero, the <a class="groops-class" href="fileFormat_normalEquation.html">outputfileNormalEquation</a> is written to a single block file.</p><p>For example the normal equations are divided into two groups of parameters $\\hat{\\M x}_1$ and $\\hat{\\M x}_2$ according to \\[ \\begin{pmatrix}   \\M N_{11} & \\M N_{12} \\\\   \\M N_{21} & \\M N_{22} \\end{pmatrix} \\begin{pmatrix} \\hat{\\M x}_1 \\\\ \\hat{\\M x}_2 \\end{pmatrix} = \\begin{pmatrix}   \\M n_1 \\\\   \\M n_2 \\end{pmatrix}. \\]and $\\hat{\\M x}_2$ shall be eliminated, the reduced system of normal equations is given by \\[ \\bar{\\M N}\\hat{\\M x} = \\bar{\\M n} \\qquad\\text{with}\\qquad \\bar{\\M N}=\\M N_{11}-\\M N_{12}\\M N_{22}^{-1}\\M N_{12}^T \\qquad\\text{and}\\qquad\\bar{\\M n} =  \\M n_1 - \\M N_{12}\\M N_{22}^{-1}\\M n_2. \\] See also <a class="groops-program" href="NormalsReorder.html">NormalsReorder</a>.'},
'NormalsMultiplyAdd': { 'name': 'NormalsMultiplyAdd', 'key': 'NormalsMultiplyAdd', 'description': 'This program modifies   This program modifies   in a way that   is estimated instead of  .  where   is   This program modifies   and   is  factor . This can be used to re-add reduced reference fields before a combined estimation at normal equation level. Therefore the right hand side of the normal equations is modified by  and the quadratic sum of observations by   As the normal matrix itself is not modified, rewriting of the matrix can be disabled by setting  writeNormalMatrix  to false.', 'config_table': 'outputfileNormalEquation filename  inputfileNormalEquation filename  inputfileParameter filename x factor double alpha writeNormalMatrix boolean write full coefficient matrix, right hand sides and info files', 'display_text': 'This program modifies <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a> in a way that $\\bar{\\M x}$ is estimated instead of $\\M x$. \\[  \\bar{\\M x} := \\M x + \\alpha\\, \\M x_0, \\]where $\\M x_0$ is <a class="groops-class" href="fileFormat_matrix.html">inputfileParameter</a> and $\\alpha$ is <strong class="groops-config-element">factor</strong>. This can be used to re-add reduced reference fields before a combined estimation at normal equation level. Therefore the right hand side of the normal equations is modified by \\[  \\bar{\\M n} := \\M n + \\alpha\\,\\M N\\M x_0, \\]and the quadratic sum of observations by \\[  \\bar{\\M l^T\\M P\\M l} := \\M l^T\\M P\\M l + \\alpha^2\\,\\M x_0^T\\M N\\M x_0 + 2\\alpha\\,\\M x_0^T\\M n \\] As the normal matrix itself is not modified, rewriting of the matrix can be disabled by setting <strong class="groops-config-element">writeNormalMatrix</strong> to false.'},
'NormalsRegularizationBorders': { 'name': 'NormalsRegularizationBorders', 'key': 'NormalsRegularizationBorders', 'description': 'This program sets up two regularization matrices for two different regional areas. For a given set of points defined by   This program sets up two regularization matrices for two different regional areas. For a given set of points defined by   it is evaluated, whether each point (corresponding to an unknown parameter of a respective parameterization by space localizing basis functions) is inside or outside a certain area given by   This program sets up two regularization matrices for two different regional areas. For a given set of points defined by  . Each regularization matrix is a diagonal matrix, one of them features a one if the point is inside, and a zero if the point lies outside the area. The other matrix features a zero if the point is inside, and a one if the point lies outside the area This results in two regularization matrices with  The two matrices are provided as vectors of the diagonal in the output files   This program sets up two regularization matrices for two different regional areas. For a given set of points defined by   and   This program sets up two regularization matrices for two different regional areas. For a given set of points defined by  . The regularization matrices are then used by   This program sets up two regularization matrices for two different regional areas. For a given set of points defined by  . As an example, the two different areas could be oceanic regions on the one hand and continental areas on the other hand.', 'config_table': 'outputfileInside filename  outputfileOutside filename  grid gridType nodal point distribution of parameters, e.g harmonics splines border borderType regularization areas, e.g land and ocean', 'display_text': 'This program sets up two regularization matrices for two different regional areas. For a given set of points defined by <a class="groops-class" href="gridType.html">grid</a> it is evaluated, whether each point (corresponding to an unknown parameter of a respective parameterization by space localizing basis functions) is inside or outside a certain area given by <a class="groops-class" href="borderType.html">border</a>. Each regularization matrix is a diagonal matrix, one of them features a one if the point is inside, and a zero if the point lies outside the area. The other matrix features a zero if the point is inside, and a one if the point lies outside the area This results in two regularization matrices with \\[ \\M R_1+\\M R_2=\\M I. \\]The two matrices are provided as vectors of the diagonal in the output files <a class="groops-class" href="fileFormat_matrix.html">outputfileOutside</a> and <a class="groops-class" href="fileFormat_matrix.html">outputfileInside</a>. The regularization matrices are then used by <a class="groops-class" href="normalEquationType.html#regularization">normalEquation:regularization</a>. As an example, the two different areas could be oceanic regions on the one hand and continental areas on the other hand.'},
'NormalsRegularizationSphericalHarmonics': { 'name': 'NormalsRegularizationSphericalHarmonics', 'key': 'NormalsRegularizationSphericalHarmonics', 'description': 'Diagonal regularization matrix from gravity field accuracies, if not given from signal (cnm,snm), if not given from kaulas rule. The inverse accuracies   are used as weights in the regularization matrix. The diagonal is saved as Vector. The corresponding pseudo observations can be computed with  Gravityfield2SphericalHarmonicsVector .', 'config_table': 'outputfileDiagonalmatrix filename  gravityfield gravityfieldType use sigmas, if not given use signal (cnm,snm), if not given use kaulas rule minRegularizationDegree uint  maxRegularizationDegree uint  minDegree uint  maxDegree uint  numbering sphericalHarmonicsNumberingType numbering scheme for regul matrix GM double Geocentric gravitational constant R double reference radius makeIsotropic boolean  kaulaPower double sigma = kaulaFactor*degree**kaulaPower kaulaFactor double sigma = kaulaFactor*degree**kaulaPower', 'display_text': 'Diagonal regularization matrix from gravity field accuracies, if not given from signal (cnm,snm), if not given from kaulas rule. The inverse accuracies $1/\\sigma_n^2$ are used as weights in the regularization matrix. The diagonal is saved as Vector.</p><p>The corresponding pseudo observations can be computed with <a class="groops-program" href="Gravityfield2SphericalHarmonicsVector.html">Gravityfield2SphericalHarmonicsVector</a>.'},
'NormalsReorder': { 'name': 'NormalsReorder', 'key': 'NormalsReorder', 'description': 'Reorder   Reorder   by selecting parameters in a specific order. The   Reorder   also allows one to change dimension of the normal equations, either by cutting parameters or by inserting zero rows/columns for additional parameters. Without   Reorder   the order of parameters remains the same. Additionally the block sizes of the files can be adjusted. If  outBlockSize  is set to zero, the normal matrix is written to a single block file, which is needed by some programs. To eliminate parameters without changing the result of the other parameters use  NormalsEliminate .', 'config_table': 'outputfileNormalEquation filename  inputfileNormalEquation filename  parameterSelection parameterSelectorType parameter order/selection of output normal equations outBlockSize uint block size for distributing the normal equations, 0: one block', 'display_text': 'Reorder <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a> by selecting parameters in a specific order. The <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a> also allows one to change dimension of the normal equations, either by cutting parameters or by inserting zero rows/columns for additional parameters. Without <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a> the order of parameters remains the same. Additionally the block sizes of the files can be adjusted. If <strong class="groops-config-element">outBlockSize</strong> is set to zero, the normal matrix is written to a single block file, which is needed by some programs.</p><p>To eliminate parameters without changing the result of the other parameters use <a class="groops-program" href="NormalsEliminate.html">NormalsEliminate</a>.'},
'NormalsScale': { 'name': 'NormalsScale', 'key': 'NormalsScale', 'description': 'Scales rows and columns of a system of   Scales rows and columns of a system of   given by a diagonal matrix   Scales rows and columns of a system of      The estimated solution is now  This is effectively the same as rescaling columns of the design matrix. This program is useful when combining normal equations from different sources, for example in case the units of certain parameters don\'t match.', 'config_table': 'outputfileNormalEquation filename  inputfileNormalEquation filename  inputfileFactorVector filename Vector containing the factors', 'display_text': 'Scales rows and columns of a system of <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a> given by a diagonal matrix <a class="groops-class" href="fileFormat_matrix.html">inputfileFactorVector</a> $\\M S$ \\[   \\bar{\\M N} := \\M S \\M N \\M S \\qquad\\text{and}\\qquad \\bar{\\M n} := \\M S \\M n. \\]The estimated solution is now \\[   \\bar{\\M x} := \\M S^{-1} \\M x. \\]This is effectively the same as rescaling columns of the design matrix. This program is useful when combining normal equations from different sources, for example in case the units of certain parameters don\'t match.'},
'NormalsSolverVCE': { 'name': 'NormalsSolverVCE', 'key': 'NormalsSolverVCE', 'description': 'This program accumulates   This program accumulates   and solves the total combined system. The relative weigthing between the individual normals is determined iteratively by means of variance component estimation (VCE). For a detailed description of the used algorithm see   This program accumulates  . Besides the estimated parameter vector (  This program accumulates  ) the estimated accuracies (  This program accumulates  ) and the full covariance matrix (  This program accumulates  ) can be saved. Also the combined normal system can be written to   This program accumulates  . The   This program accumulates   is a matrix with rows for each estimated parameter and columns for each   This program accumulates   and indicates the contribution of the individual normals to the estimated parameters. Each row sum up to one. See also  NormalsBuild .', 'config_table': 'outputfileSolution filename parameter vector outputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) outputfileCovariance filename full covariance matrix outputfileContribution filename contribution of normal system components to the solution vector outputfileVarianceFactors filename estimated variance factors as vector outputfileNormalEquation filename the combined normal equation system normalEquation normalEquationType  inputfileApproxSolution filename to accelerate convergence rightHandSideNumberVCE uint the right hand side number for estimation of variance factors normalsBlockSize uint block size for distributing the normal equations, 0: one block maxIterationCount uint maximum number of iterations for variance component estimation', 'display_text': 'This program accumulates <a class="groops-class" href="normalEquationType.html">normalEquation</a> and solves the total combined system. The relative weigthing between the individual normals is determined iteratively by means of variance component estimation (VCE). For a detailed description of the used algorithm see <a class="groops-class" href="normalEquationType.html">normalEquation</a>.</p><p>Besides the estimated parameter vector (<a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a>) the estimated accuracies (<a class="groops-class" href="fileFormat_matrix.html">outputfileSigmax</a>) and the full covariance matrix (<a class="groops-class" href="fileFormat_matrix.html">outputfileCovariance</a>) can be saved. Also the combined normal system can be written to <a class="groops-class" href="fileFormat_normalEquation.html">outputfileNormalEquation</a>.</p><p>The <a class="groops-class" href="fileFormat_matrix.html">outputfileContribution</a> is a matrix with rows for each estimated parameter and columns for each <a class="groops-class" href="normalEquationType.html">normalEquation</a> and indicates the contribution of the individual normals to the estimated parameters. Each row sum up to one.</p><p>See also <a class="groops-program" href="NormalsBuild.html">NormalsBuild</a>.'},
'NormalsTemporalCombination': { 'name': 'NormalsTemporalCombination', 'key': 'NormalsTemporalCombination', 'description': 'This program reads a times series of   This program reads a times series of   with asscociated   This program reads a times series of   and setup a new combined normal equation system. For each parameter a   This program reads a times series of   is used. It can be used to estimate trend and annual spherical harmonic coefficients from monthly GRACE normal equations.', 'config_table': 'outputfileNormalEquation filename  inputfileNormalEquation filename normal equations for each point in time timeSeries timeSeriesType times of each normal equations parametrizationTemporal parametrizationTemporalType', 'display_text': 'This program reads a times series of <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalequation</a> with asscociated <a class="groops-class" href="timeSeriesType.html">timeSeries</a> and setup a new combined normal equation system. For each parameter a <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a> is used.</p><p>It can be used to estimate trend and annual spherical harmonic coefficients from monthly GRACE normal equations.'},
'ParameterNamesCreate': { 'name': 'ParameterNamesCreate', 'key': 'ParameterNamesCreate', 'description': 'Generate a   Generate a   by   Generate a  . This file can be used in  NormalsCreate  or in the class   Generate a  .', 'config_table': 'outputfileParameterNames filename output parameter names file parameterName parameterNamesType', 'display_text': 'Generate a <a class="groops-class" href="fileFormat_parameterName.html">outputfileParameterNames</a> by <a class="groops-class" href="parameterNamesType.html">parameterName</a>. This file can be used in <a class="groops-program" href="NormalsCreate.html">NormalsCreate</a> or in the class <a class="groops-class" href="parameterSelectorType.html">parameterSelector</a>.'},
'ParameterSelection2IndexVector': { 'name': 'ParameterSelection2IndexVector', 'key': 'ParameterSelection2IndexVector', 'description': 'Generate index vector from parameter selection in  matrix format . This vector can be used in  MatrixCalculate  with   Generate index vector from parameter selection in   to reorder arbitrary vectors and matrices similar to  NormalsReorder . The   Generate index vector from parameter selection in   allows reordering and dimension changes, either by cutting parameters or by inserting additional parameters.   Generate index vector from parameter selection in   contains indices of parameters in   Generate index vector from parameter selection in   or -1 for newly added parameters.   Generate index vector from parameter selection in   contains the selected parameter names.', 'config_table': 'outputfileIndexVector filename indices of source parameters in target normal equations outputfileParameterNames filename output parameter names file inputfileParameterNames filename parameter names file of source normal equations parameterSelection parameterSelectorType parameter order/selection of target normal equations', 'display_text': 'Generate index vector from parameter selection in <a class="groops-file" href="fileFormat_matrix.html">matrix format</a>. This vector can be used in <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a> with <a class="groops-class" href="matrixGeneratorType.html#reorder">matrix:reorder</a> to reorder arbitrary vectors and matrices similar to <a class="groops-program" href="NormalsReorder.html">NormalsReorder</a>.</p><p>The <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a> allows reordering and dimension changes, either by cutting parameters or by inserting additional parameters. <a class="groops-class" href="fileFormat_matrix.html">outputfileIndexVector</a> contains indices of parameters in <a class="groops-class" href="fileFormat_parameterName.html">inputfileParameterNames</a> or -1 for newly added parameters. <a class="groops-class" href="fileFormat_parameterName.html">outputfileParameterNames</a> contains the selected parameter names.'},
'Orbit2ArgumentOfLatitude': { 'name': 'Orbit2ArgumentOfLatitude', 'key': 'Orbit2ArgumentOfLatitude', 'description': 'This program computes the argument of latitude of an  orbit  and writes it as  instrument file  (MISCVALUE(S)). The data of   This program computes the argument of latitude of an   are appended as values to each epoch.', 'config_table': 'outputfileArgOfLatitude filename instrument file (MISCVALUE(S): argLat, ...) inputfileOrbit filename  inputfileInstrument filename data are appended', 'display_text': 'This program computes the argument of latitude of an <a class="groops-file" href="fileFormat_instrument.html">orbit</a> and writes it as <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUE(S)). The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as values to each epoch.</p><p>'},
'Orbit2BetaPrimeAngle': { 'name': 'Orbit2BetaPrimeAngle', 'key': 'Orbit2BetaPrimeAngle', 'description': 'This program computes the beta prime angle (between the orbital plane and earth-sun direction) and writes it as MISCVALUE(S)  instrument file . The angle is calculated w.r.t the sun (per default), but can be changed. The data of   This program computes the beta prime angle (between the orbital plane and earth-sun direction) and writes it as MISCVALUE(S)   are appended as values to each epoch.', 'config_table': 'outputfileBetaAngle filename instrument file (MISCVALUE(S): beta\', ...) inputfileOrbit filename  inputfileInstrument filename data are appended ephemerides ephemeridesType  planet planetType', 'display_text': 'This program computes the beta prime angle (between the orbital plane and earth-sun direction) and writes it as MISCVALUE(S) <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>. The angle is calculated w.r.t the sun (per default), but can be changed. The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as values to each epoch.'},
'Orbit2EarthFixedOrbit': { 'name': 'Orbit2EarthFixedOrbit', 'key': 'Orbit2EarthFixedOrbit', 'description': 'Normally the orbits in GROOPS are given in the celestial reference frame (CRF) with the origin in the center of mass (CoM). This program rotates the orbit with   Normally the orbits in GROOPS are given in the celestial reference frame (CRF) with the origin in the center of mass (CoM). This program rotates the orbit with   from CRF to the TRF. To additionally tranform into the center of solid Earth (CE) frame (or center of Figure (CF)), a correction can be applied by providing degree one coefficients of a   Normally the orbits in GROOPS are given in the celestial reference frame (CRF) with the origin in the center of mass (CoM). This program rotates the orbit with   (e.g. ocean tides). If  celestial2terrestrial  is set to no, the inverse transformation is applied. See also  InstrumentRotate .', 'config_table': 'outputfileOrbit filename  inputfileOrbit filename  earthRotation earthRotationType transformation from CRF to TRF gravityfield gravityfieldType degree 1 fluid mantle for CM2CE correction celestial2terrestrial boolean yes: crf->trf, no: trf->crf', 'display_text': 'Normally the orbits in GROOPS are given in the celestial reference frame (CRF) with the origin in the center of mass (CoM). This program rotates the orbit with <a class="groops-class" href="earthRotationType.html">earthRotation</a> from CRF to the TRF.</p><p>To additionally tranform into the center of solid Earth (CE) frame (or center of Figure (CF)), a correction can be applied by providing degree one coefficients of a <a class="groops-class" href="gravityfieldType.html">gravityfield</a> (e.g. ocean tides).</p><p>If <strong class="groops-config-element">celestial2terrestrial</strong> is set to no, the inverse transformation is applied.</p><p>See also <a class="groops-program" href="InstrumentRotate.html">InstrumentRotate</a>.'},
'Orbit2EclipseFactor': { 'name': 'Orbit2EclipseFactor', 'key': 'Orbit2EclipseFactor', 'description': 'This program generates an  instrument file  (MISCVALUE(S)) containing the eclipse factor for a given set of orbit. The data of   This program generates an   are appended as values to each epoch.', 'config_table': 'outputfileEclipseFactor filename instrument file (MISCVALUE(S): eclipse, ...) inputfileOrbit filename  inputfileInstrument filename data are appended ephemerides ephemeridesType  eclipse eclipseType', 'display_text': 'This program generates an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUE(S)) containing the eclipse factor for a given set of orbit. The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as values to each epoch.'},
'Orbit2Groundtracks': { 'name': 'Orbit2Groundtracks', 'key': 'Orbit2Groundtracks', 'description': 'This program write  satellites positions  as  gridded data  ( outputfileTrackGriddedData ) in a terrestrial reference frame. The points are expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters  R  and  inverseFlattening . The orbit data are given in the celestial frame so   This program write   is needed to transform the data into the terrestrial frame. The data of   This program write   are appended as values to each point.', 'config_table': 'outputfileGriddedData filename positions as gridded data inputfileOrbit filename  inputfileInstrument filename values at grid points earthRotation earthRotationType transformation from CRF to TRF R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'This program write <a class="groops-file" href="fileFormat_instrument.html">satellites positions</a> as <a class="groops-file" href="fileFormat_griddedData.html">gridded data</a> (<strong class="groops-config-element">outputfileTrackGriddedData</strong>) in a terrestrial reference frame. The points are expressed as ellipsoidal coordinates (longitude, latitude, height) based on a reference ellipsoid with parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong>. The orbit data are given in the celestial frame so <a class="groops-class" href="earthRotationType.html">earthRotation</a> is needed to transform the data into the terrestrial frame. The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as values to each point.'},
'Orbit2Kepler': { 'name': 'Orbit2Kepler', 'key': 'Orbit2Kepler', 'description': 'This program computes the osculating Keplerian elements from position and velocity of a given   This program computes the osculating Keplerian elements from position and velocity of a given  . The   This program computes the osculating Keplerian elements from position and velocity of a given   must contain positions and velocities (see  OrbitAddVelocityAndAcceleration ). The  outputfileKepler  is an  instrument file  (MISCVALUES) with the Keplerian elements at each epoch in the following order    Ascending Node   [degree]  Inclination   [degree]  Argument of perigee   [degree]  major axis   [m]  eccentricity    mean anomaly   [degree]  transit time of perigee   [mjd]   The data of   This program computes the osculating Keplerian elements from position and velocity of a given   are appended as values to each epoch.', 'config_table': 'outputfileKepler filename instrument file (MISCVALUES: Omega, i, omega [degree], a [m], e, M [degree], tau [mjd], ...) inputfileOrbit filename position and velocity at each epoch define the kepler orbit inputfileInstrument filename data is appended GM double Geocentric gravitational constant', 'display_text': 'This program computes the osculating Keplerian elements from position and velocity of a given <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. The <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> must contain positions and velocities (see <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a>).</p><p>The <strong class="groops-config-element">outputfileKepler</strong> is an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES) with the Keplerian elements at each epoch in the following order <ul>  <li>Ascending Node $\\Omega$ [degree] </li><li> Inclination $i$ [degree] </li><li> Argument of perigee $\\omega$ [degree] </li><li> major axis $a$ [m] </li><li> eccentricity $e$ </li><li> mean anomaly $M$ [degree] </li><li> transit time of perigee $\\tau$ [mjd] </li></ul>  The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as values to each epoch.'},
'Orbit2MagneticField': { 'name': 'Orbit2MagneticField', 'key': 'Orbit2MagneticField', 'description': 'This program computes the magentic field vector(    in CRF)) along an  orbit  and writes it as  instrument file  (MISCVALUES). The data of   This program computes the magentic field vector(  are appended as data columns to each epoch.', 'config_table': 'outputfileMagneticField filename instrument file (x,y,z in CRF [Tesla = kg/A/s^2]), ...) inputfileOrbit filename  inputfileInstrument filename data are appended to output file magnetosphere magnetosphereType  earthRotation earthRotationType', 'display_text': 'This program computes the magentic field vector($x, y, z$ $[Tesla = kg/A/s^2]$ in CRF)) along an <a class="groops-file" href="fileFormat_instrument.html">orbit</a> and writes it as <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES). The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as data columns to each epoch.'},
'Orbit2ThermosphericState': { 'name': 'Orbit2ThermosphericState', 'key': 'Orbit2ThermosphericState', 'description': 'This program computes the thermosperic state (density, temperature, wind (x,y,z in CRF)) based on emprical models along an  orbit  and writes it as  instrument file  (MISCVALUES). The wind is given in an celestial reference frame (CRF). The data of   This program computes the thermosperic state (density, temperature, wind (x,y,z in CRF)) based on emprical models along an   are appended as values to each epoch.', 'config_table': 'outputfileThermosphericState filename instrument file (MISCVALUES: density, temperature, wind (x,y,z in CRF), ...) inputfileOrbit filename  inputfileInstrument filename data are appended to output file thermosphere thermosphereType  earthRotation earthRotationType', 'display_text': 'This program computes the thermosperic state (density, temperature, wind (x,y,z in CRF)) based on emprical models along an <a class="groops-file" href="fileFormat_instrument.html">orbit</a> and writes it as <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> (MISCVALUES). The wind is given in an celestial reference frame (CRF). The data of <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> are appended as values to each epoch.'},
'OrbitAddVelocityAndAcceleration': { 'name': 'OrbitAddVelocityAndAcceleration', 'key': 'OrbitAddVelocityAndAcceleration', 'description': 'This program computes velocities and accelerations from a given  orbit  by differentiating a moving polynomial. The values are saved in one output file which then contains orbit, velocity and acceleration.', 'config_table': 'outputfileOrbit filename  inputfileOrbit filename  polynomialDegree uint Polynomial degree, must be even!', 'display_text': 'This program computes velocities and accelerations from a given <a class="groops-file" href="fileFormat_instrument.html">orbit</a> by differentiating a moving polynomial. The values are saved in one output file which then contains orbit, velocity and acceleration.'},
'PlanetOrbit': { 'name': 'PlanetOrbit', 'key': 'PlanetOrbit', 'description': 'Creates an  orbit file  of sun, moon, or planets. The orbit is given in the celestial reference frame (CRF) or alternatively in the terrestrial reference frame (TRF) if   Creates an   is provided.', 'config_table': 'outputfileOrbit filename  planet planetType  timeSeries timeSeriesType  ephemerides ephemeridesType  earthRotation earthRotationType transform orbits into TRF', 'display_text': 'Creates an <a class="groops-file" href="fileFormat_instrument.html">orbit file</a> of sun, moon, or planets. The orbit is given in the celestial reference frame (CRF) or alternatively in the terrestrial reference frame (TRF) if <a class="groops-class" href="earthRotationType.html">earthRotation</a> is provided.'},
'PlotDegreeAmplitudes': { 'name': 'PlotDegreeAmplitudes', 'key': 'PlotDegreeAmplitudes', 'description': 'Plot degree amplitudes of potential coefficients computed by  Gravityfield2DegreeAmplitudes  or  PotentialCoefficients2DegreeAmplitudes  using the GMT Generic Mapping Tools ( https://www.generic-mapping-tools.org ). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of  outputfile . This is a convenience program with meaningful default values. The same plots can be generated with the more general  PlotGraph .', 'config_table': 'outputfile filename *.png, *.jpg, *.eps, ... title string  layer plotGraphLayerType  minDegree uint  maxDegree uint  majorTickSpacingDegree double boundary annotation minorTickSpacingDegree double frame tick spacing gridLineSpacingDegree double gridline spacing labelDegree string description of the x-axis logarithmicDegree boolean use logarithmic scale for the x-axis minY double  maxY double  majorTickSpacingY double boundary annotation minorTickSpacingY double frame tick spacing gridLineSpacingY double gridline spacing unitY string appended to axis values labelY string description of the y-axis logarithmicY boolean use logarithmic scale for the y-axis gridLine plotLineType The style of the grid lines. legend plotLegendType  options sequence further options... width double in cm height double in cm titleFontSize uint in pt marginTitle double between title and figure [cm] drawGridOnTop boolean grid lines above all other lines/points options string  transparent boolean make background transparent dpi uint use this resolution when rasterizing postscript file removeFiles boolean remove .gmt and script files', 'display_text': 'Plot degree amplitudes of potential coefficients computed by <a class="groops-program" href="Gravityfield2DegreeAmplitudes.html">Gravityfield2DegreeAmplitudes</a> or <a class="groops-program" href="PotentialCoefficients2DegreeAmplitudes.html">PotentialCoefficients2DegreeAmplitudes</a> using the GMT Generic Mapping Tools (<a href="https://www.generic-mapping-tools.org" target="_blank">https://www.generic-mapping-tools.org</a>). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of <strong class="groops-config-element">outputfile</strong>. This is a convenience program with meaningful default values. The same plots can be generated with the more general <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.</p><p>'},
'PlotGraph': { 'name': 'PlotGraph', 'key': 'PlotGraph', 'description': 'Generates a two dimensional xy plot using the GMT Generic Mapping Tools ( https://www.generic-mapping-tools.org ). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of  outputfile . The plotting area is defined by the two axes   Generates a two dimensional xy plot using the GMT Generic Mapping Tools ( . An alternative   Generates a two dimensional xy plot using the GMT Generic Mapping Tools (  on the right hand side can be added. The content of the graph itself is defined by one or more   Generates a two dimensional xy plot using the GMT Generic Mapping Tools ( s. The plot programs create a temporary directory in the path of  outputfile , writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting  options:removeFiles =false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with  options:options =" FORMAT=value ", see  https://docs.generic-mapping-tools.org/latest/gmt.conf.html . See also:  PlotDegreeAmplitudes ,  PlotMap ,  PlotMatrix ,  PlotSphericalHarmonicsTriangle .', 'config_table': 'outputfile filename *.png, *.jpg, *.eps, ... title string  layer plotGraphLayerType  axisX plotAxisType  axisY plotAxisType  axisY2 plotAxisType Second y-axis on right hand side colorbar plotColorbarType  legend plotLegendType  options sequence further options... width double in cm height double in cm titleFontSize uint in pt marginTitle double between title and figure [cm] drawGridOnTop boolean grid lines above all other lines/points options string  transparent boolean make background transparent dpi uint use this resolution when rasterizing postscript file removeFiles boolean remove .gmt and script files', 'display_text': 'Generates a two dimensional xy plot using the GMT Generic Mapping Tools (<a href="https://www.generic-mapping-tools.org" target="_blank">https://www.generic-mapping-tools.org</a>). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of <strong class="groops-config-element">outputfile</strong>.</p><p>The plotting area is defined by the two axes <a class="groops-class" href="plotAxisType.html">axisX/Y</a>. An alternative <a class="groops-class" href="plotAxisType.html">axisY2</a> on the right hand side can be added. The content of the graph itself is defined by one or more <a class="groops-class" href="plotGraphLayerType.html">layer</a>s.</p><p>The plot programs create a temporary directory in the path of <strong class="groops-config-element">outputfile</strong>, writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting <strong class="groops-config-element">options:removeFiles</strong>=false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with <strong class="groops-config-element">options:options</strong>="<code>FORMAT=value</code>", see <a href="https://docs.generic-mapping-tools.org/latest/gmt.conf.html" target="_blank">https://docs.generic-mapping-tools.org/latest/gmt.conf.html</a>.</p><p>See also: <a class="groops-program" href="PlotDegreeAmplitudes.html">PlotDegreeAmplitudes</a>, <a class="groops-program" href="PlotMap.html">PlotMap</a>, <a class="groops-program" href="PlotMatrix.html">PlotMatrix</a>, <a class="groops-program" href="PlotSphericalHarmonicsTriangle.html">PlotSphericalHarmonicsTriangle</a>.'},
'PlotMap': { 'name': 'PlotMap', 'key': 'PlotMap', 'description': 'Generates a map using the GMT Generic Mapping Tools ( https://www.generic-mapping-tools.org ). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of  outputfile . The base map is defined by a   Generates a map using the GMT Generic Mapping Tools (  of an ellipsoid ( R ,  inverseFlattening ). The content of the map itself is defined by one or more   Generates a map using the GMT Generic Mapping Tools ( s. The plot programs create a temporary directory in the path of  outputfile , writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting  options:removeFiles =false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with  options:options =" FORMAT=value ", see  https://docs.generic-mapping-tools.org/latest/gmt.conf.html . See also:  PlotDegreeAmplitudes ,  PlotGraph ,  PlotMatrix ,  PlotSphericalHarmonicsTriangle .', 'config_table': 'outputfile filename *.png, *.jpg, *.eps, ... title string  statisticInfos boolean  layer plotMapLayerType  R double reference radius for ellipsoidal coordinates on output inverseFlattening double reference flattening for ellipsoidal coordinates on output, 0: spherical coordinates minLambda angle min. longitude (default: compute from input data) maxLambda angle max. longitude (default: compute from input data) minPhi angle min. latitude (default: compute from input data) maxPhi angle max. latitude (default: compute from input data) majorTickSpacing angle boundary annotation minorTickSpacing angle frame tick spacing gridLineSpacing angle gridline spacing colorbar plotColorbarType  projection plotMapProjectionType map projection options sequence further options... width double in cm height double in cm titleFontSize uint in pt marginTitle double between title and figure [cm] drawGridOnTop boolean grid lines above all other lines/points options string  transparent boolean make background transparent dpi uint use this resolution when rasterizing postscript file removeFiles boolean remove .gmt and script files', 'display_text': 'Generates a map using the GMT Generic Mapping Tools (<a href="https://www.generic-mapping-tools.org" target="_blank">https://www.generic-mapping-tools.org</a>). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of <strong class="groops-config-element">outputfile</strong>.</p><p>The base map is defined by a <a class="groops-class" href="plotMapProjectionType.html">projection</a> of an ellipsoid (<strong class="groops-config-element">R</strong>, <strong class="groops-config-element">inverseFlattening</strong>). The content of the map itself is defined by one or more <a class="groops-class" href="plotMapLayerType.html">layer</a>s.</p><p>The plot programs create a temporary directory in the path of <strong class="groops-config-element">outputfile</strong>, writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting <strong class="groops-config-element">options:removeFiles</strong>=false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with <strong class="groops-config-element">options:options</strong>="<code>FORMAT=value</code>", see <a href="https://docs.generic-mapping-tools.org/latest/gmt.conf.html" target="_blank">https://docs.generic-mapping-tools.org/latest/gmt.conf.html</a>.</p><p>See also: <a class="groops-program" href="PlotDegreeAmplitudes.html">PlotDegreeAmplitudes</a>, <a class="groops-program" href="PlotGraph.html">PlotGraph</a>, <a class="groops-program" href="PlotMatrix.html">PlotMatrix</a>, <a class="groops-program" href="PlotSphericalHarmonicsTriangle.html">PlotSphericalHarmonicsTriangle</a>.</p><p>'},
'PlotMatrix': { 'name': 'PlotMatrix', 'key': 'PlotMatrix', 'description': 'Plot the coefficients of a   Plot the coefficients of a   using the GMT Generic Mapping Tools ( https://www.generic-mapping-tools.org ). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of  outputfile . The plot programs create a temporary directory in the path of  outputfile , writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting  options:removeFiles =false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with  options:options =" FORMAT=value ", see  https://docs.generic-mapping-tools.org/latest/gmt.conf.html .', 'config_table': 'outputfile filename *.png, *.jpg, *.eps, ... title string  inputfileMatrix filename  minColumn uint minimum column index to plot maxColumn uint maximum column index to plot majorTickSpacingX double boundary annotation minorTickSpacingX double frame tick spacing gridLineSpacingX double gridline spacing minRow uint minimum row index to plot maxRow uint maximum row index to plot majorTickSpacingY double boundary annotation minorTickSpacingY double frame tick spacing gridLineSpacingY double gridline spacing gridLine plotLineType The style of the grid lines. colorbar plotColorbarType  options sequence further options... width double in cm height double in cm titleFontSize uint in pt marginTitle double between title and figure [cm] drawGridOnTop boolean grid lines above all other lines/points options string  transparent boolean make background transparent dpi uint use this resolution when rasterizing postscript file removeFiles boolean remove .gmt and script files', 'display_text': 'Plot the coefficients of a <a class="groops-class" href="fileFormat_matrix.html">inputfileMatrix</a> using the GMT Generic Mapping Tools (<a href="https://www.generic-mapping-tools.org" target="_blank">https://www.generic-mapping-tools.org</a>). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of <strong class="groops-config-element">outputfile</strong>.</p><p>The plot programs create a temporary directory in the path of <strong class="groops-config-element">outputfile</strong>, writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting <strong class="groops-config-element">options:removeFiles</strong>=false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with <strong class="groops-config-element">options:options</strong>="<code>FORMAT=value</code>", see <a href="https://docs.generic-mapping-tools.org/latest/gmt.conf.html" target="_blank">https://docs.generic-mapping-tools.org/latest/gmt.conf.html</a>.</p><p>'},
'PlotSphericalHarmonicsTriangle': { 'name': 'PlotSphericalHarmonicsTriangle', 'key': 'PlotSphericalHarmonicsTriangle', 'description': 'Plot the potential coefficients of a spherical harmonic expansion using the GMT Generic Mapping Tools ( https://www.generic-mapping-tools.org ). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of  outputfile . This program plots the formal errors (sigmas). If   Plot the potential coefficients of a spherical harmonic expansion using the GMT Generic Mapping Tools (  provides no sigmas e.g. with  setSigmasToZero  in   Plot the potential coefficients of a spherical harmonic expansion using the GMT Generic Mapping Tools (  the coefficients itself are plotted instead. The plot programs create a temporary directory in the path of  outputfile , writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting  options:removeFiles =false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with  options:options =" FORMAT=value ", see  https://docs.generic-mapping-tools.org/latest/gmt.conf.html .', 'config_table': 'outputfile filename *.png, *.jpg, *.eps, ... title string  gravityfield gravityfieldType use sigmas, if not given use signal (cnm,snm) time time at this time the gravity field will be evaluated minDegree uint  maxDegree uint  majorTickSpacing double boundary annotation minorTickSpacing double frame tick spacing gridLineSpacing double gridline spacing gridLine plotLineType The style of the grid lines. colorbar plotColorbarType  options sequence further options... width double in cm height double in cm titleFontSize uint in pt marginTitle double between title and figure [cm] drawGridOnTop boolean grid lines above all other lines/points options string  transparent boolean make background transparent dpi uint use this resolution when rasterizing postscript file removeFiles boolean remove .gmt and script files', 'display_text': 'Plot the potential coefficients of a spherical harmonic expansion using the GMT Generic Mapping Tools (<a href="https://www.generic-mapping-tools.org" target="_blank">https://www.generic-mapping-tools.org</a>). A variety of image file formats are supported (e.g. png, jpg, eps) determined by the extension of <strong class="groops-config-element">outputfile</strong>.</p><p>This program plots the formal errors (sigmas). If <a class="groops-class" href="gravityfieldType.html">gravityfield</a> provides no sigmas e.g. with <strong class="groops-config-element">setSigmasToZero</strong> in <a class="groops-class" href="gravityfieldType.html#potentialCoefficients">gravityfield:potentialCoefficients</a> the coefficients itself are plotted instead.</p><p>The plot programs create a temporary directory in the path of <strong class="groops-config-element">outputfile</strong>, writes all needed data into it, generates a batch/shell script with the GMT commands, execute it, and remove the temporary directory. With setting <strong class="groops-config-element">options:removeFiles</strong>=false the last step is skipped and it is possible to adjust the plot manually to specific publication needs. Individual GMT settings are adjusted with <strong class="groops-config-element">options:options</strong>="<code>FORMAT=value</code>", see <a href="https://docs.generic-mapping-tools.org/latest/gmt.conf.html" target="_blank">https://docs.generic-mapping-tools.org/latest/gmt.conf.html</a>.</p><p>'},
'PreprocessingDualSst': { 'name': 'PreprocessingDualSst', 'key': 'PreprocessingDualSst', 'description': 'This programs processes satellite-to-satellite-tracking (SST) and orbit observations in a GRACE like configuration. Four different observation groups are considered separately: two types of SST and POD1/POD2 for the two satellites. This program works similar to  PreprocessingSst , see there for details. Here only the settings explained, which are different. Both SST observation types are reduced by the same background models and the same impact of accelerometer measurements. The covariance matrix of the reduced observations should not consider the the instrument noise only (  This programs processes satellite-to-satellite-tracking (SST) and orbit observations in a GRACE like configuration. Four different observation groups are considered separately: two types of SST and POD1/POD2 for the two satellites. This program works similar to  ) but must take the cross correlations   This programs processes satellite-to-satellite-tracking (SST) and orbit observations in a GRACE like configuration. Four different observation groups are considered separately: two types of SST and POD1/POD2 for the two satellites. This program works similar to   into account. The covariance matrix of the reduced observations is given by', 'config_table': 'outputfileSolution filename estimated parameter vector (static part only) outputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) outputfileParameterName filename estimated signal parameters (index is appended) estimateArcSigmas sequence  outputfileSigmasPerArcSst1 filename accuracies of each arc (SST1) outputfileSigmasPerArcSst2 filename accuracies of each arc (SST2) outputfileSigmasPerArcAcc filename accuracies of each arc (ACC) outputfileSigmasPerArcPod1 filename accuracies of each arc (POD1) outputfileSigmasPerArcPod2 filename accuracies of each arc (POD2) estimateEpochSigmas sequence  outputfileSigmasPerEpochSst1 filename accuracies of each epoch (SST1) outputfileSigmasPerEpochSst2 filename accuracies of each epoch (SST2) outputfileSigmasPerEpochAcc filename accuracies of each epoch (ACC) outputfileSigmasPerEpochPod1 filename accuracies of each epoch (POD1) outputfileSigmasPerEpochPod2 filename accuracies of each epoch (POD2) estimateCovarianceFunctions sequence  outputfileCovarianceFunctionSst1 filename covariance function outputfileCovarianceFunctionSst2 filename covariance function outputfileCovarianceFunctionAcc filename covariance function outputfileCovarianceFunctionPod1 filename covariance functions for along, cross, radial direction outputfileCovarianceFunctionPod2 filename covariance functions for along, cross, radial direction computeResiduals sequence  outputfileSst1Residuals filename  outputfileSst2Residuals filename  outputfileAccResiduals filename  outputfilePod1Residuals filename  outputfilePod2Residuals filename  observation choice obervation equations (Sst) dualSstVariational sequence two SST observations rightHandSide sequence input for observation vectors inputfileSatelliteTracking1 filename ranging observations and corrections inputfileSatelliteTracking2 filename ranging observations and corrections inputfileOrbit1 filename kinematic positions of satellite A as observations inputfileOrbit2 filename kinematic positions of satellite B as observations sstType choice  range   rangeRate   none   inputfileVariational1 filename approximate position and integrated state matrix inputfileVariational2 filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst1 parametrizationSatelliteTrackingType satellite tracking parameter for first ranging observations parametrizationSst2 parametrizationSatelliteTrackingType satellite tracking parameter for second ranging observations integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n covarianceSst1 sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovarianceMatrixArc filename Must be given per sst arc with correct dimensions. inputfileSigmasCovarianceMatrixArc filename Vector with one sigma for each <inputfileCovarianceMatrixArc> sampling double [seconds] sampling of the covariance function covarianceSst2 sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovarianceMatrixArc filename Must be given per sst arc with correct dimensions. inputfileSigmasCovarianceMatrixArc filename Vector with one sigma for each <inputfileCovarianceMatrixArc> sampling double [seconds] sampling of the covariance function covarianceAcc sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovarianceMatrixArc filename Must be given per sst arc with correct dimensions. inputfileSigmasCovarianceMatrixArc filename Vector with one sigma for each <inputfileCovarianceMatrixArc> sampling double [seconds] sampling of the covariance function covariancePod1 sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovariancePodEpoch filename 3x3 epoch covariances sampling double [seconds] sampling of the covariance function covariancePod2 sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovariancePodEpoch filename 3x3 epoch covariances sampling double [seconds] sampling of the covariance function estimateShortTimeVariations sequence co-estimate short time gravity field variations estimateSigma boolean estimate standard deviation via VCE autoregressiveModelSequence autoregressiveModelSequenceType AR model sequence for constraining short time gravity variations parameterSelection parameterSelectorType parameters describing the short time gravity field downweightPod double downweight factor for POD inputfileArcList filename list to correspond points of time to arc numbers iterationCount uint (maximum) number of iterations for the estimation of calibration parameter and error PSD variableNameIterations string All output fileNames in preprocessing iteration are expanded with this variable prior to writing to disk defaultBlockSize uint block size of static normal equation blocks', 'display_text': 'This programs processes satellite-to-satellite-tracking (SST) and orbit observations in a GRACE like configuration. Four different observation groups are considered separately: two types of SST and POD1/POD2 for the two satellites. This program works similar to <a class="groops-program" href="PreprocessingSst.html">PreprocessingSst</a>, see there for details. Here only the settings explained, which are different.</p><p>Both SST observation types are reduced by the same background models and the same impact of accelerometer measurements. The covariance matrix of the reduced observations should not consider the the instrument noise only (<a class="groops-class" href="covarianceSstType.html">covarianceSst1/2</a>) but must take the cross correlations <a class="groops-class" href="covarianceSstType.html">covarianceAcc</a> into account. The covariance matrix of the reduced observations is given by \\[   \\M\\Sigma(\\begin{bmatrix} \\Delta l_{SST1} \\\\ \\Delta l_{SST2} \\end{bmatrix})   = \\begin{bmatrix} \\M\\Sigma_{SST1} + \\M\\Sigma_{ACC} & \\M\\Sigma_{ACC} \\\\                    \\M\\Sigma_{ACC} & \\M\\Sigma_{SST2} + \\M\\Sigma_{ACC}     \\end{bmatrix}. \\]'},
'PreprocessingGradiometer': { 'name': 'PreprocessingGradiometer', 'key': 'PreprocessingGradiometer', 'description': 'This program estimates empirical covariance functions of the gradiometer instrument noise and determine arc wise variances to downweight arcs with outliers. This program works similar to  PreprocessingPod , see there for details. Here only the settings explained, which are different. ...', 'config_table': 'outputfileCovarianceFunction filename  outputfileSigmasPerArc filename accuracies of each arc outputfileSggResiduals filename  rightHandSide sggRightSideType input for the observation vector inputfileOrbit filename  inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  parametrizationBias parametrizationTemporalType per arc covarianceSgg sequence  inputfileCovarianceFunction filename approximate covariances in time covarianceLength uint counts observation epochs sampling double [seconds] sampling of the covariance function iterationCount uint for the estimation of calibration parameter and error PSD', 'display_text': 'This program estimates empirical covariance functions of the gradiometer instrument noise and determine arc wise variances to downweight arcs with outliers. This program works similar to <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>, see there for details. Here only the settings explained, which are different.</p><p>...'},
'PreprocessingPod': { 'name': 'PreprocessingPod', 'key': 'PreprocessingPod', 'description': 'This program estimates empirical covariance functions of the instrument noise and determine arc wise variances to downweight arc with outliers. A complete least squares adjustment for gravity field determination is performed by computing the  observation  equations, see   This program estimates empirical covariance functions of the instrument noise and determine arc wise variances to downweight arc with outliers.  or   This program estimates empirical covariance functions of the instrument noise and determine arc wise variances to downweight arc with outliers.  for details. The normal equations are accumulated and solved to   This program estimates empirical covariance functions of the instrument noise and determine arc wise variances to downweight arc with outliers.  together with the estimated accuracies   This program estimates empirical covariance functions of the instrument noise and determine arc wise variances to downweight arc with outliers. . The estimated residuals   can be computed with  computeResiduals . For each component (along, cross, radial) of the kinematic orbit positions a noise covariance function is estimated  The covariance matrix is composed of the sum of matrices   and unknown variance factors  with the cosine transformation matrices   An additional variance factor can be computed ( estimateArcSigmas ) for each arc    according to  where   is the redundancy. This variance factor should be around one for normal behaving arcs as the noise characteristics is already considered by the covariance matrix but bad arcs get a much larger variance. By appling this factor bad arcs or arcs with large outliers are downweighted.', 'config_table': 'outputfileSolution filename estimated parameter vector (static part only) outputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) outputfileParameterName filename names of estimated parameters (static part only) estimateArcSigmas sequence  outputfileSigmasPerArcPod filename accuracies of each arc (POD2) estimateCovarianceFunctions sequence  outputfileCovarianceFunctionPod filename covariance functions for along, cross, radial direction computeResiduals sequence  outputfilePodResiduals filename  observation choice obervation equations (POD) podIntegral sequence precise orbit data (integral approach) inputfileSatelliteModel filename satellite macro model rightHandSide podRightSideType input for the reduced observation vector inputfileOrbit filename used to evaluate the observation equations, not used as observations inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  gradientfield gravityfieldType low order field to estimate the change of the gravity by position adjustement parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration parametrizationAccelerationType orbit force parameters keepSatelliteStates boolean set boundary values of each arc global integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n accelerateComputation boolean acceleration of computation by transforming the observations podVariational sequence precise orbit data (variational equations) rightHandSide sequence input for observation vectors inputfileOrbit filename kinematic positions as observations inputfileVariational filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration parametrizationAccelerationType orbit force parameters integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n accelerateComputation boolean acceleration of computation by transforming the observations covariancePod sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileCovarianceFunction filename approximate covariances in time inputfileCovariancePodEpoch filename 3x3 epoch covariances sampling double [seconds] sampling of the covariance function inputfileArcList filename list to correspond points of time to arc numbers adjustmentThreshold double Adjustment factor threshold: Iteration will be stopped once both SST and POD adjustment factors are under this threshold iterationCount uint (maximum) number of iterations for the estimation of calibration parameter and error PSD', 'display_text': 'This program estimates empirical covariance functions of the instrument noise and determine arc wise variances to downweight arc with outliers.</p><p>A complete least squares adjustment for gravity field determination is performed by computing the <strong class="groops-config-element">observation</strong> equations, see <a class="groops-class" href="observationType.html#podIntegral">observation:podIntegral</a> or <a class="groops-class" href="observationType.html#podVariational">observation:podVariational</a> for details. The normal equations are accumulated and solved to <a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a> together with the estimated accuracies <a class="groops-class" href="fileFormat_matrix.html">outputfileSigmax</a>. The estimated residuals $\\hat{\\M e}=\\M l-\\M A\\hat{\\M x}$ can be computed with <strong class="groops-config-element">computeResiduals</strong>.</p><p>For each component (along, cross, radial) of the kinematic orbit positions a noise covariance function is estimated \\[   \\text{cov}(\\Delta t_i) = \\sum_{n=0}^{N-1} a_n^2 \\cos\\left(\\frac{\\pi}{T} n\\Delta t_i\\right). \\]The covariance matrix is composed of the sum of matrices $F_n$ and unknown variance factors \\[   \\M\\Sigma = a_1^2\\M F_1 + a_2^2 \\M F_2 + \\cdots + a_N^2\\M F_N, \\]with the cosine transformation matrices \\[   \\M F_n = \\left(\\cos\\left(\\frac{\\pi}{T} n(t_i-t_k)\\right)\\right)_{ik}. \\] An additional variance factor can be computed (<strong class="groops-config-element">estimateArcSigmas</strong>) for each arc $k$  according to \\[   \\hat{\\sigma}_k^2 = \\frac{\\hat{\\M e}_k^T\\M\\Sigma^{-1}\\hat{\\M e}_k}{r_k}, \\]where $r_k$ is the redundancy. This variance factor should be around one for normal behaving arcs as the noise characteristics is already considered by the covariance matrix but bad arcs get a much larger variance. By appling this factor bad arcs or arcs with large outliers are downweighted.'},
'PreprocessingSst': { 'name': 'PreprocessingSst', 'key': 'PreprocessingSst', 'description': 'This program processes satellite-to-satellite-tracking (SST) and kinematic orbit observations in a GRACE like configuration. Three different observation groups are considered separately: SST and POD1/POD2 for the two satellites. This program works similar to  PreprocessingPod , see there for details. Here only deviations in the settings are explained. Precise orbit data (POD) often contains systematic errors in addition to stochastic noise. In this case the variance component estimation fails and assigns too much weight to the POD data. Therefore an additional  downweightPod  factor can be applied to the standard deviation of POD for the next least squares adjustment in the iteration. This factor should also applied as  sigma  in   This program processes satellite-to-satellite-tracking (SST) and kinematic orbit observations in a GRACE like configuration. Three different observation groups are considered separately: SST and POD1/POD2 for the two satellites. This program works similar to   for computation of the final solution e.g. with  NormalsSolverVCE . Short time variations of the gravity field can be co-estimated together with the static/monthly mean gravity field. The short time parameters must also be set in   This program processes satellite-to-satellite-tracking (SST) and kinematic orbit observations in a GRACE like configuration. Three different observation groups are considered separately: SST and POD1/POD2 for the two satellites. This program works similar to   and can then be selected by   This program processes satellite-to-satellite-tracking (SST) and kinematic orbit observations in a GRACE like configuration. Three different observation groups are considered separately: SST and POD1/POD2 for the two satellites. This program works similar to  . If these parameters are not time variable, for example when a range of static parameters is selected, they are set up as constant for each time interval defined in  inputfileArcList . The parameters are constrained by an   This program processes satellite-to-satellite-tracking (SST) and kinematic orbit observations in a GRACE like configuration. Three different observation groups are considered separately: SST and POD1/POD2 for the two satellites. This program works similar to  . The weight of the constrain equations in terms of the standard deviation can be estimated by means of Variance Component Estimation (VCE) if  estimateShortTimeVariations:estimateSigma  is set. The mathematical background of this co-estimation can be found in: Kvas, A., Mayer-Grr, T. GRACE gravity field recovery with background model uncertainties. J Geod 93, 25432552 (2019).  https://doi.org/10.1007/s00190-019-01314-1 .', 'config_table': 'outputfileSolution filename estimated parameter vector (static part only) outputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) outputfileParameterName filename estimated signal parameters (index is appended) estimateArcSigmas sequence  outputfileSigmasPerArcSst filename accuracies of each arc (SST) outputfileSigmasPerArcPod1 filename accuracies of each arc (POD1) outputfileSigmasPerArcPod2 filename accuracies of each arc (POD2) estimateEpochSigmas sequence  outputfileSigmasPerEpochSst filename accuracies of each epoch (SST) outputfileSigmasPerEpochPod1 filename accuracies of each epoch (POD1) outputfileSigmasPerEpochPod2 filename accuracies of each epoch (POD2) estimateCovarianceFunctions sequence  outputfileCovarianceFunctionSst filename covariance function outputfileCovarianceFunctionPod1 filename covariance functions for along, cross, radial direction outputfileCovarianceFunctionPod2 filename covariance functions for along, cross, radial direction estimateSstArcCovarianceSigmas sequence  outputfileSigmasCovarianceMatrixArc filename one variance factor per matrix computeResiduals sequence  outputfileSstResiduals filename  outputfilePod1Residuals filename  outputfilePod2Residuals filename  observation choice obervation equations (Sst) sstIntegral sequence integral approach inputfileSatelliteModel1 filename satellite macro model inputfileSatelliteModel2 filename satellite macro model rightHandSide sstRightSideType input for the reduced observation vector sstType choice  range   rangeRate   rangeAcceleration   none   inputfileOrbit1 filename used to evaluate the observation equations, not used as observations inputfileOrbit2 filename used to evaluate the observation equations, not used as observations inputfileStarCamera1 filename  inputfileStarCamera2 filename  earthRotation earthRotationType  ephemerides ephemeridesType  gradientfield gravityfieldType low order field to estimate the change of the gravity by position adjustement parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst parametrizationSatelliteTrackingType satellite tracking parameter keepSatelliteStates boolean set boundary values of each arc global integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n sstVariational sequence variational equations rightHandSide sequence input for observation vectors inputfileSatelliteTracking filename ranging observations and corrections inputfileOrbit1 filename kinematic positions of satellite A as observations inputfileOrbit2 filename kinematic positions of satellite B as observations sstType choice  range   rangeRate   none   inputfileVariational1 filename approximate position and integrated state matrix inputfileVariational2 filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst parametrizationSatelliteTrackingType satellite tracking parameter integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n covarianceSst sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovarianceMatrixArc filename Must be given per sst arc with correct dimensions. inputfileSigmasCovarianceMatrixArc filename Vector with one sigma for each <inputfileCovarianceMatrixArc> sampling double [seconds] sampling of the covariance function covariancePod1 sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovariancePodEpoch filename 3x3 epoch covariances sampling double [seconds] sampling of the covariance function covariancePod2 sequence  sigma double apriori factor of covariance function inputfileSigmasPerArc filename apriori different accuaries for each arc (multiplicated with sigma) inputfileSigmasPerEpoch filename apriori different accuaries for each epoch inputfileCovarianceFunction filename approximate covariances in time inputfileCovariancePodEpoch filename 3x3 epoch covariances sampling double [seconds] sampling of the covariance function estimateShortTimeVariations sequence co-estimate short time gravity field variations estimateSigma boolean estimate standard deviation via VCE autoregressiveModelSequence autoregressiveModelSequenceType AR model sequence for constraining short time gravity variations parameterSelection parameterSelectorType parameters describing the short time gravity field downweightPod double downweight factor for POD inputfileArcList filename list to correspond points of time to arc numbers iterationCount uint (maximum) number of iterations for the estimation of calibration parameter and error PSD variableNameIterations string All output fileNames in preprocessing iteration are expanded with this variable prior to writing to disk defaultBlockSize uint block size of static normal equation blocks', 'display_text': 'This program processes satellite-to-satellite-tracking (SST) and kinematic orbit observations in a GRACE like configuration. Three different observation groups are considered separately: SST and POD1/POD2 for the two satellites. This program works similar to <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>, see there for details. Here only deviations in the settings are explained.</p><p>Precise orbit data (POD) often contains systematic errors in addition to stochastic noise. In this case the variance component estimation fails and assigns too much weight to the POD data. Therefore an additional <strong class="groops-config-element">downweightPod</strong> factor can be applied to the standard deviation of POD for the next least squares adjustment in the iteration. This factor should also applied as <strong class="groops-config-element">sigma</strong> in <a class="groops-class" href="observationType.html">observation</a> for computation of the final solution e.g. with <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>.</p><p>Short time variations of the gravity field can be co-estimated together with the static/monthly mean gravity field. The short time parameters must also be set in <a class="groops-class" href="parametrizationGravityType.html">observation:parametrizationGravity</a> and can then be selected by <a class="groops-class" href="parameterSelectorType.html">estimateShortTimeVariations:parameterSelection</a>. If these parameters are not time variable, for example when a range of static parameters is selected, they are set up as constant for each time interval defined in <strong class="groops-config-element">inputfileArcList</strong>. The parameters are constrained by an <a class="groops-class" href="autoregressiveModelSequenceType.html">estimateShortTimeVariations:autoregressiveModelSequence</a>. The weight of the constrain equations in terms of the standard deviation can be estimated by means of Variance Component Estimation (VCE) if <strong class="groops-config-element">estimateShortTimeVariations:estimateSigma</strong> is set. The mathematical background of this co-estimation can be found in:</p><p>Kvas, A., Mayer-Grr, T. GRACE gravity field recovery with background model uncertainties. J Geod 93, 25432552 (2019). <a href="https://doi.org/10.1007/s00190-019-01314-1" target="_blank">https://doi.org/10.1007/s00190-019-01314-1</a>.'},
'PreprocessingVariationalEquation': { 'name': 'PreprocessingVariationalEquation', 'key': 'PreprocessingVariationalEquation', 'description': 'This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by  . This means for each arc new initial state parameters are setup. In a first step the   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by   acting on the satellite are evaluated at the apriori positions given by   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by  . Non-conservative forces like solar radiation pressure needs the orientation of the satellite (  This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by  ) and additional a satellite macro model ( satelliteModel ) with the surface properties. Furthermore   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by   observations are also considered. In a second step the accelerations are integrated twice to an dynamic orbit unsing a moving polynomial with the degree  integrationDegree . The orbit is corrected to be self-consistent. This means the forces should be evaluated at the new integrated positions instead of the apriori ones. This correction is computed in a linear approximation using the gradient of the forces with respect to the positions ( gradientfield ). As this term is small generally only the largest force components has to be considered. A low degree spherical harmonic expansion of the static gravity field (about up to degree 5) is sufficient in almost all cases. In this step also the state transition matrix (the partial derivatices of the current state, position and velocity) with respect to the initial state is computed. The integrated orbit together with the state transitions are stored in   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by  , the integrated orbit only in   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by  . To improve the numerical stability a reference ellipse can be reduced beforehand using Enke\'s method ( useEnke ). Mathematically the result is the same, but as the large central term is removed before and restored afterwards more digits are available for the computation. The integrated orbit should be fitted to observations afterwards by the programs  PreprocessingVariationalEquationOrbitFit  and/or  PreprocessingVariationalEquationSstFit . They apply a least squares adjustment by estimating some satellite parameters (e.g. an accelerometer bias). If the fitted orbit is to far away from the original   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by   the linearization may not be accurate enough. In this case  PreprocessingVariationalEquation  should be run again with the fitted orbit as   This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by   and introducing the  estimatedParameters  as additional forces.', 'config_table': 'outputfileVariational filename approximate position and integrated state matrix outputfileOrbit filename integrated orbit inputfileSatelliteModel filename satellite macro model inputfileOrbit filename approximate position, used to evaluate the force inputfileStarCamera filename rotation from body frame to CRF inputfileAccelerometer filename non-gravitational forces in satellite reference frame forces forcesType  estimatedParameters sequence satellite parameters e.g. from orbit fit parametrizationAcceleration parametrizationAccelerationType orbit force parameters inputfileParameter filename estimated orbit force parameters earthRotation earthRotationType  ephemerides ephemeridesType  gradientfield gravityfieldType low order field to estimate the change of the gravity by position adjustement integrationDegree uint integration of forces by polynomial approximation of degree n useEnke sequence integrate differential forces to an elliptical reference trajectory GM double geocentric gravitational constant used for elliptical reference orbit', 'display_text': 'This program integrates an orbit dynamically using the given forces and setup the state transition matrix for each time step. These are the prerequisite for a least squares adjustement (e.g. gravity field determination) using the variational equation approach. The variational equations are computed arc wise as defined by <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. This means for each arc new initial state parameters are setup.</p><p>In a first step the <a class="groops-class" href="forcesType.html">forces</a> acting on the satellite are evaluated at the apriori positions given by <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. Non-conservative forces like solar radiation pressure needs the orientation of the satellite (<a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>) and additional a satellite macro model (<strong class="groops-config-element">satelliteModel</strong>) with the surface properties. Furthermore <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> observations are also considered.</p><p>In a second step the accelerations are integrated twice to an dynamic orbit unsing a moving polynomial with the degree <strong class="groops-config-element">integrationDegree</strong>. The orbit is corrected to be self-consistent. This means the forces should be evaluated at the new integrated positions instead of the apriori ones. This correction is computed in a linear approximation using the gradient of the forces with respect to the positions (<strong class="groops-config-element">gradientfield</strong>). As this term is small generally only the largest force components has to be considered. A low degree spherical harmonic expansion of the static gravity field (about up to degree 5) is sufficient in almost all cases. In this step also the state transition matrix (the partial derivatices of the current state, position and velocity) with respect to the initial state is computed. The integrated orbit together with the state transitions are stored in <a class="groops-class" href="fileFormat_variationalEquation.html">outputfileVariational</a>, the integrated orbit only in <a class="groops-class" href="fileFormat_instrument.html">outputfileOrbit</a>.</p><p>To improve the numerical stability a reference ellipse can be reduced beforehand using Enke\'s method (<strong class="groops-config-element">useEnke</strong>). Mathematically the result is the same, but as the large central term is removed before and restored afterwards more digits are available for the computation.</p><p>The integrated orbit should be fitted to observations afterwards by the programs <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a> and/or <a class="groops-program" href="PreprocessingVariationalEquationSstFit.html">PreprocessingVariationalEquationSstFit</a>. They apply a least squares adjustment by estimating some satellite parameters (e.g. an accelerometer bias). If the fitted orbit is to far away from the original <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> the linearization may not be accurate enough. In this case <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a> should be run again with the fitted orbit as <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> and introducing the <strong class="groops-config-element">estimatedParameters</strong> as additional forces.'},
'PreprocessingVariationalEquationOrbitFit': { 'name': 'PreprocessingVariationalEquationOrbitFit', 'key': 'PreprocessingVariationalEquationOrbitFit', 'description': 'This program fits an   This program fits an   to an observed   This program fits an   by estimating parameters in a least squares adjustment. Additional to the initial satellite state for each arc, these parameters can be   This program fits an  , satellite   This program fits an   and stochastic pulses (velocity jumps) at given times,   This program fits an  . The estimated parameters can be stored with   This program fits an   and an extra file with the parameter names is created. The fitted orbit is written as new reference in   This program fits an   and additionally in   This program fits an  . The observed orbit positions (  This program fits an  ) together with the epoch wise covariance matrix (  This program fits an  ) must be splitted in the same arcs as the variational equations but not necessarily uniform distributed (use irregularData in  InstrumentSynchronize ). An iterative downweighting of outliers is performed by M-Huber method. The observation equations (parameter sensitity matrix) are computed by integration of the variational equations (  This program fits an  ) using a polynomial with  integrationDegree  and interpolated to the observation epochs using a polynomial with  interpolationDegree . All parameters used here must be reestimated in the full least squares adjustment for the gravity field determination to get a solution which is not biased towards the reference field. The solution of additional estimations are relative (deltas) as the parameters are already used as Taylor point in the reference orbit. See also  PreprocessingVariationalEquation .', 'config_table': 'outputfileVariational filename approximate position and integrated state matrix outputfileOrbit filename integrated orbit outputfileSolution filename estimated calibration and state parameters inputfileVariational filename approximate position and integrated state matrix inputfileOrbit filename kinematic positions of satellite as observations inputfileCovariancePodEpoch filename 3x3 epoch wise covariances ephemerides ephemeridesType may be needed by parametrizationAcceleration parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration parametrizationAccelerationType orbit force parameters stochasticPulse timeSeriesType  integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n iterationCount uint for the estimation of calibration parameter and error PSD', 'display_text': 'This program fits an <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a> to an observed <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> by estimating parameters in a least squares adjustment. Additional to the initial satellite state for each arc, these parameters can be <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>, satellite <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a> and stochastic pulses (velocity jumps) at given times, <a class="groops-class" href="timeSeriesType.html">stochasticPulse</a>. The estimated parameters can be stored with <a class="groops-class" href="fileFormat_matrix.html">outputfileSolution</a> and an extra file with the parameter names is created. The fitted orbit is written as new reference in <a class="groops-class" href="fileFormat_variationalEquation.html">outputfileVariational</a> and additionally in <a class="groops-class" href="fileFormat_instrument.html">outputfileOrbit</a>.</p><p>The observed orbit positions (<a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>) together with the epoch wise covariance matrix (<a class="groops-class" href="fileFormat_instrument.html">inputfileCovariancePodEpoch</a>) must be splitted in the same arcs as the variational equations but not necessarily uniform distributed (use irregularData in <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>). An iterative downweighting of outliers is performed by M-Huber method.</p><p>The observation equations (parameter sensitity matrix) are computed by integration of the variational equations (<a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a>) using a polynomial with <strong class="groops-config-element">integrationDegree</strong> and interpolated to the observation epochs using a polynomial with <strong class="groops-config-element">interpolationDegree</strong>.</p><p>All parameters used here must be reestimated in the full least squares adjustment for the gravity field determination to get a solution which is not biased towards the reference field. The solution of additional estimations are relative (deltas) as the parameters are already used as Taylor point in the reference orbit.</p><p>See also <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a>.'},
'PreprocessingVariationalEquationSstFit': { 'name': 'PreprocessingVariationalEquationSstFit', 'key': 'PreprocessingVariationalEquationSstFit', 'description': 'This program fits two   This program fits two   to satellite-to-satellite-tracking (SST) and orbit observations in a GRACE like configuration. It works similar to  PreprocessingVariationalEquationOrbitFit , see there for details. As the relative weighting of the observation types is important complex description of the covariances can be set with   This program fits two  ,   This program fits two  ,   This program fits two  .', 'config_table': 'outputfileVariational1 filename approximate position and integrated state matrix outputfileVariational2 filename approximate position and integrated state matrix outputfileOrbit1 filename integrated orbit outputfileOrbit2 filename integrated orbit outputfileSolution1 filename estimated calibration and state parameters outputfileSolution2 filename estimated calibration and state parameters rightHandSide sequence input for observation vectors inputfileSatelliteTracking filename ranging observations and corrections inputfileOrbit1 filename kinematic positions of satellite A as observations inputfileOrbit2 filename kinematic positions of satellite B as observations sstType choice  range   rangeRate   none   inputfileVariational1 filename approximate position and integrated state matrix inputfileVariational2 filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst parametrizationSatelliteTrackingType satellite tracking parameter integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n covarianceSst covarianceSstType covariance matrix of satellite to satellite tracking observations covariancePod1 covariancePodType covariance matrix of kinematic orbits (satellite 1) covariancePod2 covariancePodType covariance matrix of kinematic orbits (satellite 2) iterationCount uint for the estimation of calibration parameter and error PSD', 'display_text': 'This program fits two <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational1/2</a> to satellite-to-satellite-tracking (SST) and orbit observations in a GRACE like configuration. It works similar to <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>, see there for details.</p><p>As the relative weighting of the observation types is important complex description of the covariances can be set with <a class="groops-class" href="covarianceSstType.html">covarianceSst</a>, <a class="groops-class" href="covariancePodType.html">covariancePod1</a>, <a class="groops-class" href="covariancePodType.html">covariancePod2</a>.'},
'NoiseAccelerometer': { 'name': 'NoiseAccelerometer', 'key': 'NoiseAccelerometer', 'description': 'This program adds noise and biases to simulated  accelerometer data  generated by  SimulateAccelerometer . See   This program adds noise and biases to simulated   for details on noise generation.', 'config_table': 'outputfileAccelerometer filename  inputfileAccelerometer filename  biasAlong double [m/s**2] biasCross double [m/s**2] biasRadial double [m/s**2] noiseAlong noiseGeneratorType [m/s**2] noiseCross noiseGeneratorType [m/s**2] noiseRadial noiseGeneratorType [m/s**2]', 'display_text': 'This program adds noise and biases to simulated <a class="groops-file" href="fileFormat_instrument.html">accelerometer data</a> generated by <a class="groops-program" href="SimulateAccelerometer.html">SimulateAccelerometer</a>. See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise generation.'},
'NoiseGriddedData': { 'name': 'NoiseGriddedData', 'key': 'NoiseGriddedData', 'description': 'This program adds noise to  gridded data data . See   This program adds noise to   for details on noise generation.', 'config_table': 'outputfileGriddedData filename  inputfileGriddedData filename  noise noiseGeneratorType  startDataFields uint start countDataFields uint number of data fields (default: all after start)', 'display_text': 'This program adds noise to <a class="groops-file" href="fileFormat_griddedData.html">gridded data data</a>. See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise generation.'},
'NoiseInstrument': { 'name': 'NoiseInstrument', 'key': 'NoiseInstrument', 'description': 'This program adds noise to  instrument data . See   This program adds noise to   for details on noise generation.', 'config_table': 'outputfileInstrument filename  inputfileInstrument filename  noise noiseGeneratorType  startDataFields uint start countDataFields uint number of data fields (default: all after start)', 'display_text': 'This program adds noise to <a class="groops-file" href="fileFormat_instrument.html">instrument data</a>. See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise generation.'},
'NoiseNormalsSolution': { 'name': 'NoiseNormalsSolution', 'key': 'NoiseNormalsSolution', 'description': 'The inverse of the normal matrix of   The inverse of the normal matrix of   represents the covariance matrix of the estimated parameters. This program generates a noise vector with  if generated input noise is standard white noise. The noise vector is computed with  where   is the generated   The inverse of the normal matrix of   and   is the cholesky upper triangle matrix of the normal matrix  .', 'config_table': 'outputfileNoise filename generated noise as matrix: parameterCount x sampleCount inputfileNormalEquation filename  noise noiseGeneratorType  sampleCount uint number of samples to be generated useEigenvalueDecomposition boolean use eigenvalue decomposition', 'display_text': 'The inverse of the normal matrix of <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a> represents the covariance matrix of the estimated parameters. This program generates a noise vector with \\[ \\M\\Sigma(\\M e) = \\M N^{-1}, \\]if generated input noise is standard white noise.</p><p>The noise vector is computed with \\[ \\M e = \\M W^{-T} \\M z, \\]where $\\M z$ is the generated <a class="groops-class" href="noiseGeneratorType.html">noise</a> and $\\M W$ is the cholesky upper triangle matrix of the normal matrix $\\M N=\\M W^T\\M W$.'},
'NoiseOrbit': { 'name': 'NoiseOrbit', 'key': 'NoiseOrbit', 'description': 'This program adds noise to simulated  satellite \'s positions and velocities generated by  SimulateOrbit  (along, cross, radial). See   This program adds noise to simulated   for details on noise options.', 'config_table': 'outputfileOrbit filename  inputfileOrbit filename  noisePosition noiseGeneratorType along, cross, radial [m] noiseVelocity noiseGeneratorType along, cross, radial [m/s]', 'display_text': 'This program adds noise to simulated <a class="groops-file" href="fileFormat_instrument.html">satellite</a>\'s positions and velocities generated by <a class="groops-program" href="SimulateOrbit.html">SimulateOrbit</a> (along, cross, radial). See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise options.'},
'NoiseSatelliteTracking': { 'name': 'NoiseSatelliteTracking', 'key': 'NoiseSatelliteTracking', 'description': 'This program adds noise to simulated satellite tracking data generated by  SimulateSatelliteTracking . See   This program adds noise to simulated satellite tracking data generated by   for details on noise generation.', 'config_table': 'outputfileSatelliteTracking filename  inputfileSatelliteTracking filename  noiseRange noiseGeneratorType [m] noiseRangeRate noiseGeneratorType [m/s] noiseRangeAcceleration noiseGeneratorType [m/s^2]', 'display_text': 'This program adds noise to simulated satellite tracking data generated by <a class="groops-program" href="SimulateSatelliteTracking.html">SimulateSatelliteTracking</a>. See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise generation.'},
'NoiseStarCamera': { 'name': 'NoiseStarCamera', 'key': 'NoiseStarCamera', 'description': 'This program adds noise to rotation observations. The noise is computed via a pseudo random sequence. See   This program adds noise to rotation observations. The noise is computed via a pseudo random sequence. See   for details on noise options.', 'config_table': 'outputfileStarCamera filename  inputfileStarCamera filename  noiseRoll noiseGeneratorType [rad] noisePitch noiseGeneratorType [rad] noiseYaw noiseGeneratorType [rad]', 'display_text': 'This program adds noise to rotation observations. The noise is computed via a pseudo random sequence. See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise options.'},
'NoiseTimeSeries': { 'name': 'NoiseTimeSeries', 'key': 'NoiseTimeSeries', 'description': 'This program generates   This program generates   with the requested characteristics. See   This program generates   for details on noise options.', 'config_table': 'outputfileNoise filename  outputfileCovarianceFunction filename  noise noiseGeneratorType  timeSeries timeSeriesType  columns uint number of noise series (columns)', 'display_text': 'This program generates <a class="groops-class" href="fileFormat_instrument.html">outputfileNoise</a> with the requested characteristics. See <a class="groops-class" href="noiseGeneratorType.html">noiseGenerator</a> for details on noise options.'},
'SimulateAccelerometer': { 'name': 'SimulateAccelerometer', 'key': 'SimulateAccelerometer', 'description': 'This program simulate  accelerometer data . The orientation of the accelerometer is given by   This program simulate   otherwise the celestial reference frame (CRF) is used. For computation of non-conservative forces a   This program simulate   is needed.', 'config_table': 'outputfileAccelerometer filename  inputfileSatelliteModel filename satellite macro model inputfileOrbit filename  inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  forces forcesType', 'display_text': 'This program simulate <a class="groops-file" href="fileFormat_instrument.html">accelerometer data</a>. The orientation of the accelerometer is given by <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> otherwise the celestial reference frame (CRF) is used. For computation of non-conservative forces a <a class="groops-class" href="fileFormat_satelliteModel.html">satelliteModel</a> is needed.'},
'SimulateAccelerometerCoMOffset': { 'name': 'SimulateAccelerometerCoMOffset', 'key': 'SimulateAccelerometerCoMOffset', 'description': 'This program generates an  accelerometer file  containing perturbing accelerations due to a given center of mass (CoM) offset. This includes centrifugal effects, Euler forces and the effect of gravity gradients.', 'config_table': 'outputfileAccelerometer filename effect of offset inputfileOrbit filename  inputfileStarCamera filename  applyAngularRate boolean compute effect of centrifugal forces applyAngularAccelerations boolean compute effect of Euler forces gradientfield gravityfieldType low order field to estimate the change of the gravity by position adjustement earthRotation earthRotationType  interpolationDegree uint derivation of quaternions by polynomial interpolation of degree n CoMOffsetX double offset [m] CoMOffsetY double offset [m] CoMOffsetZ double offset [m]', 'display_text': 'This program generates an <a class="groops-file" href="fileFormat_instrument.html">accelerometer file</a> containing perturbing accelerations due to a given center of mass (CoM) offset. This includes centrifugal effects, Euler forces and the effect of gravity gradients.'},
'SimulateGradiometer': { 'name': 'SimulateGradiometer', 'key': 'SimulateGradiometer', 'description': 'This program simulates error free  gradiometer data  along a satellite\'s orbit. The orientation of the full tensor gradiometer is given by   This program simulates error free   otherwise the celestial reference frame (CRF) is used. The gravity gradients are given by   This program simulates error free   and   This program simulates error free  .', 'config_table': 'outputfileGradiometer filename  inputfileOrbit filename  inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  gravityfield gravityfieldType  tides tidesType', 'display_text': 'This program simulates error free <a class="groops-file" href="fileFormat_instrument.html">gradiometer data</a> along a satellite\'s orbit. The orientation of the full tensor gradiometer is given by <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> otherwise the celestial reference frame (CRF) is used. The gravity gradients are given by <a class="groops-class" href="gravityfieldType.html">gravityfield</a> and <a class="groops-class" href="tidesType.html">tides</a>.'},
'SimulateKeplerOrbit': { 'name': 'SimulateKeplerOrbit', 'key': 'SimulateKeplerOrbit', 'description': 'This program simulates a Keplerian  orbit  at a given  timeSeries  starting from the given  integrationConstants .', 'config_table': 'outputfileOrbit filename  timeSeries timeSeriesType  GM double Geocentric gravitational constant integrationConstants choice  kepler sequence  majorAxis double [m] eccentricity double [-] inclination angle [degree] ascendingNode angle [degree] argumentOfPerigee angle [degree] meanAnomaly angle [degree] time time integration constants are valid at this epoch positionAndVelocity sequence  position0x double [m] in CRF position0y double [m] in CRF position0z double [m] in CRF velocity0x double [m/s] velocity0y double [m/s] velocity0z double [m/s] time time integration constants are valid at this epoch', 'display_text': 'This program simulates a Keplerian <a class="groops-file" href="fileFormat_instrument.html">orbit</a> at a given <strong class="groops-config-element">timeSeries</strong> starting from the given <strong class="groops-config-element">integrationConstants</strong>.'},
'SimulateOrbit': { 'name': 'SimulateOrbit', 'key': 'SimulateOrbit', 'description': 'This program integrates an  orbit  from a given force function (dynamic orbit). The force functions are given by   This program integrates an  . For computation of non-conservative forces a  satelliteModel  is needed. The integration method must be selected with   This program integrates an  . Because the orbit data are calculated in the celestial reference frame (CRF) you need   This program integrates an   to transform the force function from the terrestrial reference frame (TRF). The integration start and end time, as well as the sampling, are derived from the  timeSeries  option. It is possible to integrate the arc in  reverse , where the initial conditions are assumed to be met at the end time of the  timeSeries .', 'config_table': 'outputfileOrbit filename orbit file to be written. inputfileSatelliteModel filename satellite macro model timeSeries timeSeriesType time points for simulated orbit epochs. integrationConstants choice  kepler sequence  majorAxis double [m] eccentricity double [-] inclination angle [degree] ascendingNode angle [degree] argumentOfPerigee angle [degree] meanAnomaly angle [degree] GM double Geocentric gravitational constant positionAndVelocity sequence  position0x double [m] in CRF position0y double [m] in CRF position0z double [m] in CRF velocity0x double [m/s] velocity0y double [m/s] velocity0z double [m/s] file sequence  inputfileOrbit filename only epoch at timeStart is used margin double [seconds] used when finding initial epoch in orbitFile propagator orbitPropagatorType orbit propagation method. earthRotation earthRotationType  ephemerides ephemeridesType  forces forcesType considered in orbit propagation. reverse boolean start integration at last epoch in timeSeries, going backward in time.', 'display_text': 'This program integrates an <a class="groops-file" href="fileFormat_instrument.html">orbit</a> from a given force function (dynamic orbit). The force functions are given by <a class="groops-class" href="forcesType.html">forces</a>. For computation of non-conservative forces a <a class="groops-file" href="fileFormat_satelliteModel.html">satelliteModel</a> is needed. The integration method must be selected with <a class="groops-class" href="orbitPropagatorType.html">propagator</a>. Because the orbit data are calculated in the celestial reference frame (CRF) you need <a class="groops-class" href="earthRotationType.html">earthRotation</a> to transform the force function from the terrestrial reference frame (TRF). The integration start and end time, as well as the sampling, are derived from the <strong class="groops-config-element">timeSeries</strong> option. It is possible to integrate the arc in <strong class="groops-config-element">reverse</strong>, where the initial conditions are assumed to be met at the end time of the <strong class="groops-config-element">timeSeries</strong>.'},
'SimulateSatelliteTracking': { 'name': 'SimulateSatelliteTracking', 'key': 'SimulateSatelliteTracking', 'description': 'This program simulates  tracking data  (range, range-rate, range-accelerations) between 2 satellites. The range is given by  with   and the unit vector in line of sight (LOS) direction  Range-rates   and range accelrations   are obtained by differentation  with the derivative of the unit vector  The   This program simulates  s must contain positions, velocities, and acceleration (see  OrbitAddVelocityAndAcceleration ).', 'config_table': 'outputfileSatelliteTracking filename  inputfileOrbit1 filename  inputfileOrbit2 filename', 'display_text': 'This program simulates <a class="groops-file" href="fileFormat_instrument.html">tracking data</a> (range, range-rate, range-accelerations) between 2 satellites. The range is given by \\[ \\rho(t) = \\left\\lVert{\\M r_B(t) - \\M r_A(t)}\\right\\rVert = \\M e_{AB}(t)\\cdot\\M r_{AB}(t), \\]with $\\M r_{AB} = \\M r_B - \\M r_A$ and the unit vector in line of sight (LOS) direction \\[\\label{sst.los} \\M e_{AB} = \\frac{\\M r_{AB}}{\\left\\lVert{\\M r_{AB}}\\right\\rVert}=\\frac{\\M r_{AB}}{\\rho}. \\]Range-rates $\\dot{\\rho}$ and range accelrations $\\ddot{\\rho}$ are obtained by differentation \\[\\label{obsRangeRate} \\dot{\\rho}  = \\M e_{AB}\\cdot\\dot{\\M r}_{AB} + \\dot{\\M e}_{AB}\\cdot\\M r_{AB}             = \\M e_{AB}\\cdot\\dot{\\M r}_{AB}, \\]\\[\\label{obsRangeAccl} \\begin{split} \\ddot{\\rho} &= \\M e_{AB}\\cdot\\ddot{\\M r}_{AB} +\\dot{\\M e}_{AB}\\cdot\\dot{\\M r}_{AB}             = \\M e_{AB}\\cdot\\ddot{\\M r}_{AB} +    \\frac{1}{\\rho}\\left(\\dot{\\M r}_{AB}^2-\\dot{\\rho}^2\\right). \\\\ \\end{split} \\]with the derivative of the unit vector \\[ \\dot{\\M e}_{AB}=\\frac{d}{dt}\\left(\\frac{\\M r_{AB}}{\\rho}\\right) =\\frac{\\dot{\\M r}_{AB}}{\\rho}-\\frac{\\dot{\\rho}\\cdot\\M r_{AB}}{\\rho^2} =\\frac{1}{\\rho}\\left({\\dot{\\M r}_{AB}-\\dot{\\rho}\\cdot\\M e_{AB}}\\right). \\]The <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>s must contain positions, velocities, and acceleration (see <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a>).'},
'SimulateStarCamera': { 'name': 'SimulateStarCamera', 'key': 'SimulateStarCamera', 'description': 'This program simulates  star camera  measurements at each satellite\'s position. The satellite\'s orientation follows a local orbit frame with the x-axis in along track (along velocity), y-axis is cross track (normal to position and velocity vector) and z-axis pointing nadir (negative position vector). As for non circular orbit the position and velocity are not exact normal, the default is the x-axis to be exact along velocity and the z-axis forms a right hand system (not exact nadir) or with  nadirPointing  the z-axis is exact nadir and x-axis approximates along. The resulting rotation matrices rotate from satellite frame to inertial frame.', 'config_table': 'outputfileStarCamera filename rotation from satellite to inertial frame (x: along, y: cross, z: nadir) inputfileOrbit filename position and velocity defines the orientation of the satellite at each epoch nadirPointing boolean false: exact along and nearly nadir, true: nearly along and exact nadir', 'display_text': 'This program simulates <a class="groops-file" href="fileFormat_instrument.html">star camera</a> measurements at each satellite\'s position. The satellite\'s orientation follows a local orbit frame with the x-axis in along track (along velocity), y-axis is cross track (normal to position and velocity vector) and z-axis pointing nadir (negative position vector). As for non circular orbit the position and velocity are not exact normal, the default is the x-axis to be exact along velocity and the z-axis forms a right hand system (not exact nadir) or with <strong class="groops-config-element">nadirPointing</strong> the z-axis is exact nadir and x-axis approximates along. The resulting rotation matrices rotate from satellite frame to inertial frame.'},
'SimulateStarCameraGnss': { 'name': 'SimulateStarCameraGnss', 'key': 'SimulateStarCameraGnss', 'description': 'This program simulates  star camera  measurements at each satellite position of   This program simulates  . The resulting rotation matrices rotate from body frame to inertial frame. The body frame refers to the IGS-specific (not the manufacturer-specific) body frame, as described by  . The   This program simulates   must contain velocities (use  OrbitAddVelocityAndAcceleration  if needed). Information about the attitude mode(s) used by the GNSS satellite may be provided via   This program simulates  . This file can be created with  GnssAttitudeInfoCreate . It contains one or more time-dependent entries, each defining the default attitude mode, the attitude modes used around orbit noon and midnight, and some parameters required by the various modes. If no   This program simulates   is selected, the program defaults to a nominal yaw-steering attitude model. A sufficiently high  modelingResolution  ensures that the attitude behavior is modeled properly at all times. The attitude behavior is defined by the respective mode. Here is a list of the supported modes with a brief explanation and references:    nominalYawSteering :       Yaw to keep solar panels aligned to Sun (e.g. most GNSS satellites outside eclipse) [1]  orbitNormal :       Keep fixed yaw angle, for example point X-axis in flight direction (e.g. BDS-2G, BDS-3G, QZS-2G) [1]  catchUpYawSteering :       Yaw at maximum yaw rate to catch up to nominal yaw angle (e.g. GPS-* (noon), GPS-IIR (midnight)) [2, 3]  shadowMaxYawSteeringAndRecovery :       Yaw at maximum yaw rate from shadow start to end, recover after shadow (e.g. GPS-IIA (midnight)) [2]  shadowMaxYawSteeringAndStop :       Yaw at maximum yaw rate from shadow start until nominal yaw angle at shadow end is reached,       then stop (e.g. GLO-M (midnight)) [4]  shadowConstantYawSteering :       Yaw at constant yaw rate from shadow start to end (e.g. GPS-IIF (midnight)) [3]  centeredMaxYawSteering :       Yaw at maximum yaw rate centered around noon/midnight (e.g. QZS-2I, GLO-M (noon)) [4, 8]  smoothedYawSteering1 :       Yaw based on an auxiliary Sun vector for a smooth yaw maneuver (e.g. GAL-1) [5]  smoothedYawSteering2 :       Yaw based on a modified yaw-steering law for a smooth yaw maneuver (e.g. GAL-2, BDS-3M, BDS-3I) [5, 6]  betaDependentOrbitNormal :       Switch to orbit normal mode if below beta angle threshold (e.g. BDS-2M, BDS-2I, QZS-1) [7, 8]  See  GnssAttitudeInfoCreate  for more details on which satellite uses which attitude modes and the required parameters for each mode. References for the attitude modes:            https://www.gsc-europa.eu/support-to-developers/galileo-satellite-metadata#3       https://qzss.go.jp/en/technical/qzssinfo/index.html', 'config_table': 'outputfileStarCamera filename rotation from body frame to CRF inputfileOrbit filename attitude is modeled based on this orbit inputfileAttitudeInfo filename attitude modes used by the satellite and respective parameters interpolationDegree uint polynomial degree for orbit interpolation modelingResolution double [s] resolution for attitude model evaluation ephemerides ephemeridesType  eclipse eclipseType model to determine if satellite is in Earth\'s shadow', 'display_text': 'This program simulates <a class="groops-file" href="fileFormat_instrument.html">star camera</a> measurements at each satellite position of <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. The resulting rotation matrices rotate from body frame to inertial frame. The body frame refers to the IGS-specific (not the manufacturer-specific) body frame, as described by <a href="https://doi.org/10.1016/j.asr.2015.06.019">Montenbruck et al. (2015)</a>. The <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> must contain velocities (use <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a> if needed).</p><p>Information about the attitude mode(s) used by the GNSS satellite may be provided via <a class="groops-class" href="fileFormat_instrument.html">inputfileAttitudeInfo</a>. This file can be created with <a class="groops-program" href="GnssAttitudeInfoCreate.html">GnssAttitudeInfoCreate</a>. It contains one or more time-dependent entries, each defining the default attitude mode, the attitude modes used around orbit noon and midnight, and some parameters required by the various modes. If no <a class="groops-class" href="fileFormat_instrument.html">inputfileAttitudeInfo</a> is selected, the program defaults to a nominal yaw-steering attitude model. A sufficiently high <strong class="groops-config-element">modelingResolution</strong> ensures that the attitude behavior is modeled properly at all times.</p><p>The attitude behavior is defined by the respective mode. Here is a list of the supported modes with a brief explanation and references: <ul>  <li><b>nominalYawSteering</b>:       Yaw to keep solar panels aligned to Sun (e.g. most GNSS satellites outside eclipse) [1] </li><li> <b>orbitNormal</b>:       Keep fixed yaw angle, for example point X-axis in flight direction (e.g. BDS-2G, BDS-3G, QZS-2G) [1] </li><li> <b>catchUpYawSteering</b>:       Yaw at maximum yaw rate to catch up to nominal yaw angle (e.g. GPS-* (noon), GPS-IIR (midnight)) [2, 3] </li><li> <b>shadowMaxYawSteeringAndRecovery</b>:       Yaw at maximum yaw rate from shadow start to end, recover after shadow (e.g. GPS-IIA (midnight)) [2] </li><li> <b>shadowMaxYawSteeringAndStop</b>:       Yaw at maximum yaw rate from shadow start until nominal yaw angle at shadow end is reached,       then stop (e.g. GLO-M (midnight)) [4] </li><li> <b>shadowConstantYawSteering</b>:       Yaw at constant yaw rate from shadow start to end (e.g. GPS-IIF (midnight)) [3] </li><li> <b>centeredMaxYawSteering</b>:       Yaw at maximum yaw rate centered around noon/midnight (e.g. QZS-2I, GLO-M (noon)) [4, 8] </li><li> <b>smoothedYawSteering1</b>:       Yaw based on an auxiliary Sun vector for a smooth yaw maneuver (e.g. GAL-1) [5] </li><li> <b>smoothedYawSteering2</b>:       Yaw based on a modified yaw-steering law for a smooth yaw maneuver (e.g. GAL-2, BDS-3M, BDS-3I) [5, 6] </li><li> <b>betaDependentOrbitNormal</b>:       Switch to orbit normal mode if below beta angle threshold (e.g. BDS-2M, BDS-2I, QZS-1) [7, 8] </li></ul> </p><p></p><p>See <a class="groops-program" href="GnssAttitudeInfoCreate.html">GnssAttitudeInfoCreate</a> for more details on which satellite uses which attitude modes and the required parameters for each mode.</p><p>References for the attitude modes: <ol>  <li><a href="https://doi.org/10.1016/j.asr.2015.06.019">Montenbruck et al. (2015)</a> </li><li> <a href="https://doi.org/10.1007/s10291-008-0092-1">Kouba (2009)</a> </li><li> <a href="https://doi.org/10.1007/s10291-016-0562-9">Kuang et al. (2017)</a> </li><li> <a href="https://doi.org/10.1016/j.asr.2010.09.007">Dilssner et al. (2011)</a> </li><li> <a href="https://www.gsc-europa.eu/support-to-developers/galileo-satellite-metadata#3" target="_blank">https://www.gsc-europa.eu/support-to-developers/galileo-satellite-metadata#3</a> </li><li> <a href="https://doi.org/10.1007/s10291-018-0783-1">Wang et al. (2018)</a> </li><li> <a href="https://doi.org/10.1017/S0373463318000103">Li et al. (2018)</a> </li><li> <a href="https://qzss.go.jp/en/technical/qzssinfo/index.html" target="_blank">https://qzss.go.jp/en/technical/qzssinfo/index.html</a> </li></ol>'},
'SimulateStarCameraGrace': { 'name': 'SimulateStarCameraGrace', 'key': 'SimulateStarCameraGrace', 'description': 'Simulates  star camera data  of the two GRACE satellites.    x: the antenna center pointing to the other satellite.  y: normal to line of sight and the radial direction.  z: forms a right handed system.', 'config_table': 'outputfileStarCamera1 filename  outputfileStarCamera2 filename  inputfileOrbit1 filename position define the orientation of the satellite at each epoch inputfileOrbit2 filename position define the orientation of the satellite at each epoch antennaCenters choice KBR antenna phase center value sequence  center1X double x-coordinate of antenna position in SRF [m] for GRACEA center1Y double y-coordinate of antenna position in SRF [m] for GRACEA center1Z double z-coordinate of antenna position in SRF [m] for GRACEA center2X double x-coordinate of antenna position in SRF [m] for GRACEB center2Y double y-coordinate of antenna position in SRF [m] for GRACEB center2Z double z-coordinate of antenna position in SRF [m] for GRACEB file sequence  inputAntennaCenters filename', 'display_text': 'Simulates <a class="groops-file" href="fileFormat_instrument.html">star camera data</a> of the two GRACE satellites. <ul>  <li>x: the antenna center pointing to the other satellite. </li><li> y: normal to line of sight and the radial direction. </li><li> z: forms a right handed system. </li></ul>'},
'SimulateStarCameraSentinel1': { 'name': 'SimulateStarCameraSentinel1', 'key': 'SimulateStarCameraSentinel1', 'description': 'This program simulates  star camera  measurements at each satellite\'s position for the Sentinel 1A satellite. The   This program simulates   must contain positions and velocities (see  OrbitAddVelocityAndAcceleration ). The resulting rotation matrices rotate from satellite frame to inertial frame.', 'config_table': 'outputfileStarCamera filename  inputfileOrbit filename position and velocity defines the orientation of the satellite at each epoch', 'display_text': 'This program simulates <a class="groops-file" href="fileFormat_instrument.html">star camera</a> measurements at each satellite\'s position for the Sentinel 1A satellite. The <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a> must contain positions and velocities (see <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a>). The resulting rotation matrices rotate from satellite frame to inertial frame.'},
'FileConvert': { 'name': 'FileConvert', 'key': 'FileConvert', 'description': 'Converts GROOPS file between different file formats (ASCII, XML, binary), see  file formats  for details. It prints also some information about the content. Therefore it can be used to get an idea about the content of binary files.', 'config_table': 'outputfile filename GROOPS formats: .xml, .txt, .dat inputfile filename GROOPS formats: .xml, .txt, .dat', 'display_text': 'Converts GROOPS file between different file formats (ASCII, XML, binary), see <a class="groops-ref" href="general.fileFormat.html">file formats</a> for details. It prints also some information about the content. Therefore it can be used to get an idea about the content of binary files.'},
'FileCreateDirectories': { 'name': 'FileCreateDirectories', 'key': 'FileCreateDirectories', 'description': 'Creates the directory and parent directories as needed.', 'config_table': 'directory filename', 'display_text': 'Creates the directory and parent directories as needed.'},
'FileMove': { 'name': 'FileMove', 'key': 'FileMove', 'description': 'Move/rename file or directory. If the  outputfile  is an existing directory the  inputfile  is moved into it.', 'config_table': 'outputfile filename target name or directory for the move/rename inputfile filename', 'display_text': 'Move/rename file or directory. If the <strong class="groops-config-element">outputfile</strong> is an existing directory the <strong class="groops-config-element">inputfile</strong> is moved into it.'},
'FileRemove': { 'name': 'FileRemove', 'key': 'FileRemove', 'description': 'Remove files or directories. Deletes also the content recursivley if one of  files  is a directory.', 'config_table': 'files filename', 'display_text': 'Remove files or directories. Deletes also the content recursivley if one of <strong class="groops-config-element">files</strong> is a directory.'},
'FileTextCreate': { 'name': 'FileTextCreate', 'key': 'FileTextCreate', 'description': 'Create text  outputfile  containing  line s. This program can be a powerful tool, if the  line  is repeated with a   Create text   together with the  text parser .', 'config_table': 'outputfile filename  line string', 'display_text': 'Create text <strong class="groops-config-element">outputfile</strong> containing <strong class="groops-config-element">line</strong>s. This program can be a powerful tool, if the <strong class="groops-config-element">line</strong> is repeated with a <a class="groops-class" href="loopType.html">loop</a> together with the <a class="groops-ref" href="general.parser.html#text">text parser</a>.'},
'GroupPrograms': { 'name': 'GroupPrograms', 'key': 'GroupPrograms', 'description': 'Runs  program s in a group, which can be used to structure a config file. If  catchErrors  is enabled and an error occurs, the remaining  program s are skipped and execution continues with  errorProgram s, in case any are defined. Otherwise an exception is thrown. The  silently  option disables the screen ouput of the  program s. With  outputfileLog  a log file is written for this group additional to a global log file. This might be helpful within  LoopPrograms  with parallel iterations.', 'config_table': 'outputfileLog filename additional log file silently boolean without showing the output. program programType  catchErrors sequence  errorProgram programType executed if an error occured', 'display_text': 'Runs <strong class="groops-config-element">program</strong>s in a group, which can be used to structure a config file. If <strong class="groops-config-element">catchErrors</strong> is enabled and an error occurs, the remaining <strong class="groops-config-element">program</strong>s are skipped and execution continues with <strong class="groops-config-element">errorProgram</strong>s, in case any are defined. Otherwise an exception is thrown.</p><p>The <strong class="groops-config-element">silently</strong> option disables the screen ouput of the <strong class="groops-config-element">program</strong>s. With <strong class="groops-config-element">outputfileLog</strong> a log file is written for this group additional to a global log file. This might be helpful within <a class="groops-program" href="LoopPrograms.html">LoopPrograms</a> with parallel iterations.'},
'IfPrograms': { 'name': 'IfPrograms', 'key': 'IfPrograms', 'description': 'Runs a list of  program s if a   Runs a list of   is met. Otherwise  elseProgram s are executed.', 'config_table': 'condition conditionType  program programType executed if condition evaluates to true elseProgram programType executed if condition evaluates to false', 'display_text': 'Runs a list of <strong class="groops-config-element">program</strong>s if a <a class="groops-class" href="conditionType.html">condition</a> is met. Otherwise <strong class="groops-config-element">elseProgram</strong>s are executed.'},
'LoopPrograms': { 'name': 'LoopPrograms', 'key': 'LoopPrograms', 'description': 'This program runs a list of programs in a   This program runs a list of programs in a  . If  continueAfterError = yes  and an error occurs, the remaining programs in the current iteration are skipped and the loop continues with the next iteration. Otherwise an exception is thrown. If this program is executed on multiple processing nodes, the iterations can be computed in parallel, see  parallelization . The first process serves as load balancer and the other processes are assigned to iterations according to  processCountPerIteration . For example, running a loop containing three iterations on 13 processes with  processCountPerIteration = 4 , runs the three iterations in parallel, with each iteration being assigned four processes. With  parallelLog = yes  all processes write output to screen and the log file. As the output can be quite confusing in this case, running  GroupPrograms  with an extra  outputfileLog  for each iteration (use the loop variables for the name of the log files) might be helpful.', 'config_table': 'loop loopType subprograms are called for every iteration continueAfterError boolean continue with next iteration after error, otherwise throw exception processCountPerIteration uint 0: use all processes for each iteration parallelLog boolean write to screen/log file from all processing nodes in parallelized loops program programType', 'display_text': 'This program runs a list of programs in a <a class="groops-class" href="loopType.html">loop</a>.</p><p>If <strong class="groops-config-element">continueAfterError</strong>=<code>yes</code> and an error occurs, the remaining programs in the current iteration are skipped and the loop continues with the next iteration. Otherwise an exception is thrown.</p><p>If this program is executed on multiple processing nodes, the iterations can be computed in parallel, see <a class="groops-ref" href="general.parallelization.html">parallelization</a>. The first process serves as load balancer and the other processes are assigned to iterations according to <strong class="groops-config-element">processCountPerIteration</strong>. For example, running a loop containing three iterations on 13 processes with <strong class="groops-config-element">processCountPerIteration</strong>=<code>4</code>, runs the three iterations in parallel, with each iteration being assigned four processes. With <strong class="groops-config-element">parallelLog</strong>=<code>yes</code> all processes write output to screen and the log file. As the output can be quite confusing in this case, running <a class="groops-program" href="GroupPrograms.html">GroupPrograms</a> with an extra <strong class="groops-config-element">outputfileLog</strong> for each iteration (use the loop variables for the name of the log files) might be helpful.'},
'RunCommand': { 'name': 'RunCommand', 'key': 'RunCommand', 'description': 'Execute system  command s. If  executeParallel  is set and multiple  command s are given they are executed in parallel at distributed nodes, otherwise they are executed consecutively at master node only.', 'config_table': 'command filename  silently boolean without showing the output. continueAfterError boolean continue with next command after error, otherwise throw exception executeParallel boolean execute several commands in parallel', 'display_text': 'Execute system <strong class="groops-config-element">command</strong>s. If <strong class="groops-config-element">executeParallel</strong> is set and multiple <strong class="groops-config-element">command</strong>s are given they are executed in parallel at distributed nodes, otherwise they are executed consecutively at master node only.'},
'BerneseKinematic2Orbit': { 'name': 'BerneseKinematic2Orbit', 'key': 'BerneseKinematic2Orbit', 'description': 'Read kinematic orbits in Bernese format.', 'config_table': 'outputfileOrbit filename  outputfileCovariance filename  earthRotation earthRotationType from TRF to CRF inputfile filename', 'display_text': 'Read kinematic orbits in Bernese format.'},
'Champ2AccStar': { 'name': 'Champ2AccStar', 'key': 'Champ2AccStar', 'description': 'This program reads in CHAMP accelerometer and star camera data given in the special CHAMP format. In case of CHAMP accelerometer and star camera data is both stored in one file. A description of the format can be found under:  http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf .', 'config_table': 'outputfileAccelerometer filename  outputfileAngularAcceleration filename  outputfileStarCamera filename  inputfile filename', 'display_text': 'This program reads in CHAMP accelerometer and star camera data given in the special CHAMP format. In case of CHAMP accelerometer and star camera data is both stored in one file. A description of the format can be found under: <a href="http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf" target="_blank">http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf</a>.'},
'Champ2Orbit': { 'name': 'Champ2Orbit', 'key': 'Champ2Orbit', 'description': 'This program reads in CHAMP precise science orbits in the special CHORB format. A description of the format can be found under:  http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-002.pdf', 'config_table': 'outputfileOrbit filename  earthRotation earthRotationType  timeSeries timeSeriesType  inputOrbit sequence  inputfile filename orbits in SP3 format', 'display_text': 'This program reads in CHAMP precise science orbits in the special CHORB format. A description of the format can be found under: <a href="http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-002.pdf" target="_blank">http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-002.pdf</a>'},
'Cosmic2OrbitStar': { 'name': 'Cosmic2OrbitStar', 'key': 'Cosmic2OrbitStar', 'description': 'This program reads in cosmic orbit and star camera data given in the CHAMP format. In case of cosmic orbit and star camera data is stored in one file. A description of the format can be found under:  http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf', 'config_table': 'outputfileOrbit filename  outputfileStarCamera filename  inputfile filename', 'display_text': 'This program reads in cosmic orbit and star camera data given in the CHAMP format. In case of cosmic orbit and star camera data is stored in one file. A description of the format can be found under: <a href="http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf" target="_blank">http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf</a>'},
'DoodsonAdmittance2SupplementaryFiles': { 'name': 'DoodsonAdmittance2SupplementaryFiles', 'key': 'DoodsonAdmittance2SupplementaryFiles', 'description': 'The publication of an ocean tide model includes not only the atlas in the form of spherical harmonics coefficients, but also the matrix of Doodson multipliers ( outputfileDoodsonMatrix ) and the  outputfileAdmittanceMatrix . The  outputfileMajorTideList  contains the  fileNames  for each contituent. The required information is taken from the   The publication of an ocean tide model includes not only the atlas in the form of spherical harmonics coefficients, but also the matrix of Doodson multipliers ( . See also  DoodsonHarmonics2PotentialCoefficients .', 'config_table': 'outputfileMajorTideList filename  fileNames filename template for fileList, variables: doodson, name, cossin outputfileDoodsonMatrix filename  outputfileAdmittanceMatrix filename  inputfileAdmittance filename interpolation of minor constituents', 'display_text': 'The publication of an ocean tide model includes not only the atlas in the form of spherical harmonics coefficients, but also the matrix of Doodson multipliers (<strong class="groops-config-element">outputfileDoodsonMatrix</strong>) and the <strong class="groops-config-element">outputfileAdmittanceMatrix</strong>.</p><p>The <strong class="groops-config-element">outputfileMajorTideList</strong> contains the <strong class="groops-config-element">fileNames</strong> for each contituent. The required information is taken from the <a class="groops-class" href="fileFormat_admittance.html">inputfileAdmittance</a>.</p><p>See also <a class="groops-program" href="DoodsonHarmonics2PotentialCoefficients.html">DoodsonHarmonics2PotentialCoefficients</a>.'},
'DoodsonHarmonics2IersPotential': { 'name': 'DoodsonHarmonics2IersPotential', 'key': 'DoodsonHarmonics2IersPotential', 'description': 'Convert doodson harmonics to IERS conventions according to FES2004. cf.  ftp://tai.bipm.org/iers/conv2010/chapter6/tidemodels/fes2004.dat .', 'config_table': 'outputfile filename according to IERS2010, chapter 6.3.2, footnote 7 inputfileDoodsonHarmoncis filename  header string info for output header factor double  minDegree uint  maxDegree uint', 'display_text': 'Convert doodson harmonics to IERS conventions according to FES2004. cf. <a href="ftp://tai.bipm.org/iers/conv2010/chapter6/tidemodels/fes2004.dat" target="_blank">ftp://tai.bipm.org/iers/conv2010/chapter6/tidemodels/fes2004.dat</a>.'},
'DoodsonHarmonics2IersWaterHeight': { 'name': 'DoodsonHarmonics2IersWaterHeight', 'key': 'DoodsonHarmonics2IersWaterHeight', 'description': 'Convert doodson harmonics to IERS conventions according to FES2004. cf.  ftp://tai.bipm.org/iers/conv2010/chapter6/tidemodels/fes2004.dat .', 'config_table': 'outputfile filename according to IERS2010, chapter 6.3.2, footnote 7 inputfileDoodsonHarmoncis filename  inputfileTideGeneratingPotential filename to compute Xi phase correction header string info for output header kernel kernelType data type of output values factor double e.g. from [m] to [cm] minDegree uint  maxDegree uint', 'display_text': 'Convert doodson harmonics to IERS conventions according to FES2004. cf. <a href="ftp://tai.bipm.org/iers/conv2010/chapter6/tidemodels/fes2004.dat" target="_blank">ftp://tai.bipm.org/iers/conv2010/chapter6/tidemodels/fes2004.dat</a>.'},
'GnssAntex2AntennaDefinition': { 'name': 'GnssAntex2AntennaDefinition', 'key': 'GnssAntex2AntennaDefinition', 'description': 'Converts metadata and antenna definitions from the  . to   Converts metadata and antenna definitions from the  ,   Converts metadata and antenna definitions from the  ,   Converts metadata and antenna definitions from the  , and   Converts metadata and antenna definitions from the   files for the respective GNSS and for the list of ground station antennas.', 'config_table': 'outputfileAntennaDefinitionStation filename antenna center variations outputfileAntennaDefinitionTransmitter filename antenna center variations outputfileTransmitterInfo filename PRN is appended to file name outputfileSvnBlockTableGps filename SVN to satellite block mapping outputfileSvnBlockTableGlonass filename SVN to satellite block mapping outputfileSvnBlockTableGalileo filename SVN to satellite block mapping outputfileSvnBlockTableBeiDou filename SVN to satellite block mapping outputfileSvnBlockTableQzss filename SVN to satellite block mapping outputfileTransmitterListGps filename list of PRNs outputfileTransmitterListGlonass filename list of PRNs outputfileTransmitterListGalileo filename list of PRNs outputfileTransmitterListBeiDou filename list of PRNs outputfileTransmitterListQzss filename list of PRNs inputfileAntex filename  timeStart time ignore older antenna definitions createZeroModel boolean create empty antenna patterns', 'display_text': 'Converts metadata and antenna definitions from the <a href="https://files.igs.org/pub/data/format/antex14.txt">IGS ANTEX format</a>. to <a class="groops-class" href="fileFormat_platform.html">transmitterInfo</a>, <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">antennaDefinition</a>, <a class="groops-class" href="fileFormat_stringTable.html">svnBlockTable</a>, and <a class="groops-class" href="fileFormat_stringList.html">transmitterList</a> files for the respective GNSS and for the list of ground station antennas.'},
'GnssAttitude2Orbex': { 'name': 'GnssAttitude2Orbex', 'key': 'GnssAttitude2Orbex', 'description': 'Convert attitude of GNSS satellites to   (quaternions). If   Convert attitude of GNSS satellites to   is provided, the output file contains quaternions for rotation from TRF to satellite body frame (IGS/ORBEX convention), otherwise the rotation is from CRF to satellite body frame. See also  GnssOrbex2StarCamera ,  SimulateStarCameraGnss .', 'config_table': 'outputfileOrbex filename ORBEX file inputfileTransmitterList filename ASCII list with transmitter PRNs inputfileAttitude filename instrument file containing attitude variablePrn string loop variable for PRNs from transmitter list timeSeries timeSeriesType resample to these epochs (otherwise input file epochs are used) earthRotation earthRotationType rotate data into Earth-fixed frame interpolationDegree uint for attitude and Earth rotation interpolation description string description of file contents createdBy string name of agency inputData string description of input data (see ORBEX description) contact string email address referenceFrame string reference frame used in file comment string', 'display_text': 'Convert attitude of GNSS satellites to <a href="http://acc.igs.org/misc/proposal_orbex_april2019.pdf">ORBEX file format</a> (quaternions).</p><p>If <a class="groops-class" href="earthRotationType.html">earthRotation</a> is provided, the output file contains quaternions for rotation from TRF to satellite body frame (IGS/ORBEX convention), otherwise the rotation is from CRF to satellite body frame.</p><p>See also <a class="groops-program" href="GnssOrbex2StarCamera.html">GnssOrbex2StarCamera</a>, <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a>.'},
'GnssClock2ClockRinex': { 'name': 'GnssClock2ClockRinex', 'key': 'GnssClock2ClockRinex', 'description': 'Converts GNSS clocks from GROOPS format to  . Clocks can be provided via  satelliteData  and/or  stationData . Observed signal types are inferred from   Converts GNSS clocks from GROOPS format to  . Satellites/stations used as clock references can be provided via  referenceClock . See IGS clock RINEX format description for further details on header information.', 'config_table': 'outputfileClockRinex filename  satelliteData sequence one element per satellite inputfileClock filename clock instrument file inputfileSignalBias filename signal bias file identifier string PRN (e.g. G23) stationData sequence one element per station inputfileClock filename clock instrument file inputfilePosition filename station position file inputfileStationInfo filename station info file identifier string station name (e.g. wtzz) comment string comment in header program string name of program (for first line) institution string name of agency (for first line) analysisCenter string name of analysis center differentialCodeBias string program and source for applied differential code bias phaseCenterVariations string program and source for applied phase center variations referenceClock string identifier of reference satellite/station referenceFrame string terrestrial reference frame for the stations', 'display_text': 'Converts GNSS clocks from GROOPS format to <a href="https://files.igs.org/pub/data/format/rinex_clock304.txt">IGS clock RINEX format</a>. Clocks can be provided via <strong class="groops-config-element">satelliteData</strong> and/or <strong class="groops-config-element">stationData</strong>. Observed signal types are inferred from <a class="groops-class" href="fileFormat_gnssSignalBias.html">inputfileSignalBias</a>. Satellites/stations used as clock references can be provided via <strong class="groops-config-element">referenceClock</strong>.</p><p>See IGS clock RINEX format description for further details on header information.'},
'GnssClockRinex2InstrumentClock': { 'name': 'GnssClockRinex2InstrumentClock', 'key': 'GnssClockRinex2InstrumentClock', 'description': 'This program converts clocks from the  , which contains the clocks of all satellites and stations in a single file, into an  instrument file (MISCVALUE)  for each  identifier  (satellite and/or station).', 'config_table': 'outputfileInstrument filename identifier is appended to each file inputfileClockRinex filename  identifier string satellite or station identifier, e.g. G23 or alic intervals timeSeriesType  minEpochsPerInterval uint minimum number of epochs in an interval', 'display_text': 'This program converts clocks from the <a href="https://files.igs.org/pub/data/format/rinex_clock304.txt">IGS clock RINEX format</a>, which contains the clocks of all satellites and stations in a single file, into an <a class="groops-file" href="fileFormat_instrument.html">instrument file (MISCVALUE)</a> for each <strong class="groops-config-element">identifier</strong> (satellite and/or station).'},
'GnssEop2IgsErp': { 'name': 'GnssEop2IgsErp', 'key': 'GnssEop2IgsErp', 'description': 'Write GNSS Earth orientation parameters to  . Requires polar motion, polar motion rate, dUT1 and LOD parameters in the solution vector   Write GNSS Earth orientation parameters to   and their sigmas in   Write GNSS Earth orientation parameters to  . Solution usually comes out of  GnssProcessing .', 'config_table': 'outputfileIgsErp filename IGS ERP file epoch sequence e.g. daily solution inputfileSolution filename parameter vector inputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) inputfileParameterNames filename parameter names inputfileTransmitterList filename transmitter PRNs used in solution (used for transmitter count) inputfileStationList filename stations used in solution (used for station count) time time reference time for epoch comment string', 'display_text': 'Write GNSS Earth orientation parameters to <a href="https://files.igs.org/pub/data/format/erp.txt">IGS ERP file format</a>.</p><p>Requires polar motion, polar motion rate, dUT1 and LOD parameters in the solution vector <a class="groops-class" href="fileFormat_matrix.html">inputfileSolution</a> and their sigmas in <a class="groops-class" href="fileFormat_matrix.html">inputfileSigmax</a>. Solution usually comes out of <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>.'},
'GnssGriddedDataTimeSeries2Ionex': { 'name': 'GnssGriddedDataTimeSeries2Ionex', 'key': 'GnssGriddedDataTimeSeries2Ionex', 'description': 'Converts TEC maps from GROOPS  gridded data time series  format to IGS  . Currently only supports 2D TEC maps. See also  GnssIonex2GriddedDataTimeSeries ,   Converts TEC maps from GROOPS  .', 'config_table': 'outputfileIonex filename  inputfileGriddedDataTimeSeries filename must contain regular grid value expression expression (e.g. data column) timeSeries timeSeriesType (empty = use input file time series) program string name of program (for first line) institution string name of agency (for first line) description string description in header comment string comment in header mappingFunction string see IONEX documentation elevationCutoff double see IONEX documentation (0 if unknown) observablesUsed string see IONEX documentation exponent int factor 10^exponent is applied to all values', 'display_text': 'Converts TEC maps from GROOPS <a class="groops-file" href="fileFormat_griddedDataTimeSeries.html">gridded data time series</a> format to IGS <a href="https://files.igs.org/pub/data/format/ionex1.pdf">IONEX file format</a>.</p><p>Currently only supports 2D TEC maps.</p><p>See also <a class="groops-program" href="GnssIonex2GriddedDataTimeSeries.html">GnssIonex2GriddedDataTimeSeries</a>, <a class="groops-class" href="gnssParametrizationType.html#ionosphereMap">IonosphereMap</a>.'},
'GnssIonex2GriddedDataTimeSeries': { 'name': 'GnssIonex2GriddedDataTimeSeries', 'key': 'GnssIonex2GriddedDataTimeSeries', 'description': 'Converts TEC maps from IGS   to GROOPS  gridded data time series  format. Currently only supports 2D TEC maps. See also  GnssGriddedDataTimeSeries2Ionex ,   Converts TEC maps from IGS  .', 'config_table': 'outputfileGriddedDataTimeSeries filename  inputfileIonex filename', 'display_text': 'Converts TEC maps from IGS <a href="https://files.igs.org/pub/data/format/ionex1.pdf">IONEX file format</a> to GROOPS <a class="groops-file" href="fileFormat_griddedDataTimeSeries.html">gridded data time series</a> format.</p><p>Currently only supports 2D TEC maps.</p><p>See also <a class="groops-program" href="GnssGriddedDataTimeSeries2Ionex.html">GnssGriddedDataTimeSeries2Ionex</a>, <a class="groops-class" href="gnssParametrizationType.html#ionosphereMap">IonosphereMap</a>.'},
'GnssNormals2Sinex': { 'name': 'GnssNormals2Sinex', 'key': 'GnssNormals2Sinex', 'description': 'Write GNSS data/metadata and  normal equations  to  . Normal equations usually come from  GnssProcessing  (e.g. from  GNSS satellite orbit determination and station network analysis ). Metadata input files include   Write GNSS data/metadata and  ,   Write GNSS data/metadata and  , and   Write GNSS data/metadata and  , see  GnssAntex2AntennaDefinition . See also  Sinex2Normals  and  NormalsSphericalHarmonics2Sinex .', 'config_table': 'outputfileSinexNormals filename full SINEX file including normal equations outputfileSinexCoordinates filename SINEX file without normal equations (station coordinates file) inputfileNormals filename normal equation matrix inputfileSolution filename parameter vector inputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) inputfileApriori filename apriori parameter vector inputfileAprioriSigma filename constraint sigmas for apriori parameter vector inputfileAprioriMatrix filename normal equation matrix of applied constraints transmitterConstellation sequence transmitter constellation metadata inputfileTransmitterList filename transmitter PRNs used in solution inputfileTransmitterInfo filename transmitter info file template inputfileAntennaDefinition filename transmitter phase centers and variations (ANTEX) variablePrn string loop variable for PRNs from transmitter list stations sequence  inputfileStationList filename stations contained in normal equations inputfileStationInfo filename station info file template inputfileAntennaDefinition filename station phase centers and variations (ANTEX) variableStationName string loop variable for station names from station list observationTimeStart time start time for which solution has observations observationTimeEnd time end time for which solution has observations time time reference time for parameters sampling double [seconds] observation sampling antennaCalibrationModel string e.g. IGS14_WWWW (WWWW = ANTEX release GPS week) sinexHeader sequence  agencyCode string identify the agency providing the data timeStart time start time of the data timeEnd time end time of the data  observationCode string technique used to generate the SINEX solution constraintCode string 0: tight constraint, 1: siginficant constraint, 2: unconstrained solutionContent string solution types contained in the SINEX solution (S O E T C A) description string organizitions gathering/alerting the file contents contact string Address of the relevant contact. e-mail output string Description of the file contents input string Brief description of the input used to generate this solution software string Software used to generate the file hardware string Computer hardware on which above software was run inputfileComment filename comments in the comment block from a file (truncated at 80 characters) comment string comments in the comment block', 'display_text': 'Write GNSS data/metadata and <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a> to <a href="http://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX format</a>.</p><p>Normal equations usually come from <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a> (e.g. from <a class="groops-ref" href="cookbook.gnssNetwork.html">GNSS satellite orbit determination and station network analysis</a>). Metadata input files include <a class="groops-class" href="fileFormat_platform.html">stationInfo/transmitterInfo</a>, <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">antennaDefinition</a>, and <a class="groops-class" href="fileFormat_stringList.html">stationList/transmitterList</a>, see <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a>.</p><p>See also <a class="groops-program" href="Sinex2Normals.html">Sinex2Normals</a> and <a class="groops-program" href="NormalsSphericalHarmonics2Sinex.html">NormalsSphericalHarmonics2Sinex</a>.'},
'GnssOrbex2StarCamera': { 'name': 'GnssOrbex2StarCamera', 'key': 'GnssOrbex2StarCamera', 'description': 'Converts GNSS satellite attitude from   (quaternions) to  instrument file (STARCAMERA) . The resulting star camera files contain the rotation from satellite body frame to TRF, or to CRF in case   Converts GNSS satellite attitude from   is provided. See also  GnssAttitude2Orbex .', 'config_table': 'outputfileStarCamera filename rotation from body frame to TRF/CRF, identifier is appended to each file inputfileOrbex filename  identifier string (empty = all) satellite identifier, e.g. G23 or E05 earthRotation earthRotationType rotation from TRF to CRF', 'display_text': 'Converts GNSS satellite attitude from <a href="http://acc.igs.org/misc/proposal_orbex_april2019.pdf">ORBEX file format</a> (quaternions) to <a class="groops-file" href="fileFormat_instrument.html">instrument file (STARCAMERA)</a>. The resulting star camera files contain the rotation from satellite body frame to TRF, or to CRF in case <a class="groops-class" href="earthRotationType.html">earthRotation</a> is provided.</p><p>See also <a class="groops-program" href="GnssAttitude2Orbex.html">GnssAttitude2Orbex</a>.'},
'GnssReceiver2RinexObservation': { 'name': 'GnssReceiver2RinexObservation', 'key': 'GnssReceiver2RinexObservation', 'description': 'Converts a   Converts a   into a   observation file. The   Converts a   contains the antenna and receiver information for the RINEX header. The   Converts a   and   Converts a   can be used to filter the observation types that will be exported.', 'config_table': 'outputfileRinexObservation filename RINEX observation file inputfileGnssReceiver filename GNSS instrument file inputfileStationInfo filename antenna and receiver info comment string write comments at begin of header observer string header information angency string header information useType gnssType only use observations that match any of these patterns ignoreType gnssType ignore observations that match any of these patterns', 'display_text': 'Converts a <a class="groops-class" href="fileFormat_instrument.html">inputfileGnssReceiver</a> into a <a href="https://files.igs.org/pub/data/format/rinex_4.00.pdf">RINEX</a> observation file. The <a class="groops-class" href="fileFormat_platform.html">inputfileStationInfo</a> contains the antenna and receiver information for the RINEX header. The <a class="groops-class" href="gnssType.html">useType</a> and <a class="groops-class" href="gnssType.html">ignoreType</a> can be used to filter the observation types that will be exported.'},
'GnssRinexNavigation2OrbitClock': { 'name': 'GnssRinexNavigation2OrbitClock', 'key': 'GnssRinexNavigation2OrbitClock', 'description': 'Evaluates orbit and clock parameters from   (version 2, 3, and 4) navigation file  inputfileRinex  at epochs given by   Evaluates orbit and clock parameters from   and writes them to   Evaluates orbit and clock parameters from   and   Evaluates orbit and clock parameters from  , respectively. Orbits are rotated from TRF (as broadcasted) to CRF via   Evaluates orbit and clock parameters from  , but system-specific TRFs (WGS84, PZ-90, etc.) are not aligned to a common TRF. If  messageType  is set (e.g., to LNAV, CNAV, or other types defined in the RINEX 4 standard), only navigation records of this type are used. Otherwise, if multiple records are defined for the same epoch, the first one is used. Also take note that all orbits are written out even satellites whose health flag would suggest otherwise. See also  OrbitAddVelocityAndAcceleration .', 'config_table': 'outputfileOrbit filename PRN is appended to file name outputfileClock filename PRN is appended to file name inputfileRinex filename RINEX navigation file timeSeries timeSeriesType orbit and clock evaluation epochs earthRotation earthRotationType for rotation from TRF to CRF usePrn string only export these PRNs instead of all messageType string (RINEX4) only use this navigation message (LNAV, CNAV, ...)', 'display_text': 'Evaluates orbit and clock parameters from <a href="https://files.igs.org/pub/data/format/rinex_4.00.pdf">RINEX</a> (version 2, 3, and 4) navigation file <strong class="groops-config-element">inputfileRinex</strong> at epochs given by <a class="groops-class" href="timeSeriesType.html">timeSeries</a> and writes them to <a class="groops-class" href="fileFormat_instrument.html">outputfileOrbit</a> and <a class="groops-class" href="fileFormat_instrument.html">outputfileClock</a>, respectively.</p><p>Orbits are rotated from TRF (as broadcasted) to CRF via <a class="groops-class" href="earthRotationType.html">earthRotation</a>, but system-specific TRFs (WGS84, PZ-90, etc.) are not aligned to a common TRF.</p><p>If <strong class="groops-config-element">messageType</strong> is set (e.g., to LNAV, CNAV, or other types defined in the RINEX 4 standard), only navigation records of this type are used. Otherwise, if multiple records are defined for the same epoch, the first one is used.</p><p>Also take note that all orbits are written out even satellites whose health flag would suggest otherwise.</p><p>See also <a class="groops-program" href="OrbitAddVelocityAndAcceleration.html">OrbitAddVelocityAndAcceleration</a>.'},
'GnssSignalBias2SinexBias': { 'name': 'GnssSignalBias2SinexBias', 'key': 'GnssSignalBias2SinexBias', 'description': 'Convert  GNSS signal biases  from GROOPS format to  . Biases can be provided via  transmitterBiases  and/or  receiverBiases . Phase biases without attribute (e.g.  L1* ) are automatically expanded so each code bias has a corresponding phase bias (Example:  C1C ,  C1W ,  L1*  are converted to  C1C ,  C1W ,  L1C ,  L1W ). Time-variable biases (e.g. GPS L5 satellite phase bias) can be provided via  timeVariableBias . Their time span will be based on the provided epochs ( ). The slope of the bias can be optionally provided in the second data column. If GLONASS receiver biases depend on frequency number, those must be defined in   Convert   to get the correct PRN/SVN assignment to the biases. See IGS SINEX Bias format description for further details on header information. See also  GnssSinexBias2SignalBias  and  GnssBiasClockAlignment .', 'config_table': 'outputfileSinexBias filename  inputfileTransmitterInfo filename one file per satellite transmitterBiases sequence one element per satellite inputfileSignalBias filename signal bias file timeVariableBias sequence one entry per time variable bias type inputfileSignalBias filename columns: mjd, bias [m], (biasSlope [m/s]) type gnssType bias type identifier string PRN or station name (e.g. G23 or wtzz) receiverBiases sequence one element per station inputfileSignalBias filename signal bias file timeVariableBias sequence one entry per time variable bias type inputfileSignalBias filename columns: mjd, bias [m], (biasSlope [m/s]) type gnssType bias type identifier string PRN or station name (e.g. G23 or wtzz) agencyCode string identify the agency providing the data fileAgencyCode string identify the agency creating the file timeStart time start time of the data timeEnd time end time of the data  biasMode choice absolute or relative bias estimates absolute   relative   observationSampling uint [seconds] intervalLength uint [seconds] interval for bias parameter representation determinationMethod string determination method used to generate the bias results (see SINEX Bias format description) receiverClockReferenceGnss string (G, R, E, C) reference GNSS used for receiver clock estimation satelliteClockReferenceObservables string one per system, reference code observable on first and second frequency (RINEX3 format) description string organizition gathering/altering the file contents contact string contact name and/or email address input string brief description of the input used to generate this solution output string description of the file contents software string software used to generate the file hardware string computer hardware on which above software was run comment string comments in the comment block', 'display_text': 'Convert <a class="groops-file" href="fileFormat_gnssSignalBias.html">GNSS signal biases</a> from GROOPS format to <a href="https://files.igs.org/pub/data/format/sinex_bias_100.pdf">IGS SINEX Bias format</a>. Biases can be provided via <strong class="groops-config-element">transmitterBiases</strong> and/or <strong class="groops-config-element">receiverBiases</strong>. Phase biases without attribute (e.g. <code>L1*</code>) are automatically expanded so each code bias has a corresponding phase bias (Example: <code>C1C</code>, <code>C1W</code>, <code>L1*</code> are converted to <code>C1C</code>, <code>C1W</code>, <code>L1C</code>, <code>L1W</code>).</p><p>Time-variable biases (e.g. GPS L5 satellite phase bias) can be provided via <strong class="groops-config-element">timeVariableBias</strong>. Their time span will be based on the provided epochs ($t \\pm \\Delta t / 2$). The slope of the bias can be optionally provided in the second data column.</p><p>If GLONASS receiver biases depend on frequency number, those must be defined in <a class="groops-class" href="fileFormat_platform.html">inputfileTransmitterInfo</a> to get the correct PRN/SVN assignment to the biases.</p><p>See IGS SINEX Bias format description for further details on header information.</p><p>See also <a class="groops-program" href="GnssSinexBias2SignalBias.html">GnssSinexBias2SignalBias</a> and <a class="groops-program" href="GnssBiasClockAlignment.html">GnssBiasClockAlignment</a>.'},
'GnssSinexBias2SignalBias': { 'name': 'GnssSinexBias2SignalBias', 'key': 'GnssSinexBias2SignalBias', 'description': 'Converts GNSS signal biases from   to  GnssSignalBias format . Only satellite observable-specific signal biases (OSB) are supported at the moment. If multiple entries exist for the same bias, the weighted average (based on time span) of all entries is used. Time-variable biases are not supported at the moment. See also  GnssSignalBias2SinexBias .', 'config_table': 'outputfileSignalBias filename identifier is appended to file name inputfileSinexBias filename  inputfileGlonassSignalDefinition filename GLONASS frequency number mapping identifier string (empty = all) satellite PRN, e.g. G23 or E05', 'display_text': 'Converts GNSS signal biases from <a href="https://files.igs.org/pub/data/format/sinex_bias_100.pdf">IGS SINEX Bias format</a> to <a class="groops-file" href="fileFormat_gnssSignalBias.html">GnssSignalBias format</a>.</p><p>Only satellite observable-specific signal biases (OSB) are supported at the moment. If multiple entries exist for the same bias, the weighted average (based on time span) of all entries is used. Time-variable biases are not supported at the moment.</p><p>See also <a class="groops-program" href="GnssSignalBias2SinexBias.html">GnssSignalBias2SinexBias</a>.'},
'GnssStationLog2Platform': { 'name': 'GnssStationLog2Platform', 'key': 'GnssStationLog2Platform', 'description': 'Converts   to   Converts  . If   Converts   is provided, station log data is cross-checked with the given antenna definitions. Cross-checking station log data with a   is also possible by providing  inputfileSinex . Any failed checks result in warnings in the output log.', 'config_table': 'outputfileStationPlatform filename  inputfileStationLog filename  inputfileAntennaDefinition filename used to check antennas inputfileSinex filename used to cross-check station log with SINEX file', 'display_text': 'Converts <a href="https://files.igs.org/pub/station/general/blank.log">IGS station log format</a> to <a class="groops-class" href="fileFormat_platform.html">outputfileStationPlatform</a>.</p><p>If <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a> is provided, station log data is cross-checked with the given antenna definitions. Cross-checking station log data with a <a href="https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX file</a> is also possible by providing <strong class="groops-config-element">inputfileSinex</strong>. Any failed checks result in warnings in the output log.'},
'GnssStationLog2StationInfo': { 'name': 'GnssStationLog2StationInfo', 'key': 'GnssStationLog2StationInfo', 'description': 'Converts   to   Converts  . If   Converts   is provided, station log data is cross-checked with the given antenna definitions. Cross-checking station log data with a   is also possible by providing  inputfileSinex . Any failed checks result in warnings in the output log.', 'config_table': 'outputfileStationInfo filename  inputfileStationLog filename  inputfileAntennaDefinition filename used to check antennas inputfileSinex filename used to cross-check station log with SINEX file', 'display_text': 'Converts <a href="https://files.igs.org/pub/station/general/blank.log">IGS station log format</a> to <a class="groops-class" href="fileFormat_gnssStationInfo.html">outputfileStationInfo</a>.</p><p>If <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a> is provided, station log data is cross-checked with the given antenna definitions. Cross-checking station log data with a <a href="https://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX file</a> is also possible by providing <strong class="groops-config-element">inputfileSinex</strong>. Any failed checks result in warnings in the output log.'},
'GnssTroposphere2TropoSinex': { 'name': 'GnssTroposphere2TropoSinex', 'key': 'GnssTroposphere2TropoSinex', 'description': 'Convert GNSS troposphere data from GROOPS format to   format. Specification of the station list is done via  inputfileStationList .  inputfileTroposphereData  needs the troposphere data provided from  GnssProcessing . Additional following station metadata are required:  inputfileStationInfo  using file type  Station info ,  inputfileAntennaDefinition  using file type  Antenna definition  and  inputfileGridPos  which uses the stations positions provided from  GnssProcessing . For considering the geoid height use  inputfileGeoidHeight . The geoid height is provided by  Gravityfield2GriddedData .', 'config_table': 'outputfileTropoSinex filename  stations sequence  inputfileStationList filename ASCII file with station names inputfileTroposphereData filename Troposphere data estimates template (columns: mjd, trodry, trowet, tgndry, tgnwet, tgedry, tgewet) inputfileTroposphereSigmas filename Troposphere data sigmas template (columns: mjd, sigma_trowet, sigma_tgnwet, sigma_tgewet) inputfileStationInfo filename station info file template inputfileGeoidHeight filename File including geoid height inputfileGridPos filename File including stations positions inputfileAntennaDefinition filename station phase centers and variations (ANTEX) variableStationName filename Loop variable for station names from station list observationTimeStart time Start time for which solution has observations observationTimeEnd time End time for which solution has observations dataSamplingInterval double [sec] GNSS data sampling rate tropoSamplingInterval double [sec] Tropospheric parameter sampling interval tropoModelingMethod string Tropospheric estimation method: Filter, Smoother, Least Squares, Piece-Wise Linear Interpolation aPrioriTropoModel string A priori tropospheric model used tropoMappingFunction string Name of mapping function used for hydrostatic and wet delay gradientMappingFunction string Name of mapping function used for gradients metDataSource string source of surface meteorological observations used (see format desc.) observationWeighting string observation weighting model applied elevationCutoff double [deg] gnssSystems string G=GPS, R=GLONASS, E=Galileo, C=BeiDou timeSystem string G (GPS) or UTC oceanTideModel string Ocean tide loading model applied atmosphericTideModel string Atmospheric tide loading model applied geoidModel string Geoid model name for undulation values systemCode string Terrestrial reference system code remark string Remark used to identify the origin of the coordinates (AC acronym) antennaCalibrationModel string e.g. IGS14_WWWW (WWWW = ANTEX release GPS week) sinexTroHeader sequence  agencyCode string Identify the agency providing the data timeStart time Start time of the data timeEnd time End time of the data  observationCode string Technique used to generate the SINEX solution solutionContents string Marker name if single station, MIX if multiple stations description string Organizitions gathering/alerting the file contents output string Description of the file contents contact string Address of the relevant contact e-mail software string Software used to generate the file hardware string Computer hardware on which above software was run input string Brief description of the input used to generate this solution versionNumber string Unique identifier of the product, same as in file name, e.g. 000 inputfileComment filename comments in the comment block from a file (truncated at 80 characters per line) comment string comments in the comment block', 'display_text': 'Convert GNSS troposphere data from GROOPS format to <a href="https://files.igs.org/pub/data/format/sinex_tro_v2.00.pdf">IGS SINEX TRO</a> format.</p><p>Specification of the station list is done via <strong class="groops-config-element">inputfileStationList</strong>. <strong class="groops-config-element">inputfileTroposphereData</strong> needs the troposphere data provided from <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. Additional following station metadata are required: <strong class="groops-config-element">inputfileStationInfo</strong> using file type <a class="groops-file" href="fileFormat_platform.html">Station info</a>, <strong class="groops-config-element">inputfileAntennaDefinition</strong> using file type <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">Antenna definition</a> and <strong class="groops-config-element">inputfileGridPos</strong> which uses the stations positions provided from <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. For considering the geoid height use <strong class="groops-config-element">inputfileGeoidHeight</strong>. The geoid height is provided by <a class="groops-program" href="Gravityfield2GriddedData.html">Gravityfield2GriddedData</a>.'},
'GoceXml2Gradiometer': { 'name': 'GoceXml2Gradiometer', 'key': 'GoceXml2Gradiometer', 'description': 'Read ESA XML GOCE Data. The  outputfileGradiometer  is written as  instrument file (GRADIOMETER) .', 'config_table': 'outputfileGradiometer filename  inputfile filename', 'display_text': 'Read ESA XML GOCE Data. The <strong class="groops-config-element">outputfileGradiometer</strong> is written as <a class="groops-file" href="fileFormat_instrument.html">instrument file (GRADIOMETER)</a>.'},
'GoceXml2Orbit': { 'name': 'GoceXml2Orbit', 'key': 'GoceXml2Orbit', 'description': 'Read ESA XML GOCE Data.', 'config_table': 'outputfileOrbit filename  earthRotation earthRotationType rotation from TRF to CRF inputfile filename', 'display_text': 'Read ESA XML GOCE Data.'},
'GoceXml2StarCamera': { 'name': 'GoceXml2StarCamera', 'key': 'GoceXml2StarCamera', 'description': 'Read ESA XML GOCE Data.', 'config_table': 'outputfileStarCamera filename  inputfile filename', 'display_text': 'Read ESA XML GOCE Data.'},
'GoceXmlEggNom1b': { 'name': 'GoceXmlEggNom1b', 'key': 'GoceXmlEggNom1b', 'description': 'Read ESA XML GOCE Data.', 'config_table': 'outputfileGradiometer filename  outputfileStarCamera filename  outputfileAngularRate filename  outputfileAngularAcc filename  inputfile filename', 'display_text': 'Read ESA XML GOCE Data.'},
'Grace2PotentialCoefficients': { 'name': 'Grace2PotentialCoefficients', 'key': 'Grace2PotentialCoefficients', 'description': 'This program converts potential coefficients from the GRACE SDS format into  potential coefficients file . The program supports file formats for RL04 to RL06. Within the program, the variables  epochStart ,  epochEnd  and  epochMid  are populated with the corresponding time-stamps in the file. These can be used in to   This program converts potential coefficients from the GRACE SDS format into   to auto-generate the file name.', 'config_table': 'outputfilePotentialCoefficients filename variables: epochStart, epochEnd, epochMid inputfile filename', 'display_text': 'This program converts potential coefficients from the GRACE SDS format into <a class="groops-file" href="fileFormat_potentialCoefficients.html">potential coefficients file</a>. The program supports file formats for RL04 to RL06.</p><p>Within the program, the variables <code>epochStart</code>, <code>epochEnd</code> and <code>epochMid</code> are populated with the corresponding time-stamps in the file. These can be used in to <a class="groops-class" href="fileFormat_potentialCoefficients.html">outputfilePotentialCoefficients</a> to auto-generate the file name.'},
'GraceAccelerometer2L1bAscii': { 'name': 'GraceAccelerometer2L1bAscii', 'key': 'GraceAccelerometer2L1bAscii', 'description': 'Convert GROOPS accelerometer files to the GRACE SDS L1B ASCII format.', 'config_table': 'outputfileAscii filename ASCII outputfile inputfileAccelerometer filename GROOPS acceleromter file satelliteIdentifier string satellite identifier (A or B for GRACE, C or D for GRACE-FO) globalAttributes string additional attributes as \'key: value\' pairs', 'display_text': 'Convert GROOPS accelerometer files to the GRACE SDS L1B ASCII format.'},
'GraceAod2DoodsonHarmonics': { 'name': 'GraceAod2DoodsonHarmonics', 'key': 'GraceAod2DoodsonHarmonics', 'description': 'This program converts the atmospheric and ocean tidal products (AOD1B) from the GRACE SDS format into   This program converts the atmospheric and ocean tidal products (AOD1B) from the GRACE SDS format into  .', 'config_table': 'outputfileDoodsonHarmonics filename  inputfileTideGeneratingPotential filename to compute Xi phase correction inputfile filename', 'display_text': 'This program converts the atmospheric and ocean tidal products (AOD1B) from the GRACE SDS format into <a class="groops-class" href="fileFormat_doodsonHarmonic.html">outputfileDoodsonHarmonics</a>.'},
'GraceAod2TimeSplines': { 'name': 'GraceAod2TimeSplines', 'key': 'GraceAod2TimeSplines', 'description': 'This program converts the atmospheric and ocean de-aliasing product (AOD1B) from the GRACE SDS format into  time spline files . Multiple  inputfile s must be given in the correct time order. A linear method is assumed for the interpolation between the given points in time. The GRACE SDS format is described in "AOD1B Product Description Document" given at  http://podaac.jpl.nasa.gov/grace/documentation.html .', 'config_table': 'outputfileDealiasing filename  outputfileAtmosphere filename  outputfileOcean filename  outputfileBottomPressure filename  outputfileMisc filename  inputfile filename', 'display_text': 'This program converts the atmospheric and ocean de-aliasing product (AOD1B) from the GRACE SDS format into <a class="groops-file" href="fileFormat_timeSplinesGravityField.html">time spline files</a>. Multiple <strong class="groops-config-element">inputfile</strong>s must be given in the correct time order. A linear method is assumed for the interpolation between the given points in time.</p><p>The GRACE SDS format is described in "AOD1B Product Description Document" given at <a href="http://podaac.jpl.nasa.gov/grace/documentation.html" target="_blank">http://podaac.jpl.nasa.gov/grace/documentation.html</a>.'},
'GraceCoefficients2BlockMeanTimeSplines': { 'name': 'GraceCoefficients2BlockMeanTimeSplines', 'key': 'GraceCoefficients2BlockMeanTimeSplines', 'description': 'This program converts potential coefficients from the GRACE SDS RL06 format into   This program converts potential coefficients from the GRACE SDS RL06 format into  . The   This program converts potential coefficients from the GRACE SDS RL06 format into   contains the mid points of non-empty intervals and   This program converts potential coefficients from the GRACE SDS RL06 format into   contains the monthly interval boundaries from first to last solution. The output will always be monthly block means. If the SDS solutions do vary or overlap, the nearest solution in terms of reference epoch is used.', 'config_table': 'outputfileTimeSplines filename  outputfileTimeSplinesCovariance filename only the variances are saved outputfileTimeSeries filename mid points of non-empty intervals outputfileTimeIntervals filename monthly interval boundaries from first to last solution inputfile filename', 'display_text': 'This program converts potential coefficients from the GRACE SDS RL06 format into <a class="groops-class" href="fileFormat_timeSplinesGravityField.html">outputfileTimeSplines</a>.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeSeries</a> contains the mid points of non-empty intervals and <a class="groops-class" href="fileFormat_instrument.html">outputfileTimeIntervals</a> contains the monthly interval boundaries from first to last solution.</p><p>The output will always be monthly block means. If the SDS solutions do vary or overlap, the nearest solution in terms of reference epoch is used.'},
'GraceL1a2Accelerometer': { 'name': 'GraceL1a2Accelerometer', 'key': 'GraceL1a2Accelerometer', 'description': 'This program converts Level-1A accelerometer data (ACC1A) to the GROOPS instrument file format. The GRACE Level-1A format is described in  GRACEiolib.h  given at  http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz . The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use  InstrumentSynchronize .', 'config_table': 'outputfileAccelerometer filename ACCELEROMETER in SRF outputfileAngularAccelerometer filename ACCELEROMETER in SRF inputfile filename ACC1A', 'display_text': 'This program converts Level-1A accelerometer data (ACC1A) to the GROOPS instrument file format. The GRACE Level-1A format is described in <code>GRACEiolib.h</code> given at <a href="http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz" target="_blank">http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz</a>. The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.'},
'GraceL1a2SatelliteTracking': { 'name': 'GraceL1a2SatelliteTracking', 'key': 'GraceL1a2SatelliteTracking', 'description': 'This program converts Level-1A satellite tracking data (KBR1A) to the GROOPS instrument file format. The GRACE Level-1A format is described in  GRACEiolib.h  given at  http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz . The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use  InstrumentSynchronize .', 'config_table': 'outputfileSatelliteTracking filename MISCVALUES(ant_id, K_phase, Ka_phase, K_SNR, Ka_SNR) inputfile filename KBR1A', 'display_text': 'This program converts Level-1A satellite tracking data (KBR1A) to the GROOPS instrument file format. The GRACE Level-1A format is described in <code>GRACEiolib.h</code> given at <a href="http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz" target="_blank">http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz</a>. The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.'},
'GraceL1a2StarCamera': { 'name': 'GraceL1a2StarCamera', 'key': 'GraceL1a2StarCamera', 'description': 'This program converts orientation data measured by the star cameras from the GRACE Level-1A format (SCA1A) to the GROOPS instrument file format. For further information see  GraceL1a2Accelerometer .', 'config_table': 'outputfileStarCamera1 filename STARCAMERA1A, head 1 outputfileStarCamera2 filename STARCAMERA1A, head 2 inputfile filename SCA1A, !GRACE-FO is not working!', 'display_text': 'This program converts orientation data measured by the star cameras from the GRACE Level-1A format (SCA1A) to the GROOPS instrument file format. For further information see <a class="groops-program" href="GraceL1a2Accelerometer.html">GraceL1a2Accelerometer</a>.'},
'GraceL1a2Temperature': { 'name': 'GraceL1a2Temperature', 'key': 'GraceL1a2Temperature', 'description': 'This program converts Level-1A temperature measurments (HRT1B or HRT1A) to the GROOPS instrument file format. The GRACE Level-1A format is described in GRACE given at  http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz . Multiple  inputfile s must be given in the correct time order. The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use  InstrumentSynchronize .', 'config_table': 'outputfileTemperature filename MISCVALUES inputfile filename HRT1B or HRT1A', 'display_text': 'This program converts Level-1A temperature measurments (HRT1B or HRT1A) to the GROOPS instrument file format. The GRACE Level-1A format is described in GRACE given at <a href="http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz" target="_blank">http://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/sw/GraceReadSW_L1_2010-03-31.tar.gz</a>. Multiple <strong class="groops-config-element">inputfile</strong>s must be given in the correct time order. The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.'},
'GraceL1b2AccHousekeeping': { 'name': 'GraceL1b2AccHousekeeping', 'key': 'GraceL1b2AccHousekeeping', 'description': 'This program converts ACC housekeeping data (AHK1B or AHK1A) from the GRACE SDS format into  instrument file (ACCHOUSEKEEPING) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileAccHousekeeping filename ACCHOUSEKEEPING inputfile filename AHK1B or AHK1A', 'display_text': 'This program converts ACC housekeeping data (AHK1B or AHK1A) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (ACCHOUSEKEEPING)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2Accelerometer': { 'name': 'GraceL1b2Accelerometer', 'key': 'GraceL1b2Accelerometer', 'description': 'This program converts accelerometer data (ACC1B or ACT1B) from the GRACE SDS format into  instrument file (ACCELEROMETER) . Multiple  inputfile s must be given in the correct time order. The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use  InstrumentSynchronize . The GRACE SDS format is described in "GRACE Level 1B Data Product User Handbook JPL D-22027" given at  https://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/docs/Handbook_1B_v1.3.pdf .', 'config_table': 'outputfileAccelerometer filename ACCELEROMETER outputfileAngularAccelerometer filename ACCELEROMETER outputfileFlags filename MISCVALUES(qualflg, acl_res.x, acl_res.y, acl_res.z) inputfile filename ACC1B or ACT1B', 'display_text': 'This program converts accelerometer data (ACC1B or ACT1B) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (ACCELEROMETER)</a>.</p><p>Multiple <strong class="groops-config-element">inputfile</strong>s must be given in the correct time order. The output is one arc of satellite data which can include data gaps. To split the arc in multiple gap free arcs use <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>.</p><p>The GRACE SDS format is described in "GRACE Level 1B Data Product User Handbook JPL D-22027" given at <a href="https://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/docs/Handbook_1B_v1.3.pdf" target="_blank">https://podaac-tools.jpl.nasa.gov/drive/files/allData/grace/docs/Handbook_1B_v1.3.pdf</a>.'},
'GraceL1b2ClockOffset': { 'name': 'GraceL1b2ClockOffset', 'key': 'GraceL1b2ClockOffset', 'description': 'This program converts clock data (CLK1B or LLK1B) from the GRACE SDS format into  instrument file (MISCVALUE) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileClock filename MISCVALUE inputfile filename CLK1B or LLK1B', 'display_text': 'This program converts clock data (CLK1B or LLK1B) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (MISCVALUE)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2GnssReceiver': { 'name': 'GraceL1b2GnssReceiver', 'key': 'GraceL1b2GnssReceiver', 'description': 'This program converts GPS receiver data (phase and pseudo range) data from the GRACE SDS format (GPS1B or GPS1A) into  instrument file (GNSSRECEIVER) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileGnssReceiver filename GNSSRECEIVER inputfile filename GPS1B or GPS1A', 'display_text': 'This program converts GPS receiver data (phase and pseudo range) data from the GRACE SDS format (GPS1B or GPS1A) into <a class="groops-file" href="fileFormat_instrument.html">instrument file (GNSSRECEIVER)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2Magnetometer': { 'name': 'GraceL1b2Magnetometer', 'key': 'GraceL1b2Magnetometer', 'description': 'This program converts magnetometer data (MAG1B or MAG1A) from the GRACE SDS format into  instrument file (MAGNETOMETER) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileMagnetometer filename MAGNETOMETER inputfile filename MAG1B or MAG1A', 'display_text': 'This program converts magnetometer data (MAG1B or MAG1A) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (MAGNETOMETER)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2Mass': { 'name': 'GraceL1b2Mass', 'key': 'GraceL1b2Mass', 'description': 'This program converts mass data (MAS1B or MAS1A) from the GRACE SDS format into  instrument file (MASS) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileMass filename MASS inputfile filename MAS1B or MAS1A', 'display_text': 'This program converts mass data (MAS1B or MAS1A) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (MASS)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2Orbit': { 'name': 'GraceL1b2Orbit', 'key': 'GraceL1b2Orbit', 'description': 'This program converts the reduced dynamical orbit from the GRACE/GRACE-FO SDS format (GNV1B, GNI1B) into  instrument file (ORBIT) . When GNV1B is used, the orbit can be rotated from the terrestrial reference frame (TRF) transformed into the celestial reference frame (CRF) by specifying   This program converts the reduced dynamical orbit from the GRACE/GRACE-FO SDS format (GNV1B, GNI1B) into  . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileOrbit filename  earthRotation earthRotationType to rotate GNV1B into CRF inputfile filename GNV1B/GNI1B', 'display_text': 'This program converts the reduced dynamical orbit from the GRACE/GRACE-FO SDS format (GNV1B, GNI1B) into <a class="groops-file" href="fileFormat_instrument.html">instrument file (ORBIT)</a>.</p><p>When GNV1B is used, the orbit can be rotated from the terrestrial reference frame (TRF) transformed into the celestial reference frame (CRF) by specifying <a class="groops-class" href="earthRotationType.html">earthRotation</a>.</p><p>For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2SatelliteTracking': { 'name': 'GraceL1b2SatelliteTracking', 'key': 'GraceL1b2SatelliteTracking', 'description': 'This program converts low-low satellite data measured by the K-band ranging system from the GRACE SDS format (KBR1B or LRI1B) into  instrument file (SATELLITETRACKING) . The  inputfile s contain also corrections to antenna offsets and the so called light time correction. The corrections can be stored in additional files in the same format as the observations. If a phase break is found an artificial gap is created. For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileSatelliteTracking filename SATELLITETRACKING outputfileAntCentr filename SATELLITETRACKING outputfileLighttime filename SATELLITETRACKING outputfileSNR filename MISCVALUES(K_A_SNR, Ka_A_SNR, K_B_SNR, Ka_B_SNR, qualflg) outputfileIonoCorr filename MISCVALUE inputfile filename KBR1B or LRI1B', 'display_text': 'This program converts low-low satellite data measured by the K-band ranging system from the GRACE SDS format (KBR1B or LRI1B) into <a class="groops-file" href="fileFormat_instrument.html">instrument file (SATELLITETRACKING)</a>. The <strong class="groops-config-element">inputfile</strong>s contain also corrections to antenna offsets and the so called light time correction. The corrections can be stored in additional files in the same format as the observations. If a phase break is found an artificial gap is created. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2StarCamera': { 'name': 'GraceL1b2StarCamera', 'key': 'GraceL1b2StarCamera', 'description': 'This program converts orientation data measured by a star camera (SRF to CRF) from the GRACE SDS format (SCA1B) into  instrument file (STARCAMERA) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileStarCamera filename  outputfileStarCameraFlags filename MISCVALUES(sca_id, qual_rss, qualflg) inputfile filename SCA1B', 'display_text': 'This program converts orientation data measured by a star camera (SRF to CRF) from the GRACE SDS format (SCA1B) into <a class="groops-file" href="fileFormat_instrument.html">instrument file (STARCAMERA)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2StarCameraCovariance': { 'name': 'GraceL1b2StarCameraCovariance', 'key': 'GraceL1b2StarCameraCovariance', 'description': 'This program computes star camera covariance matrices ( instrument file, COVARIANE3D ) for a GRACE satellite under consideration of the active camera heads and an a priori variance factor.', 'config_table': 'outputfileStarCameraCovariance filename  inputfileStarCameraFlags filename  inputfileSequenceOfEventsQSA filename  sigma0 double [seconds of arc]', 'display_text': 'This program computes star camera covariance matrices (<a class="groops-file" href="fileFormat_instrument.html">instrument file, COVARIANE3D</a>) for a GRACE satellite under consideration of the active camera heads and an a priori variance factor.'},
'GraceL1b2SteeringMirror': { 'name': 'GraceL1b2SteeringMirror', 'key': 'GraceL1b2SteeringMirror', 'description': 'This program converts GRACE-FO Steering Mirror output (LSM1B) to an  instrument file (STARCAMERA) .', 'config_table': 'outputfileStarCamera filename  inputfile filename LSM1B', 'display_text': 'This program converts GRACE-FO Steering Mirror output (LSM1B) to an <a class="groops-file" href="fileFormat_instrument.html">instrument file (STARCAMERA)</a>.'},
'GraceL1b2Thruster': { 'name': 'GraceL1b2Thruster', 'key': 'GraceL1b2Thruster', 'description': 'This program converts thruster data (THR1B or THR1A) from the GRACE SDS format into  instrument file (THRUSTER) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileThruster filename THRUSTER inputfile filename THR1B or THR1A', 'display_text': 'This program converts thruster data (THR1B or THR1A) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (THRUSTER)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2TimeOffset': { 'name': 'GraceL1b2TimeOffset', 'key': 'GraceL1b2TimeOffset', 'description': 'This program converts time data (TIM1A or TIM1B) from the GRACE SDS format into  instrument file (MISCVALUE) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileTime filename MISCVALUE fractionalScale double 1e-6 for GRACE, 1e-9 for GRACE-FO inputfile filename TIM1A or TIM1B', 'display_text': 'This program converts time data (TIM1A or TIM1B) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (MISCVALUE)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2Uso': { 'name': 'GraceL1b2Uso', 'key': 'GraceL1b2Uso', 'description': 'This program converts clock data (USO1B) from the GRACE SDS format into  instrument file (MISCVALUES) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileUso filename MISCVALUES(uso_freq, K_freq, Ka_freq) inputfile filename USO1B', 'display_text': 'This program converts clock data (USO1B) from the GRACE SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (MISCVALUES)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GraceL1b2Vector': { 'name': 'GraceL1b2Vector', 'key': 'GraceL1b2Vector', 'description': 'This program reads vector orientation data (positions of instruments in the satellite frame) from the GRACE SDS format (VGB1B, VGN1B, VGO1B, VKB1B, or VCM1B). The   This program reads vector orientation data (positions of instruments in the satellite frame) from the GRACE SDS format (VGB1B, VGN1B, VGO1B, VKB1B, or VCM1B). The   is a   matrix containing   for each record. The GRACE SDS format is described in "GRACE Level 1B Data Product User Handbook JPL D-22027" given at  http://podaac.jpl.nasa.gov/grace/documentation.html .', 'config_table': 'outputfileVector filename  inputfile filename VGB1B, VGN1B, VGO1B, VKB1B, or VCM1B', 'display_text': 'This program reads vector orientation data (positions of instruments in the satellite frame) from the GRACE SDS format (VGB1B, VGN1B, VGO1B, VKB1B, or VCM1B). The <a class="groops-class" href="fileFormat_matrix.html">outputfileVector</a> is a $(3n\\times1)$ matrix containing $(x,y,z)$ for each record. The GRACE SDS format is described in "GRACE Level 1B Data Product User Handbook JPL D-22027" given at <a href="http://podaac.jpl.nasa.gov/grace/documentation.html" target="_blank">http://podaac.jpl.nasa.gov/grace/documentation.html</a>.'},
'GraceSequenceOfEvents': { 'name': 'GraceSequenceOfEvents', 'key': 'GraceSequenceOfEvents', 'description': 'This program converts the GRACE SOE (sequence of events) file/format into  instrument file (MISCVALUES) . The GRACE SOE format is described in "GRACE Level 1B Data Product User Handbook JPL D-22027" and "TN-03 SOE format.txt" given at  http://podaac.jpl.nasa.gov/grace/documentation.html . The output is one arc of satellite data which can include data gaps.', 'config_table': 'outputfileGraceA filename  outputfileGraceB filename  inputfile filename SoE file events choice  ACCT sequence DSHL HeaterDisconnect mode choice  Heater  DSHL HeaterDisconnect SetPoint  temperature set point AOCS sequence coarse pointing mode or attitude hold mode mode choice  CPM  coarse pointing mode AHM  attitude hold mode SM  science mode ACCR  ACCR CMCAL sequence CoM calibration maneuver sampling double [seconds] create events between start and end of maneuver KBRCAL sequence KBR calibration maneuver sampling double [seconds] create events between start and end of maneuver VCM  CoM coordinates in SRF (m) VKB  KBR phase center coordinates in SRF (m) ICUVP  ICUVP IPU  IPU IPUR  IPUR KAMI  KAMI: time tag offset to Ka-phase meas. KMI  K_MI: time tag offset to K-phase meas. KTOFF  KTOFF: time tag offset to KBR meas. MANV  MANV MTE1  MTE1 MTE2  MTE2 OCC  OCC QSA  SCA to SRF frame rotation QKS  SCA to KBR frame rotation', 'display_text': 'This program converts the GRACE SOE (sequence of events) file/format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (MISCVALUES)</a>. The GRACE SOE format is described in "GRACE Level 1B Data Product User Handbook JPL D-22027" and "TN-03_SOE_format.txt" given at <a href="http://podaac.jpl.nasa.gov/grace/documentation.html" target="_blank">http://podaac.jpl.nasa.gov/grace/documentation.html</a>. The output is one arc of satellite data which can include data gaps.'},
'GrailCdr2Orbit': { 'name': 'GrailCdr2Orbit', 'key': 'GrailCdr2Orbit', 'description': 'This program converts the orbit from the GRAIL SDS format into   instrument file (ORBIT) .', 'config_table': 'outputfileOrbit filename  inputfile filename', 'display_text': 'This program converts the orbit from the GRAIL SDS format into  <a class="groops-file" href="fileFormat_instrument.html">instrument file (ORBIT)</a>.'},
'GrailCdr2SatelliteTracking': { 'name': 'GrailCdr2SatelliteTracking', 'key': 'GrailCdr2SatelliteTracking', 'description': 'This program converts low-low satellite data measured by the K-band ranging system from the GRAIL format into  instrument file (SATELLITETRACKING) . The  inputfile s contain also corrections for antenna offsets and the so called light time correction. The corrections can be stored in additional files in the same format as the observations. If a phase break is found an artificial gap is created.', 'config_table': 'outputfileSatelliteTracking filename  outputfileAntCentr filename  outputfileLighttime filename  outputfileTemperature filename  approximateTimeBias double [seconds] inputfile filename', 'display_text': 'This program converts low-low satellite data measured by the K-band ranging system from the GRAIL format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (SATELLITETRACKING)</a>. The <strong class="groops-config-element">inputfile</strong>s contain also corrections for antenna offsets and the so called light time correction. The corrections can be stored in additional files in the same format as the observations. If a phase break is found an artificial gap is created.'},
'GrailCdr2StarCamera': { 'name': 'GrailCdr2StarCamera', 'key': 'GrailCdr2StarCamera', 'description': 'This program converts orientation data measured by a star camera (SRF to CRF) from the GRAIL SDS format into  instrument file (STARCAMERA) . For further information see  GraceL1b2Accelerometer .', 'config_table': 'outputfileStarCamera filename  inputfile filename', 'display_text': 'This program converts orientation data measured by a star camera (SRF to CRF) from the GRAIL SDS format into <a class="groops-file" href="fileFormat_instrument.html">instrument file (STARCAMERA)</a>. For further information see <a class="groops-program" href="GraceL1b2Accelerometer.html">GraceL1b2Accelerometer</a>.'},
'GriddedData2NetCdf': { 'name': 'GriddedData2NetCdf', 'key': 'GriddedData2NetCdf', 'description': 'This program converts a   This program converts a   to a COARDS compliant NetCDF file. The output data can be defined with  dataVariable . You should add at least the attributes  units ,  long_name , and maybe  _FillValue  to the variables. For the  dataVariable:value  the standard  dataVariables  are available to select the data columns of   This program converts a  . See also  NetCdfInfo ,  GriddedDataTimeSeries2NetCdf ,  NetCdf2GriddedData .', 'config_table': 'outputfileNetCdf filename file name of NetCDF output inputfileGriddedData filename input grid sequence dataVariable sequence metadata for data variables name string netCDF variable name value expression expression (variables \'height\', \'data\', \'longitude\', \'latitude\' and, \'area\' are taken from the gridded data dataType choice  double   float   int   attribute choice netCDF attributes text sequence  name string  value string  value sequence  name string  value double  dataType choice  double   float   int   globalAttribute choice additional meta data text sequence  name string  value string  value sequence  name string  value double  dataType choice  double   float   int', 'display_text': 'This program converts a <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> to a COARDS compliant NetCDF file. The output data can be defined with <strong class="groops-config-element">dataVariable</strong>. You should add at least the attributes <code>units</code>, <code>long_name</code>, and maybe <code>_FillValue</code> to the variables. For the <strong class="groops-config-element">dataVariable:value</strong> the standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data columns of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>.</p><p>See also <a class="groops-program" href="NetCdfInfo.html">NetCdfInfo</a>, <a class="groops-program" href="GriddedDataTimeSeries2NetCdf.html">GriddedDataTimeSeries2NetCdf</a>, <a class="groops-program" href="NetCdf2GriddedData.html">NetCdf2GriddedData</a>.'},
'GriddedDataTimeSeries2NetCdf': { 'name': 'GriddedDataTimeSeries2NetCdf', 'key': 'GriddedDataTimeSeries2NetCdf', 'description': 'Read a   Read a   and converts it to a COARDS compliant NetCDF file. The output data can be defined with  dataVariable . You should add at least the attributes  units ,  long_name , and maybe  _FillValue  to the variables. The  dataVariable:inputColumn  selects the data from the input file. If   Read a   is not set the temporal nodal points from the inputfile are used. See also  NetCdfInfo ,  GriddedData2NetCdf ,  NetCdf2GriddedDataTimeSeries .', 'config_table': 'outputfileNetCdf filename file name of NetCDF output inputfileGriddedDataTimeSeries filename  timeSeries timeSeriesType otherwise times from inputfile are used dataVariable sequence metadata for data variables name string netCDF variable name inputColumn uint input data column dataType choice  double   float   int   attribute choice netCDF attributes text sequence  name string  value string  value sequence  name string  value double  dataType choice  double   float   int   globalAttribute choice additional meta data text sequence  name string  value string  value sequence  name string  value double  dataType choice  double   float   int', 'display_text': 'Read a <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">inputfileGriddedDataTimeSeries</a> and converts it to a COARDS compliant NetCDF file.</p><p>The output data can be defined with <strong class="groops-config-element">dataVariable</strong>. You should add at least the attributes <code>units</code>, <code>long_name</code>, and maybe <code>_FillValue</code> to the variables. The <strong class="groops-config-element">dataVariable:inputColumn</strong> selects the data from the input file.</p><p>If <a class="groops-class" href="timeSeriesType.html">timeSeries</a> is not set the temporal nodal points from the inputfile are used.</p><p>See also <a class="groops-program" href="NetCdfInfo.html">NetCdfInfo</a>, <a class="groops-program" href="GriddedData2NetCdf.html">GriddedData2NetCdf</a>, <a class="groops-program" href="NetCdf2GriddedDataTimeSeries.html">NetCdf2GriddedDataTimeSeries</a>.'},
'GroopsAscii2Orbit': { 'name': 'GroopsAscii2Orbit', 'key': 'GroopsAscii2Orbit', 'description': 'Read Orbits given in groops kinematic orbit ASCII format with covariance information. See also  Orbit2GroopsAscii .', 'config_table': 'outputfileOrbit filename  outputfileCovariance filename  earthRotation earthRotationType  inputfile filename', 'display_text': 'Read Orbits given in groops kinematic orbit ASCII format with covariance information.</p><p>See also <a class="groops-program" href="Orbit2GroopsAscii.html">Orbit2GroopsAscii</a>.'},
'Hw2TideGeneratingPotential': { 'name': 'Hw2TideGeneratingPotential', 'key': 'Hw2TideGeneratingPotential', 'description': 'Write  tide generating potential  from Hartmann and Wenzel 1995 file,  https://doi.org/10.1029/95GL03324 .', 'config_table': 'outputfileTideGeneratingPotential filename  inputfile filename  headerLines uint skip number of header lines referenceTime time reference time', 'display_text': 'Write <a class="groops-file" href="fileFormat_tideGeneratingPotential.html">tide generating potential</a> from Hartmann and Wenzel 1995 file, <a href="https://doi.org/10.1029/95GL03324" target="_blank">https://doi.org/10.1029/95GL03324</a>.'},
'Icgem2PotentialCoefficients': { 'name': 'Icgem2PotentialCoefficients', 'key': 'Icgem2PotentialCoefficients', 'description': 'Read spherical harmonics in ICGEM format ( http://icgem.gfz-potsdam.de/ ).', 'config_table': 'outputfileStaticCoefficients filename static potential coefficients in GROOPS gfc format. Available variables (icgem2.0): epochStart, epochEnd, epochMid; (icgem1.0) epochReference outputfileTrendCoefficients filename trend potential coefficients in GROOPS gfc format.  Available variables (icgem2.0): epochStart, epochEnd, epochMid; (icgem1.0) epochReference outputfileOscillationCosine filename oscillation cosine coefficients in GROOPS gfc format. Available variables (icgem2.0): epochStart, epochEnd, epochMid, oscillationPeriod; (icgem1.0) epochReference, oscillationPeriod outputfileOscillationSine filename oscillation sine coefficients in GROOPS gfc format. Available variables (icgem2.0): epochStart, epochEnd, epochMid, oscillationPeriod; (icgem1.0) epochReference, oscillationPeriod outputfileIntervals filename two column ASCII file with all intervals found (only sensible for icgem2.0). The base name will be extended with .static, .trend, .annualCos, and .annualSin. inputfileIcgem filename ICGEM GFC file useFormalErrors boolean use formal errors if both formal and calibrated errors are given', 'display_text': 'Read spherical harmonics in ICGEM format (<a href="http://icgem.gfz-potsdam.de/" target="_blank">http://icgem.gfz-potsdam.de/</a>).'},
'Iers2OceanPoleTide': { 'name': 'Iers2OceanPoleTide', 'key': 'Iers2OceanPoleTide', 'description': 'Read ocean pole tide model according to IERS conventions and convert into  oceanPoleTide file .', 'config_table': 'outputfileOceanPole filename  inputfile filename  inputfileLoadingLoveNumber filename  maxDegree uint  GM double Geocentric gravitational constant R double Reference radius Omega double [rad/s] earth rotation rho double [kg/m**3] density of sea water G double [m**3/(kg*s**2)] gravitational constant g double [m/s**2] gravity', 'display_text': 'Read ocean pole tide model according to IERS conventions and convert into <a class="groops-file" href="fileFormat_oceanPoleTide.html">oceanPoleTide file</a>.'},
'IersC04IAU2000EarthOrientationParameter': { 'name': 'IersC04IAU2000EarthOrientationParameter', 'key': 'IersC04IAU2000EarthOrientationParameter', 'description': 'Read a IERS Earth orientation data C04 (IAU2000A) file and write it as   Read a IERS Earth orientation data C04 (IAU2000A) file and write it as  .', 'config_table': 'outputfileEOP filename  inputfile filename  timeStart time  timeEnd time', 'display_text': 'Read a IERS Earth orientation data C04 (IAU2000A) file and write it as <a class="groops-class" href="fileFormat_earthOrientationParameter.html">outputfileEOP</a>.'},
'IersHighFrequentEop2DoodsonEop': { 'name': 'IersHighFrequentEop2DoodsonEop', 'key': 'IersHighFrequentEop2DoodsonEop', 'description': 'Read Diurnal and Subdiurnal Earth Orientation variations according to updated IERS 2010 conventions and write them as   Read Diurnal and Subdiurnal Earth Orientation variations according to updated IERS 2010 conventions and write them as  .', 'config_table': 'outputfileDoodsonEOP filename  inputfile filename', 'display_text': 'Read Diurnal and Subdiurnal Earth Orientation variations according to updated IERS 2010 conventions and write them as <a class="groops-class" href="fileFormat_doodsonEarthOrientationParameter.html">outputfileDoodsonEOP</a>.'},
'IersPotential2DoodsonHarmonics': { 'name': 'IersPotential2DoodsonHarmonics', 'key': 'IersPotential2DoodsonHarmonics', 'description': 'Read ocean tide file in IERS format.', 'config_table': 'outputfileDoodsonHarmoncis filename  inputfile filename  headerLines uint skip number of header lines minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius', 'display_text': 'Read ocean tide file in IERS format.'},
'IersRapidIAU2000EarthOrientationParameter': { 'name': 'IersRapidIAU2000EarthOrientationParameter', 'key': 'IersRapidIAU2000EarthOrientationParameter', 'description': 'Read a IERS Earth orientation rapid data and prediction file (IAU2000) and write it as   Read a IERS Earth orientation rapid data and prediction file (IAU2000) and write it as  .', 'config_table': 'outputfileEOP filename  inputfile filename  timeStart time  timeEnd time', 'display_text': 'Read a IERS Earth orientation rapid data and prediction file (IAU2000) and write it as <a class="groops-class" href="fileFormat_earthOrientationParameter.html">outputfileEOP</a>.'},
'IersWaterHeight2DoodsonHarmonics': { 'name': 'IersWaterHeight2DoodsonHarmonics', 'key': 'IersWaterHeight2DoodsonHarmonics', 'description': 'Read ocean tide file in IERS format.', 'config_table': 'outputfileDoodsonHarmoncis filename  inputfile filename  headerLines uint skip number of header lines inputfileTideGeneratingPotential filename to compute Xi phase correction kernel kernelType data type of input values factor double to convert in SI units minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius', 'display_text': 'Read ocean tide file in IERS format.'},
'Igs2EarthOrientationParameter': { 'name': 'Igs2EarthOrientationParameter', 'key': 'Igs2EarthOrientationParameter', 'description': 'Read Rapid Earth Orientation Parameter from IGS daily file and write it as   Read Rapid Earth Orientation Parameter from IGS daily file and write it as  .', 'config_table': 'outputfileEOP filename  inputfile filename  timeStart time  timeEnd time', 'display_text': 'Read Rapid Earth Orientation Parameter from IGS daily file and write it as <a class="groops-class" href="fileFormat_earthOrientationParameter.html">outputfileEOP</a>.'},
'Jason2Starcamera': { 'name': 'Jason2Starcamera', 'key': 'Jason2Starcamera', 'description': 'This program reads in Jason star camera data given in a special  format. Files available at:  cddis.gsfc.nasa.gov/pub/doris/ancillary/quaternions/ja2/ . A description of the format can be found under:  ftp://ftp.ids-doris.org/pub/ids/ancillary/quaternions/jason1_2_quaternion_solar_panel.pdf', 'config_table': 'outputfileStarCamera filename  jasonNumber uint Jason number (different file format), 1 for Sentinel inputfile filename', 'display_text': 'This program reads in Jason star camera data given in a special  format. Files available at: <a href="cddis.gsfc.nasa.gov/pub/doris/ancillary/quaternions/ja2/" target="_blank">cddis.gsfc.nasa.gov/pub/doris/ancillary/quaternions/ja2/</a>. A description of the format can be found under: <a href="ftp://ftp.ids-doris.org/pub/ids/ancillary/quaternions/jason1_2_quaternion_solar_panel.pdf" target="_blank">ftp://ftp.ids-doris.org/pub/ids/ancillary/quaternions/jason1_2_quaternion_solar_panel.pdf</a>'},
'JplAscii2Ephemerides': { 'name': 'JplAscii2Ephemerides', 'key': 'JplAscii2Ephemerides', 'description': 'Read JPL DExxx (ASCII) ephemerides.', 'config_table': 'outputfileEphemerides filename  inputfileHeader filename  inputfileData filename', 'display_text': 'Read JPL DExxx (ASCII) ephemerides.'},
'Metop2Starcamera': { 'name': 'Metop2Starcamera', 'key': 'Metop2Starcamera', 'description': 'This program reads in star camera data from MetOp satellites given in the special CHAMP format. A description of the format can be found under:  http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf', 'config_table': 'outputfileStarCamera filename  inputfile filename', 'display_text': 'This program reads in star camera data from MetOp satellites given in the special CHAMP format. A description of the format can be found under: <a href="http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf" target="_blank">http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-001.pdf</a>'},
'NetCdf2GriddedData': { 'name': 'NetCdf2GriddedData', 'key': 'NetCdf2GriddedData', 'description': 'This program converts a COARDS compliant NetCDF file into an   This program converts a COARDS compliant NetCDF file into an  . If no specific input  variableNameData  are selected all suitable data are used. If the NETCDF file contains a time axis ( variableNameData ) an specific epoch can be selected with  time . The nearest epoch in file is used. See also  NetCdfInfo ,  GriddedData2NetCdf ,  NetCdf2GriddedDataTimeSeries .', 'config_table': 'outputfileGriddedData filename  inputfileNetCdf filename  variableNameLongitude string name of NetCDF variable variableNameLatitude string name of NetCDF variable variableNameTime string if with time axis: name of NetCDF variable variableNameData string data variables, otherwise all suitable data are used time time if with time axis: nearest epoch is used R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'This program converts a COARDS compliant NetCDF file into an <a class="groops-class" href="fileFormat_griddedData.html">outputfileGriddedData</a>. If no specific input <strong class="groops-config-element">variableNameData</strong> are selected all suitable data are used.</p><p>If the NETCDF file contains a time axis (<strong class="groops-config-element">variableNameData</strong>) an specific epoch can be selected with <strong class="groops-config-element">time</strong>. The nearest epoch in file is used.</p><p>See also <a class="groops-program" href="NetCdfInfo.html">NetCdfInfo</a>, <a class="groops-program" href="GriddedData2NetCdf.html">GriddedData2NetCdf</a>, <a class="groops-program" href="NetCdf2GriddedDataTimeSeries.html">NetCdf2GriddedDataTimeSeries</a>.'},
'NetCdf2GriddedDataTimeSeries': { 'name': 'NetCdf2GriddedDataTimeSeries', 'key': 'NetCdf2GriddedDataTimeSeries', 'description': 'This program converts a COARDS compliant NetCDF file into   This program converts a COARDS compliant NetCDF file into  . If no specific input  variableNameData  are selected all suitable data are used. See also  NetCdfInfo ,  NetCdf2GriddedData ,  GriddedDataTimeSeries2NetCdf .', 'config_table': 'outputfileGriddedDataTimeSeries filename  inputfileNetCdf filename  variableNameLongitude string name of NetCDF variable variableNameLatitude string name of NetCDF variable variableNameTime string name of NetCDF variable) variableNameData string data variables, otherwise all suitable data are used R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'This program converts a COARDS compliant NetCDF file into <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">outputfileGriddedDataTimeSeries</a>. If no specific input <strong class="groops-config-element">variableNameData</strong> are selected all suitable data are used.</p><p>See also <a class="groops-program" href="NetCdfInfo.html">NetCdfInfo</a>, <a class="groops-program" href="NetCdf2GriddedData.html">NetCdf2GriddedData</a>, <a class="groops-program" href="GriddedDataTimeSeries2NetCdf.html">GriddedDataTimeSeries2NetCdf</a>.'},
'NetCdfInfo': { 'name': 'NetCdfInfo', 'key': 'NetCdfInfo', 'description': 'Print content information of a NetCDF file like dimensions, variables and attributes. See also  NetCdf2GriddedData ,  NetCdf2GriddedDataTimeSeries ,  GriddedData2NetCdf ,  GriddedDataTimeSeries2NetCdf .', 'config_table': 'inputfileNetCdf filename', 'display_text': 'Print content information of a NetCDF file like dimensions, variables and attributes.</p><p>See also <a class="groops-program" href="NetCdf2GriddedData.html">NetCdf2GriddedData</a>, <a class="groops-program" href="NetCdf2GriddedDataTimeSeries.html">NetCdf2GriddedDataTimeSeries</a>, <a class="groops-program" href="GriddedData2NetCdf.html">GriddedData2NetCdf</a>, <a class="groops-program" href="GriddedDataTimeSeries2NetCdf.html">GriddedDataTimeSeries2NetCdf</a>.'},
'NormalsSphericalHarmonics2Sinex': { 'name': 'NormalsSphericalHarmonics2Sinex', 'key': 'NormalsSphericalHarmonics2Sinex', 'description': 'Write potential coefficients and  normal equations  to  . See also  Sinex2Normals  and  GnssNormals2Sinex .', 'config_table': 'outputfileSinex filename solutions in SINEX format inputfileNormals filename normal equation matrix inputfileSolution filename parameter vector inputfileSigmax filename standard deviations of the parameters (sqrt of the diagonal of the inverse normal equation) inputfileApriori filename apriori parameter vector inputfileAprioriMatrix filename normal equation matrix of applied constraints time time reference time for parameters sinexHeader sequence  agencyCode string identify the agency providing the data timeStart time start time of the data timeEnd time end time of the data  observationCode string technique used to generate the SINEX solution constraintCode string 0: tight constraint, 1: siginficant constraint, 2: unconstrained solutionContent string solution types contained in the SINEX solution (S O E T C A) description string organizitions gathering/alerting the file contents contact string Address of the relevant contact. e-mail output string Description of the file contents input string Brief description of the input used to generate this solution software string Software used to generate the file hardware string Computer hardware on which above software was run inputfileComment filename comments in the comment block from a file (truncated at 80 characters) comment string comments in the comment block', 'display_text': 'Write potential coefficients and <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a> to <a href="http://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX format</a>.</p><p>See also <a class="groops-program" href="Sinex2Normals.html">Sinex2Normals</a> and <a class="groops-program" href="GnssNormals2Sinex.html">GnssNormals2Sinex</a>.'},
'Orbit2GroopsAscii': { 'name': 'Orbit2GroopsAscii', 'key': 'Orbit2GroopsAscii', 'description': 'Convert groops orbits and corresponding covariance information to ASCII format. The format is used to publish TUG orbits. It contains a two line header with a short description of the orbit defined in  firstLine . The orbit is rotated to the Earth fixed frame (TRF) with   Convert groops orbits and corresponding covariance information to ASCII format. The format is used to publish TUG orbits. It contains a two line header with a short description of the orbit defined in   and given as one line per epoch. The epoch lines contained time [MJD GPS time], position x, y and z [m], and the epoch covariance xx, yy, zz, xy, xz and yz [ ]. See also  GroopsAscii2Orbit .', 'config_table': 'outputfile filename  inputfileOrbit filename  inputfileCovariance filename  earthRotation earthRotationType  firstLine string Text for first line', 'display_text': 'Convert groops orbits and corresponding covariance information to ASCII format. The format is used to publish TUG orbits. It contains a two line header with a short description of the orbit defined in <strong class="groops-config-element">firstLine</strong>. The orbit is rotated to the Earth fixed frame (TRF) with <a class="groops-class" href="earthRotationType.html">earthRotation</a> and given as one line per epoch. The epoch lines contained time [MJD GPS time], position x, y and z [m], and the epoch covariance xx, yy, zz, xy, xz and yz [$m^2$].</p><p>See also <a class="groops-program" href="GroopsAscii2Orbit.html">GroopsAscii2Orbit</a>.'},
'Orbit2Sp3Format': { 'name': 'Orbit2Sp3Format', 'key': 'Orbit2Sp3Format', 'description': 'Writes orbits to  . SP3 orbits are usually given in the terrestrial reference frame (TRF), so providing   Writes orbits to   automatically rotates the orbits from the celestial reference frame (CRF) to the TRF. Since SP3 orbits often use the center of Earth as a reference, a correction from center of mass to center of Earth can be applied to the orbits by providing   Writes orbits to   (e.g. ocean tides). See also  Sp3Format2Orbit .', 'config_table': 'outputfile filename  satellite sequence  inputfileOrbit filename  inputfileClock filename  inputfileCovariance filename  identifier string 3 characters (e.g. GNSS PRN: G01) orbitAccuracy double [m] used for accuracy codes in header (0 = unknown) earthRotation earthRotationType rotate data into Earth-fixed frame gravityfield gravityfieldType degree 1 fluid mantle for CM2CE correction (SP3 orbits should be in center of Earth) comment string comment lines (77 char max) firstLine string Text for first line e.g:  u+U  IGb14 KIN ITSG writeVelocity boolean write velocity in addition to position useSp3kFormat boolean use the extended sp3k format', 'display_text': 'Writes orbits to <a href="https://files.igs.org/pub/data/format/sp3d.pdf">SP3 format</a>.</p><p>SP3 orbits are usually given in the terrestrial reference frame (TRF), so providing <a class="groops-class" href="earthRotationType.html">earthRotation</a> automatically rotates the orbits from the celestial reference frame (CRF) to the TRF. Since SP3 orbits often use the center of Earth as a reference, a correction from center of mass to center of Earth can be applied to the orbits by providing <a class="groops-class" href="gravityfieldType.html">gravityfield</a> (e.g. ocean tides).</p><p>See also <a class="groops-program" href="Sp3Format2Orbit.html">Sp3Format2Orbit</a>.'},
'PotentialCoefficients2Icgem': { 'name': 'PotentialCoefficients2Icgem', 'key': 'PotentialCoefficients2Icgem', 'description': 'Write spherical harmonics in ICGEM format. GROOPS uses this format as default but this program enables the possibility to include comments and set the modelname.', 'config_table': 'outputfile filename  inputfilePotentialCoefficients filename  inputfileTrend filename  oscillation sequence  inputfileCosPotentialCoefficients filename  inputfileSinPotentialCoefficients filename  period string period of oscillation [year] comment string comment in header inputfileComment filename file containing comments for header modelname string name of the model tideSystem choice tide system of model zero_tide   tide_free   minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius time time reference time', 'display_text': 'Write spherical harmonics in ICGEM format. GROOPS uses this format as default but this program enables the possibility to include comments and set the modelname.'},
'PsmslOceanBottomPressure2TimeSeries': { 'name': 'PsmslOceanBottomPressure2TimeSeries', 'key': 'PsmslOceanBottomPressure2TimeSeries', 'description': 'This programs reads ocean bottom pressure time series from the Permanent Service for Mean Sea Level (PSMSL). In addition to the OBP measurements, the recorder position can be written to a  grid file .', 'config_table': 'outputfileTimeSeries filename  outputfilePosition filename recorder position as gridded data inputfile filename  isDaily boolean  ignoreBadData boolean  R double  inverseFlattening double  timeSeries timeSeriesType', 'display_text': 'This programs reads ocean bottom pressure time series from the Permanent Service for Mean Sea Level (PSMSL).</p><p>In addition to the OBP measurements, the recorder position can be written to a <a class="groops-file" href="fileFormat_griddedData.html">grid file</a>.'},
'RinexObservation2GnssReceiver': { 'name': 'RinexObservation2GnssReceiver', 'key': 'RinexObservation2GnssReceiver', 'description': 'Converts   (version 2, 3, and 4) and   observation files to  GnssReceiver Instrument file . In case of   observation files containing GLONASS satellites, a mapping from PRN to frequency number must be provided via  inputfileMatrixPrn2FrequencyNumber  in the form of a  matrix file  with columns: GLONASS PRN, mjdStart, mjdEnd, frequencyNumber. Source for mapping:  http://semisys.gfz-potsdam.de/semisys/api/?symname=2002&format=json&satellite=GLO . RINEX v3+ observation files already contain this information.  Converts   and   Converts   can be used to filter the observation types that will be exported. If   Converts   is set, RINEX antenna and receiver info will be cross-checked with the provided file and warnings are raised in case of differences. A list of semi-codeless GPS receivers (observing C2D instead of C2W) can be provided via   Converts   in ASCII format with one receiver name per line. Observation types will be automatically corrected for these receivers. Some LEO satellites use special RINEX observation types, either from the unofficial RINEX v2.20 or custom ones. These can be provided via   Converts   in ASCII format. The file must  must contain a table with two columns, the first being the special type, and the second being the equivalent RINEX v3 type.', 'config_table': 'outputfileGnssReceiver filename  inputfileRinexObservation filename RINEX or Compact RINEX observation files inputfileMatrixPrn2FrequencyNumber filename (required for RINEX v2 files containing GLONASS observations) GROOPS matrix with columns: GLONASS PRN, SVN, mjdStart, mjdEnd, frequencyNumber inputfileStationInfo filename used to determine semi-codeless receivers and to cross-check antenna and receiver info inputfileSemiCodelessReceivers filename ASCII list with one receiver name per line inputfileSpecialObservationTypes filename ASCII table mapping special observation types to RINEX 3 types, e.g.: LA L1C useType gnssType only use observations that match any of these patterns ignoreType gnssType ignore observations that match any of these patterns', 'display_text': 'Converts <a href="https://files.igs.org/pub/data/format/rinex_4.00.pdf">RINEX</a> (version 2, 3, and 4) and <a href="https://terras.gsi.go.jp/ja/crx2rnx.html">Compact RINEX</a> observation files to <a class="groops-file" href="fileFormat_instrument.html">GnssReceiver Instrument file</a>.</p><p>In case of <a href="https://files.igs.org/pub/data/format/rinex211.txt">RINEX v2.x</a> observation files containing GLONASS satellites, a mapping from PRN to frequency number must be provided via <strong class="groops-config-element">inputfileMatrixPrn2FrequencyNumber</strong> in the form of a <a class="groops-file" href="fileFormat_matrix.html">matrix file</a> with columns: GLONASS PRN, mjdStart, mjdEnd, frequencyNumber. Source for mapping: <a href="http://semisys.gfz-potsdam.de/semisys/api/?symname=2002&format=json&satellite=GLO" target="_blank">http://semisys.gfz-potsdam.de/semisys/api/?symname=2002&format=json&satellite=GLO</a>. RINEX v3+ observation files already contain this information.</p><p><a class="groops-class" href="gnssType.html">useType</a> and <a class="groops-class" href="gnssType.html">ignoreType</a> can be used to filter the observation types that will be exported.</p><p>If <a class="groops-class" href="fileFormat_platform.html">inputfileStationInfo</a> is set, RINEX antenna and receiver info will be cross-checked with the provided file and warnings are raised in case of differences.</p><p>A list of semi-codeless GPS receivers (observing C2D instead of C2W) can be provided via <a class="groops-class" href="fileFormat_stringList.html">inputfileSemiCodelessReceivers</a> in ASCII format with one receiver name per line. Observation types will be automatically corrected for these receivers.</p><p>Some LEO satellites use special RINEX observation types, either from the unofficial RINEX v2.20 or custom ones. These can be provided via <a class="groops-class" href="fileFormat_stringTable.html">inputfileSpecialObservationTypes</a> in ASCII format. The file must  must contain a table with two columns, the first being the special type, and the second being the equivalent RINEX v3 type.</p><p>'},
'Sacc2Orbit': { 'name': 'Sacc2Orbit', 'key': 'Sacc2Orbit', 'description': 'This program reads in SACC orbit data.', 'config_table': 'outputfileOrbit filename  inputfile filename', 'display_text': 'This program reads in SACC orbit data.'},
'Sentinel2StarCamera': { 'name': 'Sentinel2StarCamera', 'key': 'Sentinel2StarCamera', 'description': 'This program reads in Sentinel-1/2/3 star camera data given in the special format.', 'config_table': 'outputfileStarCamera filename  inputfile filename', 'display_text': 'This program reads in Sentinel-1/2/3 star camera data given in the special format.'},
'SentinelXml2Orbit': { 'name': 'SentinelXml2Orbit', 'key': 'SentinelXml2Orbit', 'description': 'Read Sentinel orbits from XML format.', 'config_table': 'outputfileOrbit filename  earthRotation earthRotationType  inputfile filename', 'display_text': 'Read Sentinel orbits from XML format.'},
'Sinex2Normals': { 'name': 'Sinex2Normals', 'key': 'Sinex2Normals', 'description': 'Convert normal equations from   to  normal equations . See also  GnssNormals2Sinex  and  NormalsSphericalHarmonics2Sinex .', 'config_table': 'outputfileNormals filename N, n: unconstrained normal equations outputfileNormalsConstraint filename N0, n0: normal equations of applied constraints outputfileSolution filename x: parameter vector outputfileSolutionApriori filename x0: a priori parameter vector inputFileSinex filename', 'display_text': 'Convert normal equations from <a href="http://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX format</a> to <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a>.</p><p>See also <a class="groops-program" href="GnssNormals2Sinex.html">GnssNormals2Sinex</a> and <a class="groops-program" href="NormalsSphericalHarmonics2Sinex.html">NormalsSphericalHarmonics2Sinex</a>.'},
'Sinex2StationDiscontinuities': { 'name': 'Sinex2StationDiscontinuities', 'key': 'Sinex2StationDiscontinuities', 'description': 'Convert station discontinuities from   (e.g. ITRF14) to   Convert station discontinuities from   (MISCVALUE). A value of 1 means position discontinuity, a value of 2 means velocity discontinuity. Start and end epochs with value 0 are added in addition to the discontinuities from SINEX to define continuity interval borders. See also  Sinex2StationPosition  and  Sinex2StationPostSeismicDeformation .', 'config_table': 'outputfileInstrument filename loop variable is replaced with station name (e.g. wtzz) inputfileDiscontinuities filename SINEX (e.g. ITRF14) station discontinuities variableLoopStation string variable name for station loop stationName string only export these stations', 'display_text': 'Convert station discontinuities from <a href="http://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX format</a> (e.g. ITRF14) to <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrument</a> (MISCVALUE). A value of 1 means position discontinuity, a value of 2 means velocity discontinuity. Start and end epochs with value 0 are added in addition to the discontinuities from SINEX to define continuity interval borders.</p><p>See also <a class="groops-program" href="Sinex2StationPosition.html">Sinex2StationPosition</a> and <a class="groops-program" href="Sinex2StationPostSeismicDeformation.html">Sinex2StationPostSeismicDeformation</a>.'},
'Sinex2StationPositions': { 'name': 'Sinex2StationPositions', 'key': 'Sinex2StationPositions', 'description': 'Extracts station positions from  inputfileSinexSolution  ( ) and writes an   Extracts station positions from   of type VECTOR3D for each station.  Positions will be computed at   Extracts station positions from   based on position and velocity of each provided interval in the SINEX file. With  inputfileSinexDiscontinuities  the bounds of these time spans are adjusted to the exact epochs of discontinuities. The  inputfileSinexPostSeismicDeformations  adds the ITRF post-seismic deformation model to the affected stations. The  inputfileSinexFrequencies  adds annual and semi-annual frequencies. If  extrapolateBackward  or  extrapolateForward  are provided, positions will also be computed for epochs before the first interval/after the last interval, based on the position and velocity of the first/last interval. Position extrapolation will stop at the first discontinuity before the first interval/after the last interval. Stations can be limited via  stationName , otherwise all stations in  inputfileSinexSolution  will be used.', 'config_table': 'outputfileInstrument filename loop variable is replaced with station name (e.g. wtzz) variableLoopStation string variable name for station loop inputfileSinexSolution filename SINEX file inputfileSinexDiscontinuities filename SINEX file inputfileSinexPostSeismicDeformations filename SINEX file inputfileSinexFrequencies filename SINEX file (XYZ or ENU) timeSeries timeSeriesType compute positions for these epochs based on velocity extrapolateForward boolean also compute positions for epochs after last interval defined in SINEX file extrapolateBackward boolean also compute positions for epochs before first interval defined in SINEX file stationName string convert only these stations', 'display_text': 'Extracts station positions from <strong class="groops-config-element">inputfileSinexSolution</strong> (<a href="http://www.iers.org/IERS/EN/Organization/AnalysisCoordinator/SinexFormat/sinex.html">SINEX format description</a>) and writes an <a class="groops-class" href="fileFormat_instrument.html">outputfileInstrument</a> of type VECTOR3D for each station.  Positions will be computed at <a class="groops-class" href="timeSeriesType.html">timeSeries</a> based on position and velocity of each provided interval in the SINEX file. With <strong class="groops-config-element">inputfileSinexDiscontinuities</strong> the bounds of these time spans are adjusted to the exact epochs of discontinuities. The <strong class="groops-config-element">inputfileSinexPostSeismicDeformations</strong> adds the ITRF post-seismic deformation model to the affected stations. The <strong class="groops-config-element">inputfileSinexFrequencies</strong> adds annual and semi-annual frequencies.</p><p>If <strong class="groops-config-element">extrapolateBackward</strong> or <strong class="groops-config-element">extrapolateForward</strong> are provided, positions will also be computed for epochs before the first interval/after the last interval, based on the position and velocity of the first/last interval. Position extrapolation will stop at the first discontinuity before the first interval/after the last interval.</p><p>Stations can be limited via <strong class="groops-config-element">stationName</strong>, otherwise all stations in <strong class="groops-config-element">inputfileSinexSolution</strong> will be used.'},
'SinexMetadata2GlonassFrequencyNumber': { 'name': 'SinexMetadata2GlonassFrequencyNumber', 'key': 'SinexMetadata2GlonassFrequencyNumber', 'description': 'Create   Create   matrix from   with the columns: GLONASS PRN, SVN, mjdStart, mjdEnd, frequencyNumber. See also  RinexObservation2GnssReceiver .', 'config_table': 'outputfileMatrixPrn2FrequencyNumber filename GROOPS matrix with columns: GLONASS PRN, SVN, mjdStart, mjdEnd, frequencyNumber inputfileSinexMetadata filename IGS SINEX metadata file', 'display_text': 'Create <a class="groops-class" href="fileFormat_matrix.html">outputfileMatrixPrn2FrequencyNumber</a> matrix from <a href="https://www.igs.org/mgex/metadata/#metadata">IGS SINEX metadata format</a> with the columns: GLONASS PRN, SVN, mjdStart, mjdEnd, frequencyNumber.</p><p>See also <a class="groops-program" href="RinexObservation2GnssReceiver.html">RinexObservation2GnssReceiver</a>.'},
'SinexMetadata2SatelliteModel': { 'name': 'SinexMetadata2SatelliteModel', 'key': 'SinexMetadata2SatelliteModel', 'description': 'Create   Create   from  . If   Create   is provided it is used as a basis and values are updated from the metadata file. See also  SatelliteModelCreate .', 'config_table': 'outputfileSatelliteModel filename  inputfileSinexMetadata filename IGS SINEX metadata file inputfileSatelliteModel filename base satellite model svn string e.g. G040, R736, E204, C211', 'display_text': 'Create <a class="groops-class" href="fileFormat_satelliteModel.html">outputfileSatelliteModel</a> from <a href="https://www.igs.org/mgex/metadata/#metadata">IGS SINEX metadata format</a>.</p><p>If <a class="groops-class" href="fileFormat_satelliteModel.html">inputfileSatelliteModel</a> is provided it is used as a basis and values are updated from the metadata file.</p><p>See also <a class="groops-program" href="SatelliteModelCreate.html">SatelliteModelCreate</a>.'},
'Sp3Format2Orbit': { 'name': 'Sp3Format2Orbit', 'key': 'Sp3Format2Orbit', 'description': 'Read IGS orbits from   and write an  instrument file (ORBIT) . The additional  outputfileClock  is an  instrument file (MISCVALUE)  and  outputfileCovariance  is an  instrument file (COVARIANCE3D) . If   Read IGS orbits from   is provided the data are transformed from terrestrial (TRF) to celestial reference frame (CRF). Since SP3 orbits often use the center of Earth as a reference, a correction from center of Earth to center of mass can be applied to the orbits by providing   Read IGS orbits from   (e.g. ocean tides). See also  Orbit2Sp3Format .', 'config_table': 'outputfileOrbit filename  outputfileClock filename  outputfileCovariance filename 3x3 epoch covariance satelliteIdentifier string e.g. L09 for GRACE A, empty: take first satellite earthRotation earthRotationType rotation from TRF to CRF gravityfield gravityfieldType degree 1 fluid mantle for CM2CE correction (SP3 orbits should be in center of Earth) inputfile filename orbits in SP3 format', 'display_text': 'Read IGS orbits from <a href="https://files.igs.org/pub/data/format/sp3d.pdf">SP3 format</a> and write an <a class="groops-file" href="fileFormat_instrument.html">instrument file (ORBIT)</a>. The additional <strong class="groops-config-element">outputfileClock</strong> is an <a class="groops-file" href="fileFormat_instrument.html">instrument file (MISCVALUE)</a> and <strong class="groops-config-element">outputfileCovariance</strong> is an <a class="groops-file" href="fileFormat_instrument.html">instrument file (COVARIANCE3D)</a>.</p><p>If <a class="groops-class" href="earthRotationType.html">earthRotation</a> is provided the data are transformed from terrestrial (TRF) to celestial reference frame (CRF). Since SP3 orbits often use the center of Earth as a reference, a correction from center of Earth to center of mass can be applied to the orbits by providing <a class="groops-class" href="gravityfieldType.html">gravityfield</a> (e.g. ocean tides).</p><p>See also <a class="groops-program" href="Orbit2Sp3Format.html">Orbit2Sp3Format</a>.'},
'Swarm2Starcamera': { 'name': 'Swarm2Starcamera', 'key': 'Swarm2Starcamera', 'description': 'This program reads SWARM star camera data given in the cdf format and before converted to an ascii file using the program  cdfexport  provided by the Goddard Space Flight Center ( http://cdf.gsfc.nasa.gov/ ).', 'config_table': 'outputfileStarCamera filename  earthRotation earthRotationType  inputfile filename', 'display_text': 'This program reads SWARM star camera data given in the cdf format and before converted to an ascii file using the program <code>cdfexport</code> provided by the Goddard Space Flight Center (<a href="http://cdf.gsfc.nasa.gov/" target="_blank">http://cdf.gsfc.nasa.gov/</a>).'},
'TerraSarTandem2Orbit': { 'name': 'TerraSarTandem2Orbit', 'key': 'TerraSarTandem2Orbit', 'description': 'This program reads in TerraSar-X or Tandem-X orbits in the special CHORB format and takes the appropriate time frame as stated in the document header. A description of the format can be found under:  http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-002.pdf', 'config_table': 'outputfileOrbit filename  earthRotation earthRotationType  inputfile filename orbits in CHORB format', 'display_text': 'This program reads in TerraSar-X or Tandem-X orbits in the special CHORB format and takes the appropriate time frame as stated in the document header. A description of the format can be found under: <a href="http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-002.pdf" target="_blank">http://op.gfz-potsdam.de/champ/docs_CHAMP/CH-GFZ-FD-002.pdf</a>'},
'TerraSarTandem2StarCamera': { 'name': 'TerraSarTandem2StarCamera', 'key': 'TerraSarTandem2StarCamera', 'description': 'This program reads in TerraSar-X or Tandem-X star camera data given in the special format.', 'config_table': 'outputfileStarCamera filename  inputfile filename', 'display_text': 'This program reads in TerraSar-X or Tandem-X star camera data given in the special format.'},
'Tle2Orbit': { 'name': 'Tle2Orbit', 'key': 'Tle2Orbit', 'description': 'This program computes the   This program computes the   from two-line elements (TLE/3LE) as can be found at e.g.  http://celestrak.org/NORAD/elements/ . The first satellite in the input file that matches the wildcard of  satelliteName  is used. The program uses the Simplified General Perturbation (SGP) model. More information can be found in the Revisiting Spacetrack Report 3 by Vallado et al. 2006.', 'config_table': 'outputfileOrbit filename  inputfileTLE filename two line elements (TLE/3LE) satelliteName string first name of wildcard match is used timeSeries timeSeriesType output orbit at these times earthRotation earthRotationType rotation to CRF', 'display_text': 'This program computes the <a class="groops-class" href="fileFormat_instrument.html">outputfileOrbit</a> from two-line elements (TLE/3LE) as can be found at e.g. <a href="http://celestrak.org/NORAD/elements/" target="_blank">http://celestrak.org/NORAD/elements/</a>. The first satellite in the input file that matches the wildcard of <strong class="groops-config-element">satelliteName</strong> is used.</p><p>The program uses the Simplified General Perturbation (SGP) model. More information can be found in the Revisiting Spacetrack Report 3 by Vallado et al. 2006.'},
'ViennaMappingFunctionGrid2File': { 'name': 'ViennaMappingFunctionGrid2File', 'key': 'ViennaMappingFunctionGrid2File', 'description': 'This program converts the gridded time series of the Vienna Mapping Functions (VMF) into the  GROOPS file format . Gridded VMF data is available at:  https://vmf.geo.tuwien.ac.at/trop_products/GRID/', 'config_table': 'outputfileVmfCoefficients filename  inputfile filename files must be given for each point in time timeSeries timeSeriesType times of input files deltaLambda angle [deg] sampling in longitude deltaPhi angle [deg] sampling in latitude isCellRegistered boolean grid points represent cells (VMF3), not grid corners (VMF1)', 'display_text': 'This program converts the gridded time series of the Vienna Mapping Functions (VMF) into the <a class="groops-file" href="fileFormat_griddedDataTimeSeries.html">GROOPS file format</a>.</p><p>Gridded VMF data is available at: <a href="https://vmf.geo.tuwien.ac.at/trop_products/GRID/" target="_blank">https://vmf.geo.tuwien.ac.at/trop_products/GRID/</a>'},
'ViennaMappingFunctionStation2File': { 'name': 'ViennaMappingFunctionStation2File', 'key': 'ViennaMappingFunctionStation2File', 'description': 'Converts Vienna Mapping Functions (VMF) station time series into  GROOPS file format . Station-wise VMF data for GNSS is available at:  https://vmf.geo.tuwien.ac.at/trop_products/GNSS/', 'config_table': 'outputfileVmfCoefficients filename  inputfileStationInfo filename  inputfileStation filename  inputfileVmf filename', 'display_text': 'Converts Vienna Mapping Functions (VMF) station time series into <a class="groops-file" href="fileFormat_griddedDataTimeSeries.html">GROOPS file format</a>.</p><p>Station-wise VMF data for GNSS is available at: <a href="https://vmf.geo.tuwien.ac.at/trop_products/GNSS/" target="_blank">https://vmf.geo.tuwien.ac.at/trop_products/GNSS/</a>'},
'GridRectangular2NetCdf': { 'name': 'GridRectangular2NetCdf', 'key': 'GridRectangular2NetCdf', 'description': 'DEPRECATED. Please use  GriddedData2NetCdf  or  GriddedDataTimeSeries2NetCdf  instead.', 'config_table': 'outputfileNetCdf filename file name of NetCDF output inputfileGridRectangular filename input grid sequence times timeSeriesType values for time axis (COARDS specification) dataVariable sequence metadata for data variables selectDataField uint input data column name string netCDF variable name dataType choice  double   float   int   attribute choice netCDF attributes text sequence  name string  value string  value sequence  name string  value double  dataType choice  double   float   int   globalAttribute choice additional meta data text sequence  name string  value string  value sequence  name string  value double  dataType choice  double   float   int', 'display_text': 'DEPRECATED. Please use <a class="groops-program" href="GriddedData2NetCdf.html">GriddedData2NetCdf</a> or <a class="groops-program" href="GriddedDataTimeSeries2NetCdf.html">GriddedDataTimeSeries2NetCdf</a> instead.'},
'NetCdf2GridRectangular': { 'name': 'NetCdf2GridRectangular', 'key': 'NetCdf2GridRectangular', 'description': 'DEPRECATED. Please use  NetCdf2GriddedData  or  NetCdf2GriddedDataTimeSeries  instead.', 'config_table': 'outputfileGridRectangular filename One grid for each epoch in the NetCDF file is written. Use loopTimeVariable as template. loopTimeVariable string  inputfileNetCdf filename  variableNameLongitude string name of NetCDF variable variableNameLatitude string name of NetCDF variable variableNameTime string name of NetCDF variable (leave blank for static grids) variableNameData string name of NetCDF variable R double reference radius for ellipsoidal coordinates inverseFlattening double reference flattening for ellipsoidal coordinates', 'display_text': 'DEPRECATED. Please use <a class="groops-program" href="NetCdf2GriddedData.html">NetCdf2GriddedData</a> or <a class="groops-program" href="NetCdf2GriddedDataTimeSeries.html">NetCdf2GriddedDataTimeSeries</a> instead.'},
'Sinex2StationPosition': { 'name': 'Sinex2StationPosition', 'key': 'Sinex2StationPosition', 'description': 'DEPRECATED. Please use  Sinex2StationPositions  instead.', 'config_table': 'outputfileInstrument filename loop variable is replaced with station name (e.g. wtzz) inputfileSinex filename SINEX file (.snx or .ssc) inputfileDiscontinuities filename discontinuities file per station; loop variable is replaced with station name (e.g. wtzz) variableLoopStation string variable name for station loop stationName string convert only these stations timeSeries timeSeriesType compute positions for these epochs based on velocity extrapolateForward boolean also compute positions for epochs after last interval defined in SINEX file extrapolateBackward boolean also compute positions for epochs before first interval defined in SINEX file', 'display_text': 'DEPRECATED. Please use <a class="groops-program" href="Sinex2StationPositions.html">Sinex2StationPositions</a> instead.'},
'Sinex2StationPostSeismicDeformation': { 'name': 'Sinex2StationPostSeismicDeformation', 'key': 'Sinex2StationPostSeismicDeformation', 'description': 'DEPRECATED. Please use  Sinex2StationPositions  instead.', 'config_table': 'outputfileInstrument filename deformation time series inputfileSinex filename ITRF post-seismic deformation SINEX file timeSeries timeSeriesType compute deformation for these epochs stationName string  localLevelFrame boolean output in North, East, Up local-level frame', 'display_text': 'DEPRECATED. Please use <a class="groops-program" href="Sinex2StationPositions.html">Sinex2StationPositions</a> instead.'},
'autoregressiveModelSequenceType': { 'name': 'autoregressiveModelSequenceType', 'key': 'autoregressiveModelSequenceType', 'description': 'Represents a sequence of multivariate autoregressive (AR) models with increasing order  . The AR models should be stored as  matrix file  in the  GROOPS definition of AR models . The required AR models can be computed with  CovarianceMatrix2AutoregressiveModel , and passed to this class through  inputfileAutoregressiveModel  in increasing order. The main purpose of AutoregressiveModelSequence is to use AR models of the form  to create pseudo-observation equations  with  used to constrain high-frequency temporal gravity field variations (see  KalmanSmootherLeastSquares ,  NormalsBuildShortTimeStaticLongTime ,  PreprocessingSst ). The corresponding normal equation coefficient matrix is given by  and if all AR models are estimated from the same sample its inverse is a block-Toeplitz covariance matrix  which can be computed using  AutoregressiveModel2CovarianceMatrix . A detailed description with applications can be found in: Kvas, A., Mayer-Grr, T. GRACE gravity field recovery with background model uncertainties. J Geod 93, 25432552 (2019).  https://doi.org/10.1007/s00190-019-01314-1', 'config_table': 'autoregressiveModelSequenceType sequence  inputfileAutoregressiveModel filename matrix file containing an AR model sigma0 double a-priori sigma for white noise covariance', 'display_text': 'Represents a sequence of multivariate autoregressive (AR) models with increasing order $p$. The AR models should be stored as <a class="groops-file" href="fileFormat_matrix.html">matrix file</a> in the <a class="groops-ref" href="fundamentals.autoregressiveModel.html">GROOPS definition of AR models</a>. The required AR models can be computed with <a class="groops-program" href="CovarianceMatrix2AutoregressiveModel.html">CovarianceMatrix2AutoregressiveModel</a>, and passed to this class through <strong class="groops-config-element">inputfileAutoregressiveModel</strong> in increasing order.</p><p>The main purpose of AutoregressiveModelSequence is to use AR models of the form \\[   \\label{eq:ar-model}   \\mathbf{y}_e(t_i) = \\sum_{k=1}^p \\mathbf{\\Phi}^{(p)}_k\\mathbf{y}_e(t_{i-k}) + \\mathbf{w}(t_i),   \\hspace{5pt} \\mathbf{w}(t_i) \\sim \\mathcal{N}(0, \\mathbf{\\Sigma}^{(p)}_\\mathbf{w}), \\]to create pseudo-observation equations \\[   \\label{eq:pseudo-observations-transformed}   0 = \\bar{\\mathbf{\\Phi}} \\Delta\\mathbf{y} + \\bar{\\mathbf{w}}, \\hspace{5pt} \\bar{\\mathbf{w}} \\sim   \\mathcal{N}(0, \\bar{\\mathbf{\\Sigma}}_{\\bar{\\mathbf{w}}}), \\]with \\[   \\label{eq:pseudo-observations-ar}   \\bar{\\mathbf{\\Phi}} =   \\begin{bmatrix}     \\mathbf{I} & & & & & \\\\     -\\mathbf{\\Phi}^{(1)}_1 & \\mathbf{I} & & & &  \\\\     -\\mathbf{\\Phi}^{(2)}_2 & -\\mathbf{\\Phi}^{(2)}_1 & \\mathbf{I} & & & \\\\     -\\mathbf{\\Phi}^{(3)}_3 & -\\mathbf{\\Phi}^ {(3)}_2 & -\\mathbf{\\Phi}^ {(3)}_1 & \\mathbf{I} & &  \\\\     & -\\mathbf{\\Phi}^{(3)}_3 & -\\mathbf{\\Phi}^ {(3)}_2 & -\\mathbf{\\Phi}^ {(3)}_1 & \\mathbf{I} &  \\\\     & & \\ddots & \\ddots & \\ddots & \\ddots  \\\\   \\end{bmatrix},   \\hspace{15pt}   \\bar{\\mathbf{\\Sigma}}_{\\bar{\\mathbf{w}}} =   \\bar{\\mathbf{\\Sigma}}_{\\bar{\\mathbf{w}}} =   \\begin{bmatrix}     \\mathbf{\\Sigma}^{(0)}_{\\mathbf{w}} & & & & & \\\\     & \\mathbf{\\Sigma}^{(1)}_{\\mathbf{w}} & & & & \\\\     & & \\mathbf{\\Sigma}^{(2)}_{\\mathbf{w}} & & & \\\\     & & & \\mathbf{\\Sigma}^{(3)}_{\\mathbf{w}} & & \\\\     & & & & \\mathbf{\\Sigma}^{(3)}_{\\mathbf{w}} &  \\\\     & & & & & \\ddots \\\\   \\end{bmatrix}. \\]used to constrain high-frequency temporal gravity field variations (see <a class="groops-program" href="KalmanSmootherLeastSquares.html">KalmanSmootherLeastSquares</a>, <a class="groops-program" href="NormalsBuildShortTimeStaticLongTime.html">NormalsBuildShortTimeStaticLongTime</a>, <a class="groops-program" href="PreprocessingSst.html">PreprocessingSst</a>).</p><p>The corresponding normal equation coefficient matrix is given by \\[   \\label{eq:ar-normals}   \\bar{\\mathbf{\\Phi}}^T\\bar{\\mathbf{\\Sigma}}^{-1}_{\\bar{\\mathbf{w}}}\\bar{\\mathbf{\\Phi}} \\]and if all AR models are estimated from the same sample its inverse is a block-Toeplitz covariance matrix \\[   (\\mathbf{\\Sigma}_{\\mathbf{y}_m})_{ij} =   \\begin{cases}  \\mathbf{\\Sigma}(|j-i|) & \\text{for } i \\leq j \\\\  \\mathbf{\\Sigma}(|j-i|))^T & \\text{otherwise}  \\end{cases}, \\]which can be computed using <a class="groops-program" href="AutoregressiveModel2CovarianceMatrix.html">AutoregressiveModel2CovarianceMatrix</a>.</p><p>A detailed description with applications can be found in: Kvas, A., Mayer-Grr, T. GRACE gravity field recovery with background model uncertainties. J Geod 93, 25432552 (2019). <a href="https://doi.org/10.1007/s00190-019-01314-1" target="_blank">https://doi.org/10.1007/s00190-019-01314-1</a>'},
'borderType': { 'name': 'borderType', 'key': 'borderType', 'description': 'With this class you can select one or more region on the surface of the Earth. In every instance of Border you can choose whether the specific region is excluded from the overall result with the switch  exclude . To determine whether a specific point will be used furthermore the following algorithm will be applied: In a first step all points are selected if first border excludes points otherwise all points excluded. When every point will be tested for each instance of border from top to bottom. If the point is not in the selected region nothing happens. Otherwise it will included or excluded depending on the switch  exclude . First Example: The border excludes all continental areas. The result are points on the oceans only. Second Example: First border describes the continent north america. The next borders excludes the great lakes and the last border describes Washington island. In this configuration points are selected if they are inside north america but not in the area of the great lakes. But if the point is on Washington island it will be included again.     The region is restricted along lines of geographical coordinates.  minPhi  and  maxPhi  describe the lower and the upper bound of the region.  minLambda  and  maxLambda  define the left and right bound.     The region is defined by a spherical cap with the center given in geographical coordinates longitude ( lambdaCenter ) and latitude ( phiCenter ). The radius of the cap is given as aperture angle  psi .      The region is defined by     containing one or more polygons given in longitude and latitude. An additional  buffer  around the polygon can be defined. Use a negative value to shrink the polygon area.', 'config_table': 'minLambda angle  maxLambda angle  minPhi angle  maxPhi angle  exclude boolean dismiss points inside lambdaCenter angle longitude of the center of the cap phiCenter angle latitude of the center of the cap psi angle aperture angle (radius) exclude boolean dismiss points inside inputfilePolygon filename  buffer double buffer around polygon [km], <0: inside exclude boolean dismiss points inside', 'display_text': 'With this class you can select one or more region on the surface of the Earth. In every instance of Border you can choose whether the specific region is excluded from the overall result with the switch <strong class="groops-config-element">exclude</strong>. To determine whether a specific point will be used furthermore the following algorithm will be applied: In a first step all points are selected if first border excludes points otherwise all points excluded. When every point will be tested for each instance of border from top to bottom. If the point is not in the selected region nothing happens. Otherwise it will included or excluded depending on the switch <strong class="groops-config-element">exclude</strong>.</p><p>First Example: The border excludes all continental areas. The result are points on the oceans only.</p><p>Second Example: First border describes the continent north america. The next borders excludes the great lakes and the last border describes Washington island. In this configuration points are selected if they are inside north america but not in the area of the great lakes. But if the point is on Washington island it will be included again.  <h2>Rectangle</h2><p> The region is restricted along lines of geographical coordinates. <strong class="groops-config-element">minPhi</strong> and <strong class="groops-config-element">maxPhi</strong> describe the lower and the upper bound of the region. <strong class="groops-config-element">minLambda</strong> and <strong class="groops-config-element">maxLambda</strong> define the left and right bound.  <h2>Cap</h2><p> The region is defined by a spherical cap with the center given in geographical coordinates longitude (<strong class="groops-config-element">lambdaCenter</strong>) and latitude (<strong class="groops-config-element">phiCenter</strong>). The radius of the cap is given as aperture angle <strong class="groops-config-element">psi</strong>.</p><p>  <h2 id="polygon">Polygon</h2><p> The region is defined by <a class="groops-class" href="fileFormat_polygon.html">inputfilePolygon</a> containing one or more polygons given in longitude and latitude. An additional <strong class="groops-config-element">buffer</strong> around the polygon can be defined. Use a negative value to shrink the polygon area.'},
'conditionType': { 'name': 'conditionType', 'key': 'conditionType', 'description': 'Test for conditions. See  Loop and conditions  for usage.     Check for a file or directory existing.     Execute command and check success.     Evaluate expression.     Evaluate elements of a     based on an expression. If  all = yes , all elements of the matrix must evaluate to true for the condition to be fulfilled, otherwise any element evaluating to true is sufficient.     Evaluate if  matrix  (or  instrument ) file is empty/has zero size.     Determines if there is a match between a pattern or a regular expression and some subsequence in a string.     Determines if a pattern or a regular expression matches the entire string.     All conditions must be met (with short-circuit evaluation).     One of the conditions must be met (with short-circuit evaluation).     The result of the condition is inverted.', 'config_table': 'file filename  command filename  silently boolean without showing the output. expression expression  matrix matrixGeneratorType expression is evaluated for each element of resulting matrix expression expression (variable: data) evaluated for each element all boolean all (=yes)/any (=no) elements must evaluate to true inputfileMatrix filename  string filename should contain a {variable} pattern filename  isRegularExpression boolean pattern is  a regular expression caseSensitive boolean treat lower and upper case as distinct string filename should contain a {variable} pattern filename  isRegularExpression boolean pattern is  a regular expression caseSensitive boolean treat lower and upper case as distinct condition conditionType  condition conditionType  condition conditionType', 'display_text': 'Test for conditions. See <a class="groops-ref" href="general.loopsAndConditions.html">Loop and conditions</a> for usage.  <h2>FileExist</h2><p> Check for a file or directory existing.  <h2>Command</h2><p> Execute command and check success.  <h2>Expression</h2><p> Evaluate expression.  <h2>Matrix</h2><p> Evaluate elements of a <a class="groops-class" href="matrixGeneratorType.html">matrix</a> based on an expression. If <strong class="groops-config-element">all</strong>=<code>yes</code>, all elements of the matrix must evaluate to true for the condition to be fulfilled, otherwise any element evaluating to true is sufficient.  <h2>MatrixEmpty</h2><p> Evaluate if <a class="groops-file" href="fileFormat_matrix.html">matrix</a> (or <a class="groops-file" href="fileFormat_instrument.html">instrument</a>) file is empty/has zero size.  <h2>StringContainsPattern</h2><p> Determines if there is a match between a pattern or a regular expression and some subsequence in a string.  <h2>StringMatchPattern</h2><p> Determines if a pattern or a regular expression matches the entire string.  <h2>And</h2><p> All conditions must be met (with short-circuit evaluation).  <h2>Or</h2><p> One of the conditions must be met (with short-circuit evaluation).  <h2>Not</h2><p> The result of the condition is inverted.'},
'covariancePodType': { 'name': 'covariancePodType', 'key': 'covariancePodType', 'description': 'Provides arc wise covariance matrices for precise orbit data. Temporal correlations are modeled in the orbit system (along, cross, radial). The     provides temporal covariance functions for each axis. From the diagonal matrix for each time step  the Toeplitz covariance matrix for an arc is constructed   The epoch wise   covariance matrices given by     are eigen value decomposed  where   is an orthgonal matrix and   diagonal. This used to split the covariances matrices  and to compose a block diagonal matrix for an arc   The complete covariance matrix of an arc is given by  where  sigma    is an overall factor and the arc specific factors   can be provided with    . The last matrix can be used to downweight outliers in single epochs and will be added if     is provided.', 'config_table': 'covariancePodType sequence  sigma double general variance factor inputfileSigmasPerArc filename different accuaries for each arc (multplicated with sigma) inputfileSigmasPerEpoch filename different accuaries for each epoch (added) inputfileCovarianceFunction filename covariances in time for along, cross, and radial direction inputfileCovariancePodEpoch filename 3x3 epoch wise covariances', 'display_text': 'Provides arc wise covariance matrices for precise orbit data. Temporal correlations are modeled in the orbit system (along, cross, radial). The <a class="groops-class" href="fileFormat_matrix.html">inputfileCovarianceFunction</a> provides temporal covariance functions for each axis. From the diagonal matrix for each time step \\[   Cov_{3\\times3}(t) = \\text{diag}(cov_x(t), cov_y(t), cov_z(t)) \\]the Toeplitz covariance matrix for an arc is constructed \\[   \\M C = \\begin{pmatrix}     Cov(t_0) & Cov(t_1) & \\cdots   &          &        &        \\\\     Cov(t_1) & Cov(t_0) & Cov(t_1) & \\cdots   &        &        \\\\     \\cdots   & Cov(t_1) & Cov(t_0) & Cov(t_1) & \\cdots &        \\\\              & \\cdots   & \\ddots   & \\ddots   & \\ddots & \\cdots \\\\   \\end{pmatrix} \\] The epoch wise $3\\times3$ covariance matrices given by <a class="groops-class" href="fileFormat_instrument.html">inputfileCovariancePodEpoch</a> are eigen value decomposed \\[   \\M C_{3\\times3}(t_i) = \\M Q \\M\\Lambda \\M Q^T, \\]where $\\M Q$ is an orthgonal matrix and $\\M\\Lambda$ diagonal. This used to split the covariances matrices \\[   \\M C_{3\\times3}(t_i) = \\M D(t_i) \\M D(t_i)^T = (\\M Q \\M\\Lambda^{1/2} \\M Q^T)(\\M Q \\M\\Lambda^{1/2} \\M Q^T)^T, \\]and to compose a block diagonal matrix for an arc \\[   \\M D = \\text{diag}(\\M D(t_1), \\M D(t_2), \\ldots, \\M D(t_2)). \\] The complete covariance matrix of an arc is given by \\[   \\M C_{arc} = \\sigma_0^2 \\sigma_{arc}^2 \\M D \\M C \\M D^T +   \\text{diag}(\\sigma_1^2\\M I_{3\\times3}, \\sigma_2^2\\M I_{3\\times3}, \\ldots, \\sigma_n^2\\M I_{3\\times3}) \\]where <strong class="groops-config-element">sigma</strong> $\\sigma_0$ is an overall factor and the arc specific factors $\\sigma_{arc}$ can be provided with <a class="groops-class" href="fileFormat_matrix.html">inputfileSigmasPerArc</a>. The last matrix can be used to downweight outliers in single epochs and will be added if <a class="groops-class" href="fileFormat_instrument.html">inputfileSigmasPerEpoch</a> is provided.'},
'covarianceSstType': { 'name': 'covarianceSstType', 'key': 'covarianceSstType', 'description': 'Provides arc wise covariance matrices for satellite-to-satellite observations SST). The     provides a temporal covariance function. From it the Toeplitz covariance matrix is constructed   The complete covariance matrix of an arc is given by  where  sigma    is an overall factor and the arc specific factors   can be provided with    . The second term describes general covariance matrices for each arc     together with the factors   from  sigmasCovarianceMatrixArc . The last matrix can be used to downweight outliers in single epochs and will be added if     is provided.', 'config_table': 'covarianceSstType sequence  sigma double general variance factor inputfileSigmasPerArc filename different accuaries for each arc (multplicated with sigma) inputfileSigmasPerEpoch filename different accuaries for each epoch (added) inputfileCovarianceFunction filename covariance function in time inputfileCovarianceMatrixArc filename one matrix file per arc. Use {arcNo} as template sigmasCovarianceMatrixArc filename vector with one sigma for each covarianceMatrixArc', 'display_text': 'Provides arc wise covariance matrices for satellite-to-satellite observations SST). The <a class="groops-class" href="fileFormat_matrix.html">inputfileCovarianceFunction</a> provides a temporal covariance function. From it the Toeplitz covariance matrix is constructed \\[   \\M C = \\begin{pmatrix}     cov(t_0) & cov(t_1) & \\cdots   &          &        &        \\\\     cov(t_1) & cov(t_0) & cov(t_1) & \\cdots   &        &        \\\\     \\cdots   & cov(t_1) & cov(t_0) & cov(t_1) & \\cdots &        \\\\              & \\cdots   & \\ddots   & \\ddots   & \\ddots & \\cdots \\\\   \\end{pmatrix} \\\\ \\] The complete covariance matrix of an arc is given by \\[   \\M C_{arc} = \\sigma_0^2 \\sigma_{arc}^2 \\M C + \\sigma_{S,arc}^2 \\M S_{arc}+ \\text{diag}(\\sigma_1^2, \\sigma_2^2, \\ldots, \\sigma_n^2) \\]where <strong class="groops-config-element">sigma</strong> $\\sigma_0$ is an overall factor and the arc specific factors $\\sigma_{arc}$ can be provided with <a class="groops-class" href="fileFormat_matrix.html">inputfileSigmasPerArc</a>. The second term describes general covariance matrices for each arc <a class="groops-class" href="fileFormat_matrix.html">inputfileCovarianceMatrixArc</a> together with the factors $\\sigma_{S,arc}$ from <strong class="groops-config-element">sigmasCovarianceMatrixArc</strong>. The last matrix can be used to downweight outliers in single epochs and will be added if <a class="groops-class" href="fileFormat_instrument.html">inputfileSigmasPerEpoch</a> is provided.</p><p>'},
'digitalFilterType': { 'name': 'digitalFilterType', 'key': 'digitalFilterType', 'description': 'Digital filter implementation for the filtering of equally spaced time series. This class implements the filter equations as  where   is the autoregressive (AR) order and   is the moving average (MA) order. Note that the MA part can also be non-causal. The characteristics of a filter cascade can be computed by the programs  DigitalFilter2FrequencyResponse  and  DigitalFilter2ImpulseResponse . To apply a filter cascade to a time series (or an instrument file ) use  InstrumentFilter . Each filter can be applyed in forward and backward direction by setting  backwardDirection . If the same filter is applied in both directions, the combined filter has zero phase and the squared magnitude response. Setting  inFrequencyDomain  to true applies the transfer function of the filter to the DFT of the input and synthesizes the result, i.e.:  This is equivalent to setting  padType  to  periodic . To reduce warmup effects, the input time series can be padded by choosing a  padType :    none : no padding is applied  zero : zeros are appended at the beginning and end of the input time series  constant : the beginning of the input time series is padded with the first value, the end is padded with the last value  periodic : periodic continuation of the input time series (i.,e. the beginning is padded with the last epochs and the end is padded with the first epochs)  symmetric : beginning and end are reflected around the first and last epoch respectively       Moving average (boxcar) filter. For odd lengths, this filter is symmetric and has therefore no phase shift. For even lengths, a phase shift of half a cycle is introduced.     Moving median filter of length  . The filter output at epoch   is the median of the set start at   to  . The filter length   should be uneven to avoid a phase shift.     Symmetric MA filter for numerical differentiation using polynomial approximation. The input time series is approximated by a moving polynomial of degree  polynomialDegree , by solving  for each time step   (  is the  sampling  of the time series). The filter coefficients for the  -th derivative are obtained by taking the appropriate row of the inverse coefficient matrix  :  The  polynomialDegree  should be even if no phase shift should be introduced.     Numerical integration using polynomial approximation. The input time series is approximated by a moving polynomial of degree  polynomialDegree  by solving  for each time step   (  is the  sampling  of the time series). The numerical integral for each time step   is approximated by the center interval of the estimated polynomial. polynomialDegree  should be even to avoid a phase shift.     Correlation ( ) of  corr  is introduced into the time series:      Low pass and differentation filter as used for GRACE KBR and ACC data in the Level1A processing.      Digital implementation of the Butterworth filter. The design of the filter is done by modifying the analog (continuous time) transfer function, which is then transformed into the digital domain by using the bilinear transform. The filter coefficients are then determined by a least squares adjustment in time domain. The  filterType  can be  lowpass ,  highpass , where one cutoff frequency has to be specified, and  bandpass  and  bandstop  where to cutoff frequencies have to be specified. Cutoff frequencies must be given as normalized frequency  . For a cutoff frequency of 30 mHz for a time series sampled with 5 seconds gives a normalized frequency of  .     Read filter coefficients of   from a coefficient file. One column might define the index   of the coefficients   and   in the other columns.     Filter representation of a wavelet.     Implemented after Christian Siemes\' dissertation, page 106.      Moving average decorrelation filter based on eigendecomposition of a Toeplitz covariance matrix.     Lag operator in digital filter representation.     Removes the filtered signal from the input, i.e. the input is passed through a     with a frequency response of  .', 'config_table': 'length uint number of epochs in averaging operator inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges length uint length of the moving window [epochs] padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges polynomialDegree uint degree of approximation polynomial derivative uint take kth derivative sampling double assumed time step between points padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges polynomialDegree uint degree of approximation polynomial sampling double assumed time step between points padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges correlation double correlation backwardDirection boolean apply filter in backward direction inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges rawDataRate double sampling frequency in Hz (fs). convolutionNumber uint number of self convolutions of the filter kernel fitInterval double length of the filter kernel [seconds] lowPassBandwith double target low pass bandwidth normFrequency double norm filter at this frequency [Hz] (default: GRACE dominant (J2) signal frequency) reduceQuadraticFit boolean remove->filter->restore quadratic fit derivative choice  derivative1st  range rate derivative2nd  range acceleration inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges order uint filter order type choice filter type lowpass sequence  Wn double normalized cutoff frequency (f_c / f_nyq) highpass sequence  Wn double normalized cutoff frequency (f_c / f_nyq) bandpass sequence  Wn1 double lower normalized cutoff frequency (f_c / f_nyq) Wn2 double upper normalized cutoff frequency (f_c / f_nyq) bandstop sequence  Wn1 double lower normalized cutoff frequency (f_c / f_nyq) Wn2 double upper normalized cutoff frequency (f_c / f_nyq) backwardDirection boolean apply filter in backward direction inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges inputfileMatrix filename matrix with filter coefficients index expression index of coefficients (input columns are named data0, data1, ...) bn expression MA coefficients (moving average) (input columns are named data0, data1, ...) an expression AR coefficients (autoregressive) (input columns are named data0, data1, ...) backwardDirection boolean apply filter in backward direction inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges inputfileWavelet filename wavelet coefficients type choice filter type lowpass   highpass   level uint compute filter for specific decomposition level backwardDirection boolean apply filter in backward direction inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges notchFrequency double normalized notch frequency w_n = (f_n/f_nyq) bandWidth double bandwidth at -3db. Quality factor of filter Q = w_n/bw backwardDirection boolean apply filter in backward direction inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges inputfileCovarianceFunction filename covariance function of time series inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges lag int lag epochs: 1 (lag); -1 (lead) inFrequencyDomain boolean apply filter in frequency domain padType choice  none  no padding is applied zero  zero padding constant  pad using first and last value periodic  periodic continuation of matrix symmetric  symmetric continuation around the matrix edges filter digitalFilterType remove filter output from input signal', 'display_text': 'Digital filter implementation for the filtering of equally spaced time series. This class implements the filter equations as \\[\\label{digitalFilterType:arma}   \\sum_{l=0}^Q a_l y_{n-l} = \\sum_{k=-p_0}^{P-p_0-1} b_k x_{n-k}, \\hspace{25pt} a_0 = 1, \\]where $Q$ is the autoregressive (AR) order and $P$ is the moving average (MA) order. Note that the MA part can also be non-causal. The characteristics of a filter cascade can be computed by the programs <a class="groops-program" href="DigitalFilter2FrequencyResponse.html">DigitalFilter2FrequencyResponse</a> and <a class="groops-program" href="DigitalFilter2ImpulseResponse.html">DigitalFilter2ImpulseResponse</a>. To apply a filter cascade to a time series (or an instrument file ) use <a class="groops-program" href="InstrumentFilter.html">InstrumentFilter</a>. Each filter can be applyed in forward and backward direction by setting <strong class="groops-config-element">backwardDirection</strong>. If the same filter is applied in both directions, the combined filter has zero phase and the squared magnitude response. Setting <strong class="groops-config-element">inFrequencyDomain</strong> to true applies the transfer function of the filter to the DFT of the input and synthesizes the result, i.e.: \\[   y_n = \\mathcal{F}^{-1}\\{H\\cdot\\mathcal{F}\\{x_n\\}\\}. \\]This is equivalent to setting <strong class="groops-config-element">padType</strong> to <strong class="groops-config-element">periodic</strong>.</p><p>To reduce warmup effects, the input time series can be padded by choosing a <strong class="groops-config-element">padType</strong>: <ul>  <li><strong class="groops-config-element">none</strong>: no padding is applied </li><li> <strong class="groops-config-element">zero</strong>: zeros are appended at the beginning and end of the input time series </li><li> <strong class="groops-config-element">constant</strong>: the beginning of the input time series is padded with the first value, the end is padded with the last value </li><li> <strong class="groops-config-element">periodic</strong>: periodic continuation of the input time series (i.,e. the beginning is padded with the last epochs and the end is padded with the first epochs) </li><li> <strong class="groops-config-element">symmetric</strong>: beginning and end are reflected around the first and last epoch respectively </li></ul>   <h2>MovingAverage</h2><p> Moving average (boxcar) filter. For odd lengths, this filter is symmetric and has therefore no phase shift. For even lengths, a phase shift of half a cycle is introduced.</p><p>\\[   y_n = \\sum_{k=-\\lfloor\\frac{P}{2}\\rfloor}^{\\lfloor\\frac{P}{2}\\rfloor} \\frac{1}{P}x_{n-k} \\]</p><p> <h2>Median</h2><p> Moving median filter of length $n$. The filter output at epoch $k$ is the median of the set start at $k-n/2$ to $k+n/2$. The filter length $n$ should be uneven to avoid a phase shift.  <h2>Derivative</h2><p> Symmetric MA filter for numerical differentiation using polynomial approximation. The input time series is approximated by a moving polynomial of degree <strong class="groops-config-element">polynomialDegree</strong>, by solving \\[   \\begin{bmatrix} x(t_k+\\tau_0) \\\\ \\vdots \\\\ x(t_k+\\tau_M) \\end{bmatrix}   =   \\begin{bmatrix}   1      & \\tau_0 & \\tau_0^2 & \\cdots & \\tau_0^M \\\\   \\vdots & \\vdots & \\vdots   &        & \\vdots   \\\\   1      & \\tau_M & \\tau_M^2 & \\cdots & \\tau_M^M \\\\   \\end{bmatrix}%^{-1}   \\begin{bmatrix}   a_0 \\\\ \\vdots \\\\ a_M   \\end{bmatrix}   \\qquad\\text{with}\\quad   \\tau_j =  (j-M/2)\\cdot \\Delta t, \\]for each time step $t_k$ ($\\Delta t$ is the <strong class="groops-config-element">sampling</strong> of the time series). The filter coefficients for the $k$-th derivative are obtained by taking the appropriate row of the inverse coefficient matrix $\\mathbf{W}$: \\[   b_n = \\prod_{i=0}^{k-1} (k-i) \\mathbf{w}_{2,:}. \\]The <strong class="groops-config-element">polynomialDegree</strong> should be even if no phase shift should be introduced.  <h2>Integral</h2><p> Numerical integration using polynomial approximation. The input time series is approximated by a moving polynomial of degree <strong class="groops-config-element">polynomialDegree</strong> by solving \\[   \\begin{bmatrix} x(t_k+\\tau_0) \\\\ \\vdots \\\\ x(t_k+\\tau_M) \\end{bmatrix}   =   \\begin{bmatrix}   1      & \\tau_0 & \\tau_0^2 & \\cdots & \\tau_0^M \\\\   \\vdots & \\vdots & \\vdots   &        & \\vdots   \\\\   1      & \\tau_M & \\tau_M^2 & \\cdots & \\tau_M^M \\\\   \\end{bmatrix}%^{-1}   \\begin{bmatrix}   a_0 \\\\ \\vdots \\\\ a_M   \\end{bmatrix}   \\qquad\\text{with}\\quad   \\tau_j =  (j-M/2)\\cdot \\Delta t, \\]for each time step $t_k$ ($\\Delta t$ is the <strong class="groops-config-element">sampling</strong> of the time series). The numerical integral for each time step $t_k$ is approximated by the center interval of the estimated polynomial.</p><p></p><p><strong class="groops-config-element">polynomialDegree</strong> should be even to avoid a phase shift.  <h2>Correlation</h2><p> Correlation ($\\rho$) of <strong class="groops-config-element">corr</strong> is introduced into the time series: \\[   y_n = \\rho\\cdot y_{n-1} + \\sqrt{1-\\rho^2}x_n. \\] <h2>GraceLowpass</h2><p> Low pass and differentation filter as used for GRACE KBR and ACC data in the Level1A processing.</p><p>  <h2>Butterworth</h2><p> Digital implementation of the Butterworth filter. The design of the filter is done by modifying the analog (continuous time) transfer function, which is then transformed into the digital domain by using the bilinear transform. The filter coefficients are then determined by a least squares adjustment in time domain.</p><p>The <strong class="groops-config-element">filterType</strong> can be <strong class="groops-config-element">lowpass</strong>, <strong class="groops-config-element">highpass</strong>, where one cutoff frequency has to be specified, and <strong class="groops-config-element">bandpass</strong> and <strong class="groops-config-element">bandstop</strong> where to cutoff frequencies have to be specified. Cutoff frequencies must be given as normalized frequency $w_n = f/f_{\\text{nyq}}$. For a cutoff frequency of 30 mHz for a time series sampled with 5 seconds gives a normalized frequency of $0.03/0.1 = 0.3$.  <h2>File</h2><p> Read filter coefficients of \\eqref{digitalFilterType:arma} from a coefficient file. One column might define the index $n$ of the coefficients $a_n$ and $b_n$ in the other columns.  <h2>Wavelet</h2><p> Filter representation of a wavelet.  <h2>Notch</h2><p> Implemented after Christian Siemes\' dissertation, page 106.</p><p>  <h2>Decorrelation</h2><p> Moving average decorrelation filter based on eigendecomposition of a Toeplitz covariance matrix.  <h2>TimeLag</h2><p> Lag operator in digital filter representation.  <h2>ReduceFilterOutput</h2><p> Removes the filtered signal from the input, i.e. the input is passed through a <a class="groops-class" href="digitalFilterType.html">digitalFilter</a> with a frequency response of $1-H(f)$.'},
'doodson': { 'name': 'doodson', 'key': 'doodson', 'description': 'This is a string which describes a tidal frequency either coded as Doodson number or using Darwins name, e.g.  255.555  or  M2 . The following names are defined:    055.565 :  om1    055.575 :  om2       056.554 :  sa   056.555 :  sa     057.555 :  ssa       058.554 :  sta   063.655 :  msm    065.455 :  mm        073.555 :  msf   075.555 :  mf     083.655 :  mstm      085.455 :  mtm   093.555 :  msq    093.555 :  msqm      125.755 :  2q1   127.555 :  sig1   127.555 :  sigma1    135.655 :  q1   137.455 :  ro1    137.455 :  rho1      145.555 :  o1   147.555 :  tau1   155.655 :  m1        157.455 :  chi1   162.556 :  pi1    163.555 :  p1        164.555 :  s1   165.555 :  k1     166.554 :  psi1      167.555 :  fi1   167.555 :  phi1   173.655 :  the1      173.655 :  theta1   175.455 :  j1     183.555 :  so1       185.555 :  oo1   195.455 :  v1     225.855 :  3n2       227.655 :  eps2   235.755 :  2n2    237.555 :  mu2       237.555 :  mi2   245.655 :  n2     247.455 :  nu2       247.455 :  ni2   253.755 :  gam2   254.556 :  alf2      255.555 :  m2   256.554 :  bet2   257.555 :  dlt2      263.655 :  la2   263.655 :  lmb2   263.655 :  lambda2   265.455 :  l2   271.557 :  2t2    272.556 :  t2        273.555 :  s2   274.554 :  r2     275.555 :  k2        283.655 :  ksi2   285.455 :  eta2   355.555 :  m3        381.555 :  t3   382.555 :  s3     383.555 :  r3        435.755 :  n4   445.655 :  mn4    455.555 :  m4        473.555 :  ms4   491.555 :  s4     655.555 :  m6        855.555 :  m8', 'config_table': '', 'display_text': 'This is a string which describes a tidal frequency either coded as Doodson number or using Darwins name, e.g. <code>255.555</code> or <code>M2</code>.</p><p>The following names are defined: <ul>  <li><code>055.565</code>: <code>om1</code>  </li><li> <code>055.575</code>: <code>om2</code>     </li><li> <code>056.554</code>: <code>sa</code> </li><li> <code>056.555</code>: <code>sa</code>   </li><li> <code>057.555</code>: <code>ssa</code>     </li><li> <code>058.554</code>: <code>sta</code> </li><li> <code>063.655</code>: <code>msm</code>  </li><li> <code>065.455</code>: <code>mm</code>      </li><li> <code>073.555</code>: <code>msf</code> </li><li> <code>075.555</code>: <code>mf</code>   </li><li> <code>083.655</code>: <code>mstm</code>    </li><li> <code>085.455</code>: <code>mtm</code> </li><li> <code>093.555</code>: <code>msq</code>  </li><li> <code>093.555</code>: <code>msqm</code>    </li><li> <code>125.755</code>: <code>2q1</code> </li><li> <code>127.555</code>: <code>sig1</code> </li><li> <code>127.555</code>: <code>sigma1</code>  </li><li> <code>135.655</code>: <code>q1</code> </li><li> <code>137.455</code>: <code>ro1</code>  </li><li> <code>137.455</code>: <code>rho1</code>    </li><li> <code>145.555</code>: <code>o1</code> </li><li> <code>147.555</code>: <code>tau1</code> </li><li> <code>155.655</code>: <code>m1</code>      </li><li> <code>157.455</code>: <code>chi1</code> </li><li> <code>162.556</code>: <code>pi1</code>  </li><li> <code>163.555</code>: <code>p1</code>      </li><li> <code>164.555</code>: <code>s1</code> </li><li> <code>165.555</code>: <code>k1</code>   </li><li> <code>166.554</code>: <code>psi1</code>    </li><li> <code>167.555</code>: <code>fi1</code> </li><li> <code>167.555</code>: <code>phi1</code> </li><li> <code>173.655</code>: <code>the1</code>    </li><li> <code>173.655</code>: <code>theta1</code> </li><li> <code>175.455</code>: <code>j1</code>   </li><li> <code>183.555</code>: <code>so1</code>     </li><li> <code>185.555</code>: <code>oo1</code> </li><li> <code>195.455</code>: <code>v1</code>   </li><li> <code>225.855</code>: <code>3n2</code>     </li><li> <code>227.655</code>: <code>eps2</code> </li><li> <code>235.755</code>: <code>2n2</code>  </li><li> <code>237.555</code>: <code>mu2</code>     </li><li> <code>237.555</code>: <code>mi2</code> </li><li> <code>245.655</code>: <code>n2</code>   </li><li> <code>247.455</code>: <code>nu2</code>     </li><li> <code>247.455</code>: <code>ni2</code> </li><li> <code>253.755</code>: <code>gam2</code> </li><li> <code>254.556</code>: <code>alf2</code>    </li><li> <code>255.555</code>: <code>m2</code> </li><li> <code>256.554</code>: <code>bet2</code> </li><li> <code>257.555</code>: <code>dlt2</code>    </li><li> <code>263.655</code>: <code>la2</code> </li><li> <code>263.655</code>: <code>lmb2</code> </li><li> <code>263.655</code>: <code>lambda2</code> </li><li> <code>265.455</code>: <code>l2</code> </li><li> <code>271.557</code>: <code>2t2</code>  </li><li> <code>272.556</code>: <code>t2</code>      </li><li> <code>273.555</code>: <code>s2</code> </li><li> <code>274.554</code>: <code>r2</code>   </li><li> <code>275.555</code>: <code>k2</code>      </li><li> <code>283.655</code>: <code>ksi2</code> </li><li> <code>285.455</code>: <code>eta2</code> </li><li> <code>355.555</code>: <code>m3</code>      </li><li> <code>381.555</code>: <code>t3</code> </li><li> <code>382.555</code>: <code>s3</code>   </li><li> <code>383.555</code>: <code>r3</code>      </li><li> <code>435.755</code>: <code>n4</code> </li><li> <code>445.655</code>: <code>mn4</code>  </li><li> <code>455.555</code>: <code>m4</code>      </li><li> <code>473.555</code>: <code>ms4</code> </li><li> <code>491.555</code>: <code>s4</code>   </li><li> <code>655.555</code>: <code>m6</code>      </li><li> <code>855.555</code>: <code>m8</code> </li></ul>'},
'earthRotationType': { 'name': 'earthRotationType', 'key': 'earthRotationType', 'description': 'This class realize the transformation between a terestrial reference frame (TRF) and a celestial reference frame (CRF).     This class realize the transformation by interpolation from file. This file can be created with  EarthOrientationParameterTimeSeries .     This class realize the transformation according to the IERS2010 conventions given by the  International Earth Rotation and Reference Systems Service  (IERS). A file with the earth orientation parameter is needed (   ).     This class realize the transformation according to the IERS2010 conventions given by the  International Earth Rotation and Reference Systems Service  (IERS). A file with the earth orientation parameter is needed (   ). Includes additional high-frequency EOP models (   ).     This class realize the transformation according to IERS2003 conventions given by the  International Earth Rotation and Reference Systems Service  (IERS). A file with the earth orientation parameter is needed (   ). The following subroutines are used:    BPN2000.f,  ERA2000.f,  pmsdnut.f,  POM2000.f,  SP2000.f,  T2C2000.f,  XYS2000A.f   from  ftp://maia.usno.navy.mil/conv2000/chapter5/  and    orthoeop.f   from  ftp://maia.usno.navy.mil/conv2000/chapter8/      Very old.     The transformation is realized as rotation about the z-axis. The angle ist given by the Greenwich Mean Siderial Time (GMST).     Double Tu0 = (timeUTC.mjdInt()-51544.5)/36525.0;   Double GMST0 = (6.0/24 + 41.0/(24*60) + 50.54841/(24*60*60))                + (8640184.812866/(24*60*60))*Tu0                + (0.093104/(24*60*60))*Tu0*Tu0                + (-6.2e-6/(24*60*60))*Tu0*Tu0*Tu0;   Double r = 1.002737909350795 + 5.9006e-11*Tu0 - 5.9e-15*Tu0*Tu0;   GMST = fmod(2*PI*(GMST0 + r * timeUTC.mjdMod()), 2*PI);       The transformation is realized as rotation about the z-axis. The angle ist given by the Earth Rotation Angle (ERA).     The transformation is realized as rotation about the z-axis. You must specify the angle ( initialAngle ) at  time0  and the angular velocity ( angularVelocity ).     This class reads quaternions from an instrument file and interpolates to the given time stamp.     This class realizes the transformation between the moon-fixed system (Principal Axis System (PA) or Mean Earth System (ME)) and the ICRS according to the JPL ephemeris file.', 'config_table': 'inputfileEOP filename  interpolationDegree uint for polynomial interpolation inputfileEOP filename  truncatedNutation boolean use truncated nutation model (IAU2006B) inputfileEOP filename  inputfileDoodsonEOP filename  inputfileEOP filename  inputfileEOP filename  inputfileNutation filename  initialAngle double Angle at time0 [rad] angularVelocity double [rad/s] time0 time  inputfileStarCamera filename  interpolationDegree uint degree of interpolation polynomial inputfileEphemerides filename librations moonfixedSystem choice  PA  Principal Axis System ME  Mean Earth System', 'display_text': 'This class realize the transformation between a terestrial reference frame (TRF) and a celestial reference frame (CRF).  <h2 id="file">File</h2><p> This class realize the transformation by interpolation from file. This file can be created with <a class="groops-program" href="EarthOrientationParameterTimeSeries.html">EarthOrientationParameterTimeSeries</a>.  <h2>Iers2010</h2><p> This class realize the transformation according to the IERS2010 conventions given by the <em>International Earth Rotation and Reference Systems Service</em> (IERS). A file with the earth orientation parameter is needed (<a class="groops-class" href="fileFormat_earthOrientationParameter.html">inputfileEOP</a>).  <h2 id="iers2010b">Iers2010b</h2><p> This class realize the transformation according to the IERS2010 conventions given by the <em>International Earth Rotation and Reference Systems Service</em> (IERS). A file with the earth orientation parameter is needed (<a class="groops-class" href="fileFormat_earthOrientationParameter.html">inputfileEOP</a>). Includes additional high-frequency EOP models (<a class="groops-class" href="fileFormat_doodsonEarthOrientationParameter.html">inputfileDoodsonEOP</a>).  <h2>Iers2003</h2><p> This class realize the transformation according to IERS2003 conventions given by the <em>International Earth Rotation and Reference Systems Service</em> (IERS). A file with the earth orientation parameter is needed (<a class="groops-class" href="fileFormat_earthOrientationParameter.html">inputfileEOP</a>).</p><p>The following subroutines are used: <ul>  <li>BPN2000.f, </li><li> ERA2000.f, </li><li> pmsdnut.f, </li><li> POM2000.f, </li><li> SP2000.f, </li><li> T2C2000.f, </li><li> XYS2000A.f </li></ul>  from <a href="ftp://maia.usno.navy.mil/conv2000/chapter5/" target="_blank">ftp://maia.usno.navy.mil/conv2000/chapter5/</a> and <ul>  <li>orthoeop.f </li></ul>  from <a href="ftp://maia.usno.navy.mil/conv2000/chapter8/" target="_blank">ftp://maia.usno.navy.mil/conv2000/chapter8/</a>  <h2>Iers1996</h2><p> Very old.  <h2>Gmst</h2><p> The transformation is realized as rotation about the z-axis. The angle ist given by the Greenwich Mean Siderial Time (GMST). <pre>   Double Tu0 = (timeUTC.mjdInt()-51544.5)/36525.0;</p><p>  Double GMST0 = (6.0/24 + 41.0/(24*60) + 50.54841/(24*60*60))                + (8640184.812866/(24*60*60))*Tu0                + (0.093104/(24*60*60))*Tu0*Tu0                + (-6.2e-6/(24*60*60))*Tu0*Tu0*Tu0;   Double r = 1.002737909350795 + 5.9006e-11*Tu0 - 5.9e-15*Tu0*Tu0;   GMST = fmod(2*PI*(GMST0 + r * timeUTC.mjdMod()), 2*PI); </pre>  <h2>Earth Rotation Angle (ERA)</h2><p> The transformation is realized as rotation about the z-axis. The angle ist given by the Earth Rotation Angle (ERA).  <h2>Z-Axis</h2><p> The transformation is realized as rotation about the z-axis. You must specify the angle (<strong class="groops-config-element">initialAngle</strong>) at <strong class="groops-config-element">time0</strong> and the angular velocity (<strong class="groops-config-element">angularVelocity</strong>).  <h2>StarCamera</h2><p> This class reads quaternions from an instrument file and interpolates to the given time stamp.  <h2>MoonRotation</h2><p> This class realizes the transformation between the moon-fixed system (Principal Axis System (PA) or Mean Earth System (ME)) and the ICRS according to the JPL ephemeris file.'},
'eclipseType': { 'name': 'eclipseType', 'key': 'eclipseType', 'description': 'Shadowing of satellites by moon and Earth provided as factor between   with 0: full shadow and 1: full sun light.           Earths penumbra modeling with Solar radiation pressure with Oblateness and Lower Atmospheric Absorption, Refraction, and Scattering (SOLAARS). See Robertson, Robbie. (2015), Highly Physical Solar Radiation Pressure Modeling During Penumbra Transitions (pp. 67-75).', 'config_table': '', 'display_text': 'Shadowing of satellites by moon and Earth provided as factor between $[0,1]$ with 0: full shadow and 1: full sun light.  <h2>Conical</h2><p>   <h2>SOLAARS</h2><p> Earths penumbra modeling with Solar radiation pressure with Oblateness and Lower Atmospheric Absorption, Refraction, and Scattering (SOLAARS). See Robertson, Robbie. (2015), Highly Physical Solar Radiation Pressure Modeling During Penumbra Transitions (pp. 67-75).'},
'ephemeridesType': { 'name': 'ephemeridesType', 'key': 'ephemeridesType', 'description': 'Ephemerides of Sun, Moon and planets. The coordinate system is defined as center of    .     Using  DExxx  ephemerides from NASA Jet Propulsion Laboratory (JPL).', 'config_table': 'inputfileEphemerides filename  origin planetType center of coordinate system', 'display_text': 'Ephemerides of Sun, Moon and planets. The coordinate system is defined as center of <a class="groops-class" href="planetType.html">origin</a>.   Using <code>DExxx</code> ephemerides from NASA Jet Propulsion Laboratory (JPL).'},
'forcesType': { 'name': 'forcesType', 'key': 'forcesType', 'description': 'This class provides the forces acting on a satellite. This encompasses    ,     and    .', 'config_table': 'forcesType sequence  gravityfield gravityfieldType  tides tidesType  miscAccelerations miscAccelerationsType', 'display_text': 'This class provides the forces acting on a satellite. This encompasses <a class="groops-class" href="gravityfieldType.html">gravityfield</a>, <a class="groops-class" href="tidesType.html">tides</a> and <a class="groops-class" href="miscAccelerationsType.html">miscAccelerations</a>.'},
'gnssAntennaDefintionListType': { 'name': 'gnssAntennaDefintionListType', 'key': 'gnssAntennaDefintionListType', 'description': 'Provides a list of GnssAntennaDefinitions as used in  GnssAntennaDefinitionCreate .     Creates a new antenna.     Select all or the first antenna from an  antenna definition file  which matches the wildcards.     Select all antennas from an  antenna definition file  which are used by a station within a defined time interval. With  specializeAntenna  an individual antenna is created for each different serial number using the general type specific values from file.     The azimuth and elevation dependent antenna center variations (patterns) of all  antenna s are resampled to a new resolution.     This class can be used to separate general antenna patterns for different    s. If the  antenna s contain only one pattern for all GPS observations on the L1 frequency ( *1*G** ), the  patternTypes = C1*G**  and  L1*G**  create two patterns with the  *1*G**  patterm as template. The first matching pattern in the  antenna  is used as template. Also new  additionalPattern  can be added (e.g. for  *5*G** ). With  addExistingPatterns  all already existing patterns that don\'t match completely to any of the above are added.     Replaces parts of the descrption of  antenna s. The star " * " left this part untouched.', 'config_table': 'name string  serial string  radome string  comment string  pattern sequence  type gnssType pattern matching of observation types offsetX double [m] antenna center offset offsetY double [m] antenna center offset offsetZ double [m] antenna center offset deltaAzimuth angle [degree] step size deltaZenith angle [degree] step size maxZenith angle [degree] values expression [m] expression (zenith, azimuth: variables) inputfileAntennaDefinition filename  name string  serial string  radome string  onlyFirstMatch boolean otherwise all machting antennas included inputfileStationInfo filename  inputfileAntennaDefinition filename  timeStart time only antennas used in this time interval timeEnd time only antennas used in this time interval specializeAntenna boolean e.g. separate different serial numbers from stationInfo antenna gnssAntennaDefintionListType  deltaAzimuth angle [degree] step size, empty: no change deltaZenith angle [degree] step size, empty: no change maxZenith angle [degree], empty: no change antenna gnssAntennaDefintionListType  patternTypes gnssType gnssType for each pattern (first match is used) additionalPattern sequence additional new patterns type gnssType pattern matching of observation types offsetX double [m] antenna center offset offsetY double [m] antenna center offset offsetZ double [m] antenna center offset deltaAzimuth angle [degree] step size deltaZenith angle [degree] step size maxZenith angle [degree] values expression [m] expression (zenith, azimuth: variables) addExistingPatterns boolean add existing patterns that don\'t match completely any of the above antenna gnssAntennaDefintionListType  name string *: left this part untouched serial string *: left this part untouched radome string *: left this part untouched comment string *: left this part untouched', 'display_text': 'Provides a list of GnssAntennaDefinitions as used in <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>.  <h2>New</h2><p> Creates a new antenna.  <h2>FromFile</h2><p> Select all or the first antenna from an <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">antenna definition file</a> which matches the wildcards.  <h2>FromStationInfo</h2><p> Select all antennas from an <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">antenna definition file</a> which are used by a station within a defined time interval. With <strong class="groops-config-element">specializeAntenna</strong> an individual antenna is created for each different serial number using the general type specific values from file.  <h2>Resample</h2><p> The azimuth and elevation dependent antenna center variations (patterns) of all <strong class="groops-config-element">antenna</strong>s are resampled to a new resolution.  <h2>Transform</h2><p> This class can be used to separate general antenna patterns for different <a class="groops-class" href="gnssType.html">gnssType</a>s. If the <strong class="groops-config-element">antenna</strong>s contain only one pattern for all GPS observations on the L1 frequency (<code>*1*G**</code>), the <strong class="groops-config-element">patternTypes</strong>=<code>C1*G**</code> and <code>L1*G**</code> create two patterns with the <code>*1*G**</code> patterm as template. The first matching pattern in the <strong class="groops-config-element">antenna</strong> is used as template. Also new <strong class="groops-config-element">additionalPattern</strong> can be added (e.g. for <code>*5*G**</code>). With <strong class="groops-config-element">addExistingPatterns</strong> all already existing patterns that don\'t match completely to any of the above are added.  <h2>Rename</h2><p> Replaces parts of the descrption of <strong class="groops-config-element">antenna</strong>s. The star "<code>*</code>" left this part untouched.'},
'gnssParametrizationType': { 'name': 'gnssParametrizationType', 'key': 'gnssParametrizationType', 'description': 'This class defines the models and parameters of the linearized observation equations for all phase and code measurements (see  GnssProcessing )  where the left side is the observation vector minus the effects computed from the a priori models. After each least squares adjustment (see    ) the a priori parameters are updated  The vector   can be written with    . Any  outputfiles  defined in the parametrizations are written with    . Each parametrization (and possible constraint equations) has a  name  which enables activating/deactivating the estimation of subsets of   with    . The a priori model   is unaffected and is always reduced. The model for the different observation types can be described as  The notation   describes the attribution to a signal type   (i.e., C or L), frequency  , signal attribute   (e.g., C, W, Q, X), transmitting satellite  , and observing receiver  . It follows the  , see  GnssType . See also  GnssProcessing .     The influence of the ionosphere is modelled by a STEC parameter (slant total electron content) in terms of   between each transmitter and receiver at each epoch. These parameters are pre-eliminated from the observation equations before accumulating the normal equations. This is similar to using the ionosphere-free linear combination as observations but only one STEC parameter is needed for an arbitrary number of observation types. The influcence to the code and phase observation is modelled as  The second order term depends on the       and the direction of the signal  . If further information about the ionosphere is available (in the form of a prior model or as additional parametrizations such as     or    ) the STEC parameters describe local and shortterm scintillations. The STEC parameters are estimated as additions to the model and it is advised to constrain them towards zero with a standard deviation of  sigmaSTEC .     The influence of the ionosphere is modelled by a VTEC parameter (vertical total electron content) in terms of   for every selected receiver each epoch. The slant TEC is computed using the elevation   dependent Modified Single-Layer Model (MSLM) mapping function  inserted into eq.  . The result is written as a  times series file  at epochs with observations depending on    . This class provides a simplifed model of the ionosphere for single receivers and enables the separation of the TEC and signal biases, meaning     becomes estimable. Local and short-term scintillations should be considered by adding loosely constrained    . The  parameter names  are  &lt;station>:VTEC::&lt;time> .     TODO: reading and writing ionosphere maps not implemented yet.  The ionosphere is parametrized in terms of   as a    ly changing (e.g. hourly linear splines) spherical harmonics expansion  up to  maxDegree = 15  in a solar-geomagentic frame defined by    . The VTEC values are mapped to STEC values via eq.  . Local and short-term scintillations can be considered by adding constrained    . To account for signal biases add    . The  parameter names  are    VTEC:sphericalHarmonics.c_&lt;degree>_&lt;order>:&lt;temporal>:&lt;interval> ,  VTEC:sphericalHarmonics.s_&lt;degree>_&lt;order>:&lt;temporal>:&lt;interval> .       Clock errors are estimated epoch-wise for each    . No clock errors are estimated if no valid observations are available (e.g. data gaps in the observations). These parameters are lineary dependent and would lead to a rank deficiency in the normal equation matrix. To circumvent this issue, the estimation requires an additional zero-mean constraint added in each epoch. This is realized with an additional observation equation  summed over all     with a standard deviation of  sigmaZeroMeanConstraint . The  parameter names  are  &lt;station or prn>:clock::&lt;time> .     This parametrization is an alternative to    . Clock errors are estimated epoch-wise for each     and, opposed to    , are also estimated for epochs that have no valid observations available (e.g. data gaps). The clock error of the an epoch can be predicted by the clock error of the preceding epoch and an unknown clock drift  This equation is applied as an additional constraint equation in each epoch  The variance   is estimated iteratively by variance component estimation (VCE). Clock jumps are treated as outliers and are automatically downweighted as described in    . The absolute initial clock error and clock drift cannot be determined if all receiver and transmitter clocks are estimated together due to their linear dependency. This linear dependency would lead to a rank deficiency in the normal equation matrix in the same manner as described in    . To circumvent the rank deficiency additional zero-mean constraints are required for the first and last epoch. The realization of the constraint is done as an additional observation equation in the form  summed over all     with a standard deviation of  sigmaZeroMeanConstraint . The  parameter names  are  &lt;station or prn>:clock::&lt;time>  and  &lt;station or prn>:clockDrift:: .     Each code and phase observation (e.g  C1C  or  L2W ) contains a bias at transmitter/receiver level  This class provides the apriori model   of eq.   only. The     are read for each receiver and transmitter. The file name is interpreted as a template with the variables  {prn}  and  {station}  being replaced by the name. (Infos regarding the variables  {prn}  and  {station}  can be found in     and     respectively). The files can be converted with  GnssSinexBias2SignalBias . The estimation of the biases is complex due to different linear dependencies, which result in rank deficiencies in the system of normal equations. For simplification the parametrization for   has been split into:    ,    , and     (including phase biases). The file handling on the other hand still remains within this class. Any prior values for the receiver/transmitter biases are read with the respective  inputFileSignalBias . All biases for a receiver/transmitter are accumulated and written to the respective  outputFileSignalBias .     Sets up an ambiguity parameter for each track and phase observation type.  As the phase observations contain a float bias at transmitter/receiver level, not all ambiguities are resolvable to integer values. The number of resolvable ambiguities can be increased with known phase biases read from file via    . In this case,     should not be used for the corresponding transmitters and receivers. In case of GLONASS, the phase biases at receiver level differ between different frequency channels (frequency division multiple access, FDMA) and for each channel an extra float phase bias is estimated. With  linearGlonassBias  a linear relationship between bias and frequency channel is assumed, which reduces the number of float bias parameters and increases the number of resolvable integer ambiguities. The integer ambiguities can be resolved and fixed in    . Resolved integer ambiguities are not estimated as unknown parameters in     anymore and are removed from the system of normal equations. The estimated phase biases can be written to files in    . The  parameter names  are    &lt;station>:phaseBias(&lt;gnssType>):: ,  &lt;prn>:phaseBias(&lt;gnssType>):: ,  &lt;station>.&lt;prn>:ambiguity&lt;index>of&lt;count>(&lt;GnssTypes>)::&lt;track interval> .       Each code observation (e.g  C1C  or  C2W ) contains a bias at transmitter/receiver level  The code biases cannot be estimated together with clock errors and ionospheric delays in an absolute sense as rank deficiencies will occur in the system of normal equations. Therefore, the biases are not initialized and set up as parameters directly but only estimable linear combinations are parametrized. The basic idea is to set up simplified normal equations with the biases, clock and STEC parameters of one single receiver or transmitter, eliminate clock and STEC parameters and perform an eigen value decomposition of the normal equation matrix  Instead of estimating the original bias parameter   a transformed set   is introduced:  The new parameters corresponding to eigen values   are estimable, the others are left out (set to zero). The missing linear combinations, which depend on the STEC parameters, can be added with    . Additional rank deficiencies may also occur when biases of transmitters and receivers are estimated together. The minimum norm nullspace (also via eigen value decomposition) is formulated as zero constraint equations and added with a standard deviation of  sigmaZeroMeanConstraint . In case of GLONASS the code biases at receiver level can differ between different frequency channels (frequency division multiple access, FDMA) and for each channel an extra code bias is estimated. With  linearGlonassBias  a linear relationship between bias and frequency channel is assumed, which reduces the number of bias parameters. The estimated biases can be written to files in    . The  parameter names  are  &lt;station or prn>:codeBias0&lt;index>&lt;combi of gnssTypes>:: .     Each code observation (e.g  C1C  or  C2W ) contains a bias at transmitter/receiver level  This parametrization represents the linear combination of signal biases which completely depend on the STEC parameters. Ignoring these bias combinations would result in a biased STEC estimation (all other parameters are nearly unaffected). To determine this part of the signal biases the     should be constrained. Furthermore, additional information about the ionosphere is required from     or    . Rank deficiencies due to the signal bias parameters may occur if biases of transmitters and receivers are estimated together. The minimum norm nullspace is formulated as zero constraint equations and added with a standard deviation of  sigmaZeroMeanConstraint . The accumulated estimated result can be written to files in    . The  parameter names  are  &lt;station or prn>:tecBias0&lt;index>&lt;combi of gnssTypes>:: .     This parametrization resolves the issue of some phase observations suffering from time-variable biases. Such a phenomenon has been found to affect GPS block IIF satellites on the L5 phase measurements (see Montenbruck et al. 2011, DOI:  ). For these time-variable biases an appropriate temporal representation has to be defined in    . For example, time-variable biases for GPS block IIF L5 phase observations (   = L5*G ) can be represented by a cubic spline with a nodal distance of one hour. The result is written as a  times series file  at the processing sampling or the sampling set by    ). This parametrization should be set up in addition to the constant    . Depending on the temporal representation a temporal zero-mean constraint is needed to separate this parametrization from the constant component. The constraint equations are added with a standard deviation of  sigmaZeroMeanConstraint . The  parameter names  are  &lt;prn>:signalBias.&lt;gnssType>:&lt;temporal>:&lt;interval> .     Estimates a static position for all     in the terrestrial frame. No-net constraints can be applied for a subset of stations,    , with a standard deviation of  noNetTranslationSigma  and  noNetRotationSigma . If the template     is provided the constraints are applied relatively to these positions. Only stations with an existing position file are considered. Without     the constraints are applied towards the apriori values from    . As a single corrupted station position can disturb the no-net conditions, the rotation/translation parameters are estimated in a  robust least squares adjustment  beforehand. The computed weight matrix is used to downweight corrupted stations in the constraint equations. In case you want to align to an ITRF/IGS reference frame, precise coordinates can be generated with  Sinex2StationPositions . The  parameter names  are    &lt;station>:position.x:: ,  &lt;station>:position.y:: ,  &lt;station>:position.z:: .       Estimates the epoch-wise     in an Earth-fixed frame (or in case of LEO satellites in an intertial frame). The   epoch wise     are computed within    The  parameter names  are    &lt;station>:position.x::&lt;time> ,  &lt;station>:position.y::&lt;time> ,  &lt;station>:position.z::&lt;time> .       The estimation of (reduced) dynamic orbits is formulated as variational equations. It is based on     calculated with  PreprocessingVariationalEquation . Necessary integrations are performed by integrating a moving interpolation polynomial of degree  integrationDegree . The     must include at least those parameters that were estimated in  PreprocessingVariationalEquationOrbitFit . Additional     parameters can be set up to reduce orbit mismodeling. If not enough epochs with observations are available ( minEstimableEpochsRatio ) the LEO satellite is disabled. The parameters and  parameter names  are divided into global    &lt;station>:&lt;parametrizationAcceleration>:*:* ,  &lt;station>:stochasticPulse.x::&lt;time> ,  &lt;station>:stochasticPulse.y::&lt;time> ,  &lt;station>:stochasticPulse.z::&lt;time> ,   and arc related parameters    &lt;station>:arc&lt;no>.&lt;parametrizationAcceleration>:*:* ,  &lt;station>:arc&lt;no>.position0.x:: ,  &lt;station>:arc&lt;no>.position0.y:: ,  &lt;station>:arc&lt;no>.position0.z:: .  &lt;station>:arc&lt;no>.velocity0.x:: ,  &lt;station>:arc&lt;no>.velocity0.y:: ,  &lt;station>:arc&lt;no>.velocity0.z:: .       Same as     but for transmitting GNSS satellites. For more details see  orbit integration .     A priori tropospheric correction is handled by a     model (e.g. Vienna Mapping Functions 3). Additional parameters in   for zenith wet delay and gradients can be set up via     (usually 2-hourly linear splines) and     (usually a daily trend). These parameters can be soft-constrained using     to avoid an unsolvable system of normal equations in case of data gaps. The  parameter names  are    &lt;station>:troposphereWet:&lt;temporal>:&lt;interval> ,  &lt;station>:troposphereGradient.x:&lt;temporal>:&lt;interval> ,  &lt;station>:troposphereGradient.y:&lt;temporal>:&lt;interval> .       Earth rotation parameters (ERPs) can be estimated by defining  estimatePole  ( ,  ) and  estimateUT1  ( ). Estimating length of day (LOD) with the sign according to IGS conventions requires a negative value in    . Constraints on the defined parameters can be added via    . An example would be to set up     so the   parameter is included in the normal equation system . Since   cannot be determined by GNSS, a hard constraint to its a priori value can then be added. The  parameter names  are    earth:polarMotion.xp:&lt;temporal>:&lt;interval> ,  earth:polarMotion.yp:&lt;temporal>:&lt;interval> ,  earth:UT1:&lt;temporal>:&lt;interval> ,  earth:nutation.X:&lt;temporal>:&lt;interval> ,  earth:nutation.>:&lt;temporal>:&lt;interval> .       This class is for parametrization the antenna for their antenna center offsets (ACO) and antenna center variations (ACV) by    . The receivers to be estimated can be selected by    . The amount of patterns to be estimated is configurable with a list of    . For each added     a set of parameters will be evaluated. The observations will be assigned to the first     that matches their own. E.g. having the patterns:  ***G  and  L1*  would lead to all GPS observations be assigned to the observation equations of the first pattern. The patterntype  L1*  would then consist of all other GNSS L1 phase observations.  addNonMatchingTypes  will, if activated, create automatically patterns for     that are not selected within the list    . Furthermore, it is possible to group same antenna build types from different receivers by  groupAntennas . The grouping by same antenna build ignores antenna serial numbers. To estimate the antenna variation parameters, a longer period of observations might be necessary for accurate estimations. Hence one should use this parametrization by accumulating normal equations from several epochs. This can be accomplished as the last steps in the      by adding     to current selected parameters with     and write the normal equation matrix with    . The written normal equations can then be accumulated with  NormalsAccumulate  and solved by  NormalsSolverVCE . Further, one should apply constraints to the normal equations by  GnssAntennaNormalsConstraint  since the estimation  of ACO and ACV can lead to rank deficiencies in the normal equation matrix. Last the solved normal equation can be parsed to a  antenna definition file   with the program  ParameterVector2GnssAntennaDefinition . As example referring to the cookbook  GNSS satellite orbit determination and station network analysis , one could add additionally     as parametrization. Since the estimations are done on a daily basis for each receiver we add an additional     which disables  parameter.receiverAntenna . After all stations are processed together with all parameters, one adds  parameter.receiverAntenna  with      to the current selected parametrizations. The last     is     to write the daily normal equations including the parametrization     into files. These normal equation files are then processed with the programs:     NormalsAccumulate : accumulates normal equations.    GnssAntennaNormalsConstraint : apply constraint to the normal equations.    NormalsSolverVCE : solves the normal equations.    ParameterVector2GnssAntennaDefinition : writes the solution into a  antenna definition file   Note that the apriori value   for this parametrization is always zero and never updated according to eq.  . The  parameter names  are  &lt;antennaName>:&lt;antennaCenterVariations>.&lt;gnssType>:: .     Same as     but for transmitting antennas (GNSS satellites). The  parameter names  are  &lt;antennaName>:&lt;antennaCenterVariations>.&lt;gnssType>:: .     Add a pseudo observation equation (constraint) for each selected      where   is the  bias  and   is the a priori value of the parameter if  relativeToApriori  is not set. The standard deviation  sigma  is used to weight the observation equations.     Groups a set of parameters. This class can be used to structure complex parametrizations and has no further effect itself.', 'config_table': 'name string used for parameter selection apply2ndOrderCorrection boolean apply ionospheric correction apply3rdOrderCorrection boolean apply ionospheric correction applyBendingCorrection boolean apply ionospheric correction magnetosphere magnetosphereType  nameConstraint string used for parameter selection sigmaSTEC double (0 = unconstrained) sigma [TECU] for STEC constraint name string  selectReceivers platformSelectorType  outputfileVTEC filename variable {station} available mapR double constant of MSLM mapping function mapH double constant of MSLM mapping function mapAlpha double constant of MSLM mapping function name string  selectReceivers platformSelectorType  maxDegree uint spherical harmonics temporal parametrizationTemporalType temporal evolution of TEC values mapR double [m] constant of MSLM mapping function mapH double [m] constant of MSLM mapping function mapAlpha double constant of MSLM mapping function magnetosphere magnetosphereType  name string used for parameter selection selectTransmitters platformSelectorType  selectReceivers platformSelectorType  outputfileClockTransmitter filename variable {prn} available outputfileClockReceiver filename variable {station} available nameConstraint string used for parameter selection selectTransmittersZeroMean platformSelectorType  selectReceiversZeroMean platformSelectorType  sigmaZeroMeanConstraint double (0 = unconstrained) sigma [m] for zero-mean constraint over all selected clocks name string used for parameter selection selectTransmitters platformSelectorType  selectReceivers platformSelectorType  outputfileClockTransmitter filename variable {prn} available outputfileClockReceiver filename variable {station} available huber double clock jumps > huber*sigma0 are downweighted huberPower double clock jumps > huber: sigma=(e/huber)^huberPower*sigma0 nameConstraint string used for parameter selection selectTransmittersZeroMean platformSelectorType use these transmitters for zero-mean constraint selectReceiversZeroMean platformSelectorType use these receivers for zero-mean constraint sigmaZeroMeanConstraint double (0 = unconstrained) sigma [m] for zero-mean constraint over all selected clocks name string used for parameter selection selectTransmitters platformSelectorType  selectReceivers platformSelectorType  outputfileSignalBiasTransmitter filename variable {prn} available outputfileSignalBiasReceiver filename variable {station} available inputfileSignalBiasTransmitter filename variable {prn} available inputfileSignalBiasReceiver filename variable {station} available name string used for parameter selection estimateTransmitterPhaseBias platformSelectorType  estimateReceiverPhaseBias platformSelectorType  linearGlonassBias boolean bias depends linear on frequency channel number name string used for parameter selection selectTransmitters platformSelectorType  selectReceivers platformSelectorType  linearGlonassBias boolean bias depends linear on frequency channel number nameConstraint string used for parameter selection sigmaZeroMeanConstraint double (0 = unconstrained) sigma [m] for null space constraint name string used for parameter selection selectTransmitters platformSelectorType  selectReceivers platformSelectorType  linearGlonassBias boolean phase or code biases depend linear on frequency channel number nameConstraint string used for parameter selection sigmaZeroMeanConstraint double (0 = unconstrained) sigma [m] for null space constraint name string used for parameter selection selectTransmitters platformSelectorType  outputfileBiasTimeSeries filename variable {prn} available inputfileBiasTimeSeries filename variable {prn} available type gnssType  parametrizationTemporal parametrizationTemporalType  nameConstraint string used for parameter selection sigmaZeroMeanConstraint double (0 = unconstrained) sigma [m] for temporal zero-mean constraint name string used for parameter selection selectReceivers platformSelectorType  outputfileGriddedPosition filename delta north east up for all stations outputfilePosition filename variable {station} available, full estimated coordinates (in TRF) nameConstraint string used for parameter selection selectNoNetReceivers platformSelectorType  inputfileNoNetPositions filename variable {station} available, precise coordinates used for no-net constraints (in TRF) noNetTranslationSigma double (0 = unconstrained) sigma [m] for no-net translation constraint on station coordinates noNetRotationSigma double (0 = unconstrained) sigma [m] at Earth\'s surface for no-net rotation constraint on station coordinates huber double stations > huber*sigma0 are downweighted in no-net constraint huberPower double stations > huber: sigma=(e/huber)^huberPower*sigma0 name string used for parameter selection selectReceivers platformSelectorType  outputfilePositions filename variable {station} available, estimated kinematic positions/orbit outputfileCovarianceEpoch filename variable {station} available, 3x3 epoch covariances name string used for parameter selection selectReceivers platformSelectorType  outputfileOrbit filename variable {station} available outputfileParameters filename variable {station} available inputfileVariational filename variable {station} available stochasticPulse timeSeriesType [mu/s] parametrization of stochastic pulses parametrizationAcceleration parametrizationAccelerationType orbit force parameters ephemerides ephemeridesType  minEstimableEpochsRatio double drop satellites with lower ratio of estimable epochs to total epochs integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint for orbit interpolation and velocity calculation name string used for parameter selection selectTransmitters platformSelectorType  outputfileOrbit filename variable {prn} available outputfileParameters filename variable {prn} available inputfileVariational filename variable {prn} available stochasticPulse timeSeriesType [mu/s] parametrization of stochastic pulses parametrizationAcceleration parametrizationAccelerationType orbit force parameters ephemerides ephemeridesType  minEstimableEpochsRatio double drop satellites with lower ratio of estimable epochs to total epochs integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint for orbit interpolation and velocity calculation name string used for parameter selection selectReceivers platformSelectorType  outputfileTroposphere filename columns: MJD, ZHD, ZWD, dry north gradient, wet north gradient, dry east gradient, wet east gradient, ... troposphere troposphereType a priori troposphere model troposphereWetEstimation parametrizationTemporalType [m] parametrization of zenith wet delays troposphereGradientEstimation parametrizationTemporalType [degree] parametrization of north and east gradients name string used for parameter selection outputfileEOP filename EOP time series (mjd, xp, yp, sp, dUT1, LOD, X, Y, S) estimatePole parametrizationTemporalType xp, yp [mas] estimateUT1 parametrizationTemporalType rotation angle [ms] estimateNutation parametrizationTemporalType dX, dY [mas] name string used for parameter selection selectReceivers platformSelectorType  antennaCenterVariations parametrizationGnssAntennaType estimate antenna center variations patternTypes gnssType gnssType for each pattern (first match is used) addNonMatchingTypes boolean add patterns for additional observed gnssTypes that don\'t match any of the above groupAntennas boolean common ACVs for same antenna build types (ignores antenna serial number) name string used for parameter selection selectTransmitters platformSelectorType  antennaCenterVariations parametrizationGnssAntennaType estimate antenna center variations patternTypes gnssType gnssType for each pattern (first match is used) addNonMatchingTypes boolean add patterns for additional observed gnssTypes that don\'t match any of the above groupAntennas boolean common ACVs for same antenna build types (ignores antenna serial number) name string  parameters parameterSelectorType parameter to constrain sigma double sigma of the constraint (same unit as parameter) bias double constrain all selected parameters towards this value relativeToApriori boolean constrain only dx and not full x=dx+x0 parametrization gnssParametrizationType', 'display_text': 'This class defines the models and parameters of the linearized observation equations for all phase and code measurements (see <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>) \\[\\label{gnssParametrizationType:model}   \\M l - \\M f(\\M x_0) = \\left.\\frac{\\partial \\M f(\\M x)}{\\partial \\M x}\\right|_{\\M x_0} \\Delta\\M x + \\M\\epsilon, \\]where the left side is the observation vector minus the effects computed from the a priori models. After each least squares adjustment (see <a class="groops-class" href="gnssProcessingStepType.html#estimate">GnssProcessing:processingStep:estimate</a>) the a priori parameters are updated \\[\\label{gnssParametrizationType:update}   \\M x_0 := \\M x_0 + \\Delta\\hat{\\M x}. \\]The vector $\\M x_0$ can be written with <a class="groops-class" href="gnssProcessingStepType.html#writeAprioriSolution">GnssProcessing:processingStep:writeAprioriSolution</a>. Any <strong class="groops-config-element">outputfiles</strong> defined in the parametrizations are written with <a class="groops-class" href="gnssProcessingStepType.html#writeResults">GnssProcessing:processingStep:writeResults</a>.</p><p>Each parametrization (and possible constraint equations) has a <strong class="groops-config-element">name</strong> which enables activating/deactivating the estimation of subsets of $\\Delta\\M x$ with <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">GnssProcessing:processingStep:selectParametrizations</a>. The a priori model $\\M f(\\M x_0)$ is unaffected and is always reduced.</p><p>The model for the different observation types can be described as \\[\\label{gnssParametrizationType:gnssFullModel} \\begin{split}   f[\\tau\\nu a]_r^s(\\M x) &= \\text{geometry}(\\M r_r^s) + \\text{clock}^s(t) + \\text{clock}_r(t) \\\\                &+ \\text{iono}([tn],t,\\M r_r^s) + \\text{tropo}(t,\\M r_r^s) \\\\                &+ \\text{ant}[\\tau\\nu a]^s  + \\text{ant}[\\tau\\nu a]_r \\\\                &+ \\text{bias}[\\tau\\nu a]^s + \\text{bias}[\\tau\\nu a]_r                + \\lambda[Ln] N[Lna]_r^s + \\text{other}(\\ldots) + \\epsilon[\\tau\\nu a]_r^s \\end{split} \\]The notation $[\\tau\\nu a]_r^s$ describes the attribution to a signal type $\\tau$ (i.e., C or L), frequency $\\nu$, signal attribute $a$ (e.g., C, W, Q, X), transmitting satellite $s$, and observing receiver $r$. It follows the <a href="https://files.igs.org/pub/data/format/rinex305.pdf">RINEX 3 definition</a>, see <a class="groops-ref" href="gnssType.html">GnssType</a>.</p><p>See also <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>.  <h2 id="ionosphereSTEC">IonosphereSTEC</h2><p> The influence of the ionosphere is modelled by a STEC parameter (slant total electron content) in terms of $[TECU]$ between each transmitter and receiver at each epoch. These parameters are pre-eliminated from the observation equations before accumulating the normal equations. This is similar to using the ionosphere-free linear combination as observations but only one STEC parameter is needed for an arbitrary number of observation types.</p><p>The influcence to the code and phase observation is modelled as \\[\\label{gnssParametrizationType:IonosphereSTEC:STEC} \\begin{split} f_C(STEC) &= \\frac{40.3}{f^2}STEC + \\frac{7525\\M b^T\\M k}{f^3}STEC +  \\frac{r}{f^4}STEC^2 \\\\ f_L(STEC) &= -\\frac{40.3}{f^2}STEC - \\frac{7525\\M b^T\\M k}{2f^3}STEC - \\frac{r}{3f^4}STEC^2 + \\text{bending}(E)STEC^2 \\end{split} \\]The second order term depends on the <a class="groops-class" href="magnetosphereType.html">magnetosphere</a> $\\M b$ and the direction of the signal $\\M k$.</p><p>If further information about the ionosphere is available (in the form of a prior model or as additional parametrizations such as <a class="groops-class" href="gnssParametrizationType.html#ionosphereMap">parametrization:ionosphereMap</a> or <a class="groops-class" href="gnssParametrizationType.html#ionosphereVTEC">parametrization:ionosphereVTEC</a>) the STEC parameters describe local and shortterm scintillations. The STEC parameters are estimated as additions to the model and it is advised to constrain them towards zero with a standard deviation of <strong class="groops-config-element">sigmaSTEC</strong>.  <h2 id="ionosphereVTEC">IonosphereVTEC</h2><p> The influence of the ionosphere is modelled by a VTEC parameter (vertical total electron content) in terms of $[TECU]$ for every selected receiver each epoch. The slant TEC is computed using the elevation $E$ dependent Modified Single-Layer Model (MSLM) mapping function \\[\\label{gnssParametrizationType:IonosphereVTEC:STEC}   STEC = \\frac{VTEC}{\\cos z\'}   \\qquad\\text{with}\\qquad   \\sin z\'= \\left(\\frac{R}{R+H}\\right)\\sin\\left(\\alpha(\\pi/2-E)\\right) \\]inserted into eq. \\eqref{gnssParametrizationType:IonosphereSTEC:STEC}.</p><p>The result is written as a <a class="groops-file" href="fileFormat_instrument.html">times series file</a> at epochs with observations depending on <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">GnssProcessing:processingStep:selectEpochs</a>.</p><p>This class provides a simplifed model of the ionosphere for single receivers and enables the separation of the TEC and signal biases, meaning <a class="groops-class" href="gnssParametrizationType.html#tecBiases">parametrization:tecBiases</a> becomes estimable. Local and short-term scintillations should be considered by adding loosely constrained <a class="groops-class" href="gnssParametrizationType.html#ionosphereSTEC">parametrization:ionosphereSTEC</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;station>:VTEC::&lt;time></code>.  <h2 id="ionosphereMap">IonosphereMap</h2><p> TODO: reading and writing ionosphere maps not implemented yet. </p><p>The ionosphere is parametrized in terms of $[TECU]$ as a <a class="groops-class" href="parametrizationTemporalType.html">temporal</a>ly changing (e.g. hourly linear splines) spherical harmonics expansion \\[   VTEC(\\lambda,\\theta,t) = \\sum_{n=0}^{n_{max}} \\sum_{m=0}^n c_{nm}(t)C_{nm}(\\lambda,\\theta)+s_{nm}(t)S_{nm}(\\lambda,\\theta) \\]up to <strong class="groops-config-element">maxDegree</strong>=<code>15</code> in a solar-geomagentic frame defined by <a class="groops-class" href="magnetosphereType.html">magnetosphere</a>. The VTEC values are mapped to STEC values via eq. \\eqref{gnssParametrizationType:IonosphereVTEC:STEC}.</p><p>Local and short-term scintillations can be considered by adding constrained <a class="groops-class" href="gnssParametrizationType.html#ionosphereSTEC">parametrization:ionosphereSTEC</a>. To account for signal biases add <a class="groops-class" href="gnssParametrizationType.html#tecBiases">parametrization:tecBiases</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>VTEC:sphericalHarmonics.c_&lt;degree>_&lt;order>:&lt;temporal>:&lt;interval></code>, </li><li> <code>VTEC:sphericalHarmonics.s_&lt;degree>_&lt;order>:&lt;temporal>:&lt;interval></code>. </li></ul>   <h2 id="clocks">Clocks</h2><p> Clock errors are estimated epoch-wise for each <a class="groops-class" href="platformSelectorType.html">selectTransmitter/Receiver</a>. No clock errors are estimated if no valid observations are available (e.g. data gaps in the observations).</p><p>These parameters are lineary dependent and would lead to a rank deficiency in the normal equation matrix. To circumvent this issue, the estimation requires an additional zero-mean constraint added in each epoch. This is realized with an additional observation equation \\[   0 = \\frac{1}{n_i + n_k} (\\sum_i \\Delta t^{s_i} + \\sum_k \\Delta t_{r_k}) \\]summed over all <a class="groops-class" href="platformSelectorType.html">selectTransmitters/ReceiversZeroMean</a> with a standard deviation of <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;station or prn>:clock::&lt;time></code>.  <h2 id="clocksModel">ClocksModel</h2><p> This parametrization is an alternative to <a class="groops-class" href="gnssParametrizationType.html#clocks">parametrization:clocks</a>. Clock errors are estimated epoch-wise for each <a class="groops-class" href="platformSelectorType.html">selectTransmitter/Receiver</a> and, opposed to <a class="groops-class" href="gnssParametrizationType.html#clocks">parametrization:clocks</a>, are also estimated for epochs that have no valid observations available (e.g. data gaps).</p><p>The clock error of the an epoch can be predicted by the clock error of the preceding epoch and an unknown clock drift \\[   \\Delta t_{i+1} = \\Delta t_{i} + t_{drift} dt + \\epsilon_i. \\]This equation is applied as an additional constraint equation in each epoch \\[   0 = \\Delta t_{i+1} - \\Delta t_{i} - t_{drift} dt + \\epsilon_i. \\]The variance $\\sigma^2(\\epsilon)$ is estimated iteratively by variance component estimation (VCE). Clock jumps are treated as outliers and are automatically downweighted as described in <a class="groops-class" href="gnssProcessingStepType.html#estimate">GnssProcessing:processingStep:estimate</a>.</p><p>The absolute initial clock error and clock drift cannot be determined if all receiver and transmitter clocks are estimated together due to their linear dependency. This linear dependency would lead to a rank deficiency in the normal equation matrix in the same manner as described in <a class="groops-class" href="gnssParametrizationType.html#clocks">parametrization:clocks</a>. To circumvent the rank deficiency additional zero-mean constraints are required for the first and last epoch. The realization of the constraint is done as an additional observation equation in the form \\[   0 = \\frac{1}{n_i + n_k} (\\sum_i \\Delta t^{s_i} + \\sum_k \\Delta t_{r_k}) \\]summed over all <a class="groops-class" href="platformSelectorType.html">selectTransmitters/ReceiversZeroMean</a> with a standard deviation of <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;station or prn>:clock::&lt;time></code> and <code>&lt;station or prn>:clockDrift::</code>.  <h2 id="signalBiases">SignalBiases</h2><p> Each code and phase observation (e.g <code>C1C</code> or <code>L2W</code>) contains a bias at transmitter/receiver level \\[   [\\tau\\nu a]_r^s(t) = \\dots + \\text{bias}[\\tau\\nu a]^s + \\text{bias}[\\tau\\nu a]_r + \\dots \\]This class provides the apriori model $\\M f(\\M x_0)$ of eq. \\eqref{gnssParametrizationType:model} only.</p><p>The <a class="groops-class" href="fileFormat_gnssSignalBias.html">inputfileSignalBiasTransmitter/Receiver</a> are read for each receiver and transmitter. The file name is interpreted as a template with the variables <code>{prn}</code> and <code>{station}</code> being replaced by the name. (Infos regarding the variables <code>{prn}</code> and <code>{station}</code> can be found in <a class="groops-class" href="gnssTransmitterGeneratorType.html">gnssTransmitterGeneratorType</a> and <a class="groops-class" href="gnssReceiverGeneratorType.html">gnssReceiverGeneratorType</a> respectively). The files can be converted with <a class="groops-program" href="GnssSinexBias2SignalBias.html">GnssSinexBias2SignalBias</a>.</p><p>The estimation of the biases is complex due to different linear dependencies, which result in rank deficiencies in the system of normal equations. For simplification the parametrization for $\\Delta\\M x$ has been split into: <a class="groops-class" href="gnssParametrizationType.html#codeBiases">parametrization:codeBiases</a>, <a class="groops-class" href="gnssParametrizationType.html#tecBiases">parametrization:tecBiases</a>, and <a class="groops-class" href="gnssParametrizationType.html#ambiguities">parametrization:ambiguities</a> (including phase biases). The file handling on the other hand still remains within this class. Any prior values for the receiver/transmitter biases are read with the respective <strong class="groops-config-element">inputFileSignalBias</strong>. All biases for a receiver/transmitter are accumulated and written to the respective <strong class="groops-config-element">outputFileSignalBias</strong>.  <h2 id="ambiguities">Ambiguities</h2><p> Sets up an ambiguity parameter for each track and phase observation type. \\[   [L\\nu a]_r^s(t) = \\dots + \\text{bias}[L\\nu a]^s + \\text{bias}[L\\nu a]_r + \\lambda[L\\nu] N[L\\nu a]_r^s \\]As the phase observations contain a float bias at transmitter/receiver level, not all ambiguities are resolvable to integer values. The number of resolvable ambiguities can be increased with known phase biases read from file via <a class="groops-class" href="gnssParametrizationType.html#signalBiases">parametrization:signalBiases</a>. In this case, <a class="groops-class" href="platformSelectorType.html">estimateTransmitter/ReceiverPhaseBiasTransmitter</a> should not be used for the corresponding transmitters and receivers.</p><p>In case of GLONASS, the phase biases at receiver level differ between different frequency channels (frequency division multiple access, FDMA) and for each channel an extra float phase bias is estimated. With <strong class="groops-config-element">linearGlonassBias</strong> a linear relationship between bias and frequency channel is assumed, which reduces the number of float bias parameters and increases the number of resolvable integer ambiguities.</p><p>The integer ambiguities can be resolved and fixed in <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">GnssProcessing:processingStep:resolveAmbiguities</a>. Resolved integer ambiguities are not estimated as unknown parameters in <a class="groops-class" href="gnssProcessingStepType.html">gnssProcessingStepType:estimate</a> anymore and are removed from the system of normal equations.</p><p>The estimated phase biases can be written to files in <a class="groops-class" href="gnssParametrizationType.html#signalBiases">parametrization:signalBiases</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>&lt;station>:phaseBias(&lt;gnssType>)::</code>, </li><li> <code>&lt;prn>:phaseBias(&lt;gnssType>)::</code>, </li><li> <code>&lt;station>.&lt;prn>:ambiguity&lt;index>of&lt;count>(&lt;GnssTypes>)::&lt;track interval></code>. </li></ul>   <h2 id="codeBiases">CodeBiases</h2><p> Each code observation (e.g <code>C1C</code> or <code>C2W</code>) contains a bias at transmitter/receiver level \\[   [C\\nu a]_r^s(t) = \\dots + \\text{bias}[C\\nu a]^s + \\text{bias}[C\\nu a]_r + \\dots \\]The code biases cannot be estimated together with clock errors and ionospheric delays in an absolute sense as rank deficiencies will occur in the system of normal equations. Therefore, the biases are not initialized and set up as parameters directly but only estimable linear combinations are parametrized.</p><p>The basic idea is to set up simplified normal equations with the biases, clock and STEC parameters of one single receiver or transmitter, eliminate clock and STEC parameters and perform an eigen value decomposition of the normal equation matrix \\[   \\M N = \\M Q \\M\\Lambda \\M Q^T. \\]Instead of estimating the original bias parameter $\\M x$ a transformed set $\\bar{\\M x}$ is introduced: \\[   \\bar{\\M x} = \\M Q^T \\M x. \\]The new parameters corresponding to eigen values $\\lambda>0$ are estimable, the others are left out (set to zero). The missing linear combinations, which depend on the STEC parameters, can be added with <a class="groops-class" href="gnssParametrizationType.html#tecBiases">parametrization:tecBiases</a>.</p><p>Additional rank deficiencies may also occur when biases of transmitters and receivers are estimated together. The minimum norm nullspace (also via eigen value decomposition) is formulated as zero constraint equations and added with a standard deviation of <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>.</p><p>In case of GLONASS the code biases at receiver level can differ between different frequency channels (frequency division multiple access, FDMA) and for each channel an extra code bias is estimated. With <strong class="groops-config-element">linearGlonassBias</strong> a linear relationship between bias and frequency channel is assumed, which reduces the number of bias parameters.</p><p>The estimated biases can be written to files in <a class="groops-class" href="gnssParametrizationType.html#signalBiases">parametrization:signalBiases</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;station or prn>:codeBias0&lt;index>&lt;combi of gnssTypes>::</code>.  <h2 id="tecBiases">TecBiases</h2><p> Each code observation (e.g <code>C1C</code> or <code>C2W</code>) contains a bias at transmitter/receiver level \\[   [C\\nu a]_r^s(t) = \\dots + \\text{bias}[C\\nu a]^s + \\text{bias}[C\\nu a]_r + \\ldots \\]This parametrization represents the linear combination of signal biases which completely depend on the STEC parameters. Ignoring these bias combinations would result in a biased STEC estimation (all other parameters are nearly unaffected). To determine this part of the signal biases the <a class="groops-class" href="gnssParametrizationType.html#ionosphereSTEC">parametrization:ionosphereSTEC</a> should be constrained. Furthermore, additional information about the ionosphere is required from <a class="groops-class" href="gnssParametrizationType.html#ionosphereVTEC">parametrization:ionosphereVTEC</a> or <a class="groops-class" href="gnssParametrizationType.html#ionosphereMap">parametrization:ionosphereMap</a>.</p><p>Rank deficiencies due to the signal bias parameters may occur if biases of transmitters and receivers are estimated together. The minimum norm nullspace is formulated as zero constraint equations and added with a standard deviation of <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>.</p><p>The accumulated estimated result can be written to files in <a class="groops-class" href="gnssParametrizationType.html#signalBiases">parametrization:signalBiases</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;station or prn>:tecBias0&lt;index>&lt;combi of gnssTypes>::</code>.  <h2 id="temporalBias">TemporalBias</h2><p> This parametrization resolves the issue of some phase observations suffering from time-variable biases. Such a phenomenon has been found to affect GPS block IIF satellites on the L5 phase measurements (see Montenbruck et al. 2011, DOI: <a href="https://doi.org/10.1007/s10291-011-0232-x">10.1007/s10291-011-0232-x</a>).</p><p>For these time-variable biases an appropriate temporal representation has to be defined in <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>. For example, time-variable biases for GPS block IIF L5 phase observations (<a class="groops-class" href="gnssType.html">type</a>=<code>L5*G</code>) can be represented by a cubic spline with a nodal distance of one hour.</p><p>The result is written as a <a class="groops-file" href="fileFormat_instrument.html">times series file</a> at the processing sampling or the sampling set by <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">GnssProcessing:processingStep:selectEpochs</a>).</p><p>This parametrization should be set up in addition to the constant <a class="groops-class" href="gnssParametrizationType.html#signalBiases">parametrization:signalBiases</a>. Depending on the temporal representation a temporal zero-mean constraint is needed to separate this parametrization from the constant component. The constraint equations are added with a standard deviation of <strong class="groops-config-element">sigmaZeroMeanConstraint</strong>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;prn>:signalBias.&lt;gnssType>:&lt;temporal>:&lt;interval></code>.  <h2 id="staticPositions">StaticPositions</h2><p> Estimates a static position for all <a class="groops-class" href="platformSelectorType.html">selectReceivers</a> in the terrestrial frame.</p><p>No-net constraints can be applied for a subset of stations, <a class="groops-class" href="platformSelectorType.html">selectNoNetReceivers</a>, with a standard deviation of <strong class="groops-config-element">noNetTranslationSigma</strong> and <strong class="groops-config-element">noNetRotationSigma</strong>. If the template <a class="groops-class" href="fileFormat_stringList.html">inputfileNoNetPositions</a> is provided the constraints are applied relatively to these positions. Only stations with an existing position file are considered. Without <a class="groops-class" href="fileFormat_stringList.html">inputfileNoNetPositions</a> the constraints are applied towards the apriori values from <a class="groops-class" href="gnssReceiverGeneratorType.html">GnssProcessing:receiver</a>. As a single corrupted station position can disturb the no-net conditions, the rotation/translation parameters are estimated in a <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a> beforehand. The computed weight matrix is used to downweight corrupted stations in the constraint equations.</p><p>In case you want to align to an ITRF/IGS reference frame, precise coordinates can be generated with <a class="groops-program" href="Sinex2StationPositions.html">Sinex2StationPositions</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>&lt;station>:position.x::</code>, </li><li> <code>&lt;station>:position.y::</code>, </li><li> <code>&lt;station>:position.z::</code>. </li></ul>   <h2 id="kinematicPositions">KinematicPositions</h2><p> Estimates the epoch-wise <a class="groops-class" href="fileFormat_instrument.html">outputfilePositions</a> in an Earth-fixed frame (or in case of LEO satellites in an intertial frame).</p><p>The $3\\times3$ epoch wise <a class="groops-class" href="fileFormat_instrument.html">outputfileCovarianceEpoch</a> are computed within <a class="groops-class" href="gnssProcessingStepType.html#computeCovarianceMatrix">GnssProcessing:processingStep:computeCovarianceMatrix</a></p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>&lt;station>:position.x::&lt;time></code>, </li><li> <code>&lt;station>:position.y::&lt;time></code>, </li><li> <code>&lt;station>:position.z::&lt;time></code>. </li></ul>   <h2 id="leoDynamicOrbits">LeoDynamicOrbits</h2><p> The estimation of (reduced) dynamic orbits is formulated as variational equations. It is based on <a class="groops-class" href="fileFormat_variationalEquation.html">inputfileVariational</a> calculated with <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a>. Necessary integrations are performed by integrating a moving interpolation polynomial of degree <strong class="groops-config-element">integrationDegree</strong>. The <a class="groops-class" href="parametrizationAccelerationType.html">parametrizationAcceleration</a> must include at least those parameters that were estimated in <a class="groops-program" href="PreprocessingVariationalEquationOrbitFit.html">PreprocessingVariationalEquationOrbitFit</a>. Additional <a class="groops-class" href="timeSeriesType.html">stochasticPulse</a> parameters can be set up to reduce orbit mismodeling. If not enough epochs with observations are available (<strong class="groops-config-element">minEstimableEpochsRatio</strong>) the LEO satellite is disabled.</p><p>The parameters and <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are divided into global <ul>  <li><code>&lt;station>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;station>:stochasticPulse.x::&lt;time></code>, </li><li> <code>&lt;station>:stochasticPulse.y::&lt;time></code>, </li><li> <code>&lt;station>:stochasticPulse.z::&lt;time></code>, </li></ul>  and arc related parameters <ul>  <li><code>&lt;station>:arc&lt;no>.&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;station>:arc&lt;no>.position0.x::</code>, </li><li> <code>&lt;station>:arc&lt;no>.position0.y::</code>, </li><li> <code>&lt;station>:arc&lt;no>.position0.z::</code>. </li><li> <code>&lt;station>:arc&lt;no>.velocity0.x::</code>, </li><li> <code>&lt;station>:arc&lt;no>.velocity0.y::</code>, </li><li> <code>&lt;station>:arc&lt;no>.velocity0.z::</code>. </li></ul>   <h2 id="transmitterDynamicOrbits">TransmitterDynamicOrbits</h2><p> Same as <a class="groops-class" href="gnssParametrizationType.html#leoDynamicOrbits">leoDynamicOrbits</a> but for transmitting GNSS satellites. For more details see <a class="groops-ref" href="cookbook.gnssNetwork.html#orbitIntegration">orbit integration</a>.  <h2 id="troposphere">Troposphere</h2><p> A priori tropospheric correction is handled by a <a class="groops-class" href="troposphereType.html">troposphere</a> model (e.g. Vienna Mapping Functions 3). Additional parameters in $[m]$ for zenith wet delay and gradients can be set up via <a class="groops-class" href="parametrizationTemporalType.html">troposphereWetEstimation</a> (usually 2-hourly linear splines) and <a class="groops-class" href="parametrizationTemporalType.html">troposphereGradientEstimation</a> (usually a daily trend). These parameters can be soft-constrained using <a class="groops-class" href="gnssParametrizationType.html#constraints">parametrization:constraints</a> to avoid an unsolvable system of normal equations in case of data gaps.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>&lt;station>:troposphereWet:&lt;temporal>:&lt;interval></code>, </li><li> <code>&lt;station>:troposphereGradient.x:&lt;temporal>:&lt;interval></code>, </li><li> <code>&lt;station>:troposphereGradient.y:&lt;temporal>:&lt;interval></code>. </li></ul>   <h2 id="earthRotation">EarthRotation</h2><p> Earth rotation parameters (ERPs) can be estimated by defining <strong class="groops-config-element">estimatePole</strong> ($x_p$, $y_p\\, [mas]$) and <strong class="groops-config-element">estimateUT1</strong> ($dUT1\\, [ms], LOD$).</p><p>Estimating length of day (LOD) with the sign according to IGS conventions requires a negative value in <a class="groops-class" href="parametrizationTemporalType.html#trend">parametrizationTemporal:trend:timeStep</a>.</p><p>Constraints on the defined parameters can be added via <a class="groops-class" href="gnssParametrizationType.html#constraints">parametrization:constraints</a>. An example would be to set up <a class="groops-class" href="parametrizationTemporalType.html#constant">estimateUT1:constant</a> so the $dUT1$ parameter is included in the normal equation system . Since $dUT1$ cannot be determined by GNSS, a hard constraint to its a priori value can then be added.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>earth:polarMotion.xp:&lt;temporal>:&lt;interval></code>, </li><li> <code>earth:polarMotion.yp:&lt;temporal>:&lt;interval></code>, </li><li> <code>earth:UT1:&lt;temporal>:&lt;interval></code>, </li><li> <code>earth:nutation.X:&lt;temporal>:&lt;interval></code>, </li><li> <code>earth:nutation.>:&lt;temporal>:&lt;interval></code>. </li></ul>   <h2 id="receiverAntennas">ReceiverAntennas</h2><p> This class is for parametrization the antenna for their antenna center offsets (ACO) and antenna center variations (ACV) by <a class="groops-class" href="parametrizationGnssAntennaType.html">antennaCenterVariations</a>. The receivers to be estimated can be selected by <a class="groops-class" href="platformSelectorType.html">selectReceivers</a>.</p><p>The amount of patterns to be estimated is configurable with a list of <a class="groops-class" href="gnssType.html">patternTypes</a>. For each added <a class="groops-class" href="gnssType.html">patternTypes</a> a set of parameters will be evaluated. The observations will be assigned to the first <a class="groops-class" href="gnssType.html">patternTypes</a> that matches their own. E.g. having the patterns: <code>***G</code> and <code>L1*</code> would lead to all GPS observations be assigned to the observation equations of the first pattern. The patterntype <code>L1*</code> would then consist of all other GNSS L1 phase observations. <strong class="groops-config-element">addNonMatchingTypes</strong> will, if activated, create automatically patterns for <a class="groops-class" href="gnssType.html">observations</a> that are not selected within the list <a class="groops-class" href="gnssType.html">patternTypes</a>. Furthermore, it is possible to group same antenna build types from different receivers by <strong class="groops-config-element">groupAntennas</strong>. The grouping by same antenna build ignores antenna serial numbers.</p><p>To estimate the antenna variation parameters, a longer period of observations might be necessary for accurate estimations. Hence one should use this parametrization by accumulating normal equations from several epochs. This can be accomplished as the last steps in the <a class="groops-class" href="gnssProcessingStepType.html">processing steps</a>  by adding <a class="groops-class" href="gnssParametrizationType.html#receiverAntennas">ReceiverAntennas</a> to current selected parameters with <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">GnssProcessing:processingStep:selectParametrizations</a> and write the normal equation matrix with <a class="groops-class" href="gnssProcessingStepType.html#writeNormalEquations">GnssProcessing:processingStep:writeNormalEquations</a>. The written normal equations can then be accumulated with <a class="groops-program" href="NormalsAccumulate.html">NormalsAccumulate</a> and solved by <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>. Further, one should apply constraints to the normal equations by <a class="groops-program" href="GnssAntennaNormalsConstraint.html">GnssAntennaNormalsConstraint</a> since the estimation  of ACO and ACV can lead to rank deficiencies in the normal equation matrix. Last the solved normal equation can be parsed to a <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">antenna definition file</a>  with the program <a class="groops-program" href="ParameterVector2GnssAntennaDefinition.html">ParameterVector2GnssAntennaDefinition</a>.</p><p>As example referring to the cookbook <a class="groops-ref" href="cookbook.gnssNetwork.html">GNSS satellite orbit determination and station network analysis</a>, one could add additionally <a class="groops-class" href="gnssParametrizationType.html#receiverAntennas">receiverAntennas</a> as parametrization. Since the estimations are done on a daily basis for each receiver we add an additional <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a> which disables <code>parameter.receiverAntenna</code>. After all stations are processed together with all parameters, one adds <code>parameter.receiverAntenna</code> with <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>  to the current selected parametrizations. The last <a class="groops-class" href="gnssProcessingStepType.html">processingStep</a> is <a class="groops-class" href="gnssProcessingStepType.html#writeNormalEquations">GnssProcessing:processingStep:writeNormalEquations</a> to write the daily normal equations including the parametrization <a class="groops-class" href="gnssParametrizationType.html#receiverAntennas">receiverAntennas</a> into files. These normal equation files are then processed with the programs:</p><p><ul>    <li><a class="groops-program" href="NormalsAccumulate.html">NormalsAccumulate</a>: accumulates normal equations.   </li><li> <a class="groops-program" href="GnssAntennaNormalsConstraint.html">GnssAntennaNormalsConstraint</a>: apply constraint to the normal equations.   </li><li> <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>: solves the normal equations.   </li><li> <a class="groops-program" href="ParameterVector2GnssAntennaDefinition.html">ParameterVector2GnssAntennaDefinition</a>: writes the solution into a <a class="groops-file" href="fileFormat_gnssAntennaDefinition.html">antenna definition file</a> </li></ul> </p><p>Note that the apriori value $\\M x_0$ for this parametrization is always zero and never updated according to eq. \\eqref{gnssParametrizationType:update}.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;antennaName>:&lt;antennaCenterVariations>.&lt;gnssType>::</code>.  <h2 id="transmitterAntennas">TransmitterAntennas</h2><p> Same as <a class="groops-class" href="gnssParametrizationType.html#receiverAntennas">receiverAntennas</a> but for transmitting antennas (GNSS satellites).</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>&lt;antennaName>:&lt;antennaCenterVariations>.&lt;gnssType>::</code>.  <h2 id="constraints">Constraints</h2><p> Add a pseudo observation equation (constraint) for each selected <a class="groops-class" href="parameterSelectorType.html">parameters</a> \\[   b-x_0 = 1 \\cdot dx + \\epsilon, \\]where $b$ is the <strong class="groops-config-element">bias</strong> and $x_0$ is the a priori value of the parameter if <strong class="groops-config-element">relativeToApriori</strong> is not set. The standard deviation <strong class="groops-config-element">sigma</strong> is used to weight the observation equations.  <h2 id="group">Group</h2><p> Groups a set of parameters. This class can be used to structure complex parametrizations and has no further effect itself.'},
'gnssProcessingStepType': { 'name': 'gnssProcessingStepType', 'key': 'gnssProcessingStepType', 'description': 'Processing step in  GnssProcessing . Processing steps enable a dynamic definition of the consecutive steps performed during any kind of GNSS processing. The most common steps are    , which performs an iterative least squares adjustment, and    , which writes all output files defined in  GnssProcessing  and is usually the last step. Some steps such as    ,    ,    , and     affect all subsequent steps. In case these steps are used within a     or     step, they only affect the steps within this level. For usage examples see cookbooks on  GNSS satellite orbit determination and network analysis  or  Kinematic orbit determination of LEO satellites .     Iterative non-linear least squares adjustment. In every iteration it accumulates the system of normal equations, solves the system and updates the estimated parameters. The estimated parameters serve as a priori values in the next iteration and the following processing steps. Iterates until either every single parameter update (converted to an influence in meter) is below a  convergenceThreshold  or  maxIterationCount  is reached. With  computeResiduals  the observation equations are computed again after each update to compute the observation residuals. The overall standard deviation of a single observation used for the weighting is composed of several factors  where   is the signal type, the azmiuth and elevation dependent   is given by     and the other factors are estimated iteratively from the residuals. With  computeWeights  a standardized variance   for each residual   is computed  taking the redundancy   into account. If   is above a threshold  huber  the observation gets a higher standard deviation used for weighting according to  similar to  robust least squares adjustment . With  adjustSigma0  individual variance factors can be computed for each station and all phases of a system and each code observation  type  (e.g. for each  L**G ,  L**E ,  C1CG ,  C2WG ,  C1CE ,  ) separately      Performs a least squares adjustment like     but with additional integer phase ambiguity resolution. After this step all resolved ambiguities are removed from the normal equation system. Integer ambiguity resolution is performed based on the least squares ambiguity decorrelation adjustment (LAMBDA) method (Teunissen 1995, DOI  ), specifically the modified algorithm (MLAMBDA) by Chang et al. (2005, DOI  ). First the covariance matrix of the integer ambiguity parameters is computed by eliminating all but those parameters from the full normal equation matrix and inverting it. Then, a Z-transformation is performed as described by Chang et al. (2005) to decorrelate the ambiguity parameters without losing their integer nature. The search process follows MLAMBDA and uses integer minimization of the weighted sum of squared residuals. It is computationally infeasible to search a hyper-ellipsoid with a dimension of ten thousand or more. Instead, a blocked search algorithm is performed by moving a window with a length of, for example,  searchBlockSize = 200  parameters over the decorrelated ambiguities, starting from the most accurate. In each step, the window is moved by half of its length and the overlapping parts are compared to each other. If all fixed ambiguities in the overlap agree, the algorithm continues. Otherwise, both windows are combined and the search is repeated using the combined window, again comparing with the overlapping part of the preceding window. If not all solutions could be checked for a block after  maxSearchSteps , the selected  incompleteAction  is performed. If the algorithm reaches ambiguities with a standard deviation higher than  sigmaMaxResolve , ambiguity resolution stops and the remaining ambiguities are left as float values. Otherwise, all ambiguity parameters are fixed to integer values. In contrast to an integer least squares solution over the full ambiguity vector, it is not guaranteed that the resulting solution is optimal in the sense of minimal variance with given covariance. This trade-off is necessary to cope with large numbers of ambiguities.     Accumulates the normal equations and computes the covariance matrix as inverse of the normal matrix. It is not the full inverse but only the elements which are set in the normal matrix (see     ) are computed. The matrix is passed to the    . Only used in     to get the epoch wise covariance information at the moment.     In this step all  outputfiles  defined in     are written. It considers the settings of    ,    , and    . It is usually the last processing step, but can also be used at other points in the processing in combination with  suffix  to write intermediate results, for example before     to output the float solution.     Accumulates the normal equations matrix and writes it. If     is set only the selected parameters are written to the normal equations and all other parameters are eliminated beforehand (implicitly solved). The solution of the normals would results in   (see    ). To write the appropriate apriori vector   use    .     Writes the current apriori vector   (see    ). If     is set only the selected parameters are written.     Writes the  observation residuals  for all    . For for each station a file is written. The file name is interpreted as a template with the variable  {station}  being replaced by the station name.     Writes a  list  of receivers (stations) which are used in the last step and selected by    .     Writes a  list  of transmitters which are used in the last step and selected by    .     Print residual statistics.     areq: C1CG**: factor =  0.64, sigma0 = 1.00, count =  2748, outliers =    48 (1.75  )   areq: C1WG**: factor =  0.50, sigma0 = 1.00, count =  2748, outliers =    43 (1.56  )   areq: C2WG**: factor =  0.50, sigma0 = 1.00, count =  2748, outliers =    59 (2.15  )   areq: C5XG**: factor =  0.46, sigma0 = 1.00, count =  1279, outliers =    23 (1.80  )   areq: L1CG**: factor =  0.86, sigma0 = 0.96, count =  2748, outliers =    40 (1.46  )   areq: L1WG**: factor =  0.86, sigma0 = 1.02, count =  2748, outliers =    40 (1.46  )   areq: L2WG**: factor =  0.86, sigma0 = 0.96, count =  2748, outliers =    40 (1.46  )   areq: L5XG**: factor =  0.86, sigma0 = 1.30, count =  1279, outliers =    14 (1.09  )   areq: C1PR**: factor =  0.48, sigma0 = 1.00, count =  1713, outliers =    53 (3.09  )   areq: C2PR**: factor =  0.55, sigma0 = 1.00, count =  1713, outliers =    51 (2.98  )   areq: L1PR**: factor =  0.85, sigma0 = 1.09, count =  1713, outliers =    29 (1.69  )   areq: L2PR**: factor =  0.85, sigma0 = 0.88, count =  1713, outliers =    29 (1.69  )   areq: C1XE**: factor =  0.44, sigma0 = 1.00, count =  1264, outliers =    21 (1.66  )   areq: C5XE**: factor =  0.33, sigma0 = 1.00, count =  1264, outliers =    27 (2.14  )   areq: C7XE**: factor =  0.28, sigma0 = 1.00, count =  1264, outliers =    41 (3.24  )   areq: L1XE**: factor =  0.82, sigma0 = 1.14, count =  1264, outliers =    15 (1.19  )   areq: L5XE**: factor =  0.82, sigma0 = 0.84, count =  1264, outliers =    15 (1.19  )   areq: L7XE**: factor =  0.82, sigma0 = 0.94, count =  1264, outliers =    15 (1.19  )   badg: C1CG**: factor =  1.25, sigma0 = 1.00, count =  2564, outliers =    47 (1.83  )   ...       Enable/disable parameter groups and constraint groups for subsequent steps, e.g.     or    . The  name  and  nameConstraint  of these groups are defined in    . Prior models or previously estimated parameters used as new apriori   values are unaffected and they are always reduced from the observations. This means all unselected parameters are kept fixed to their last result. An example would be to process at a 5-minute sampling using     and then at the end to densify the clock parameters to the full 30-second observation sampling while keeping all other parameters fixed ( disable = * ,  enable = *.clock* ,  enable = parameter.STEC ).     Select epochs for subsequent steps. This step can be used to reduce the processing sampling while keeping the original observation sampling for all preprocessing steps (e.g. outlier and cycle slip detection). Another example is to process at a 5-minute sampling by setting  nthEpoch = 10  and then at the end to densify only the clock parameters to the full 30-second observation sampling by setting  nthEpoch = 1  while keeping all other parameters fixed with    .     Select block structure of sparse normal equations for subsequent steps. This step can be used to define the structure of the different parts of the normal equation system, which can have a major impact on computing performance and memory consumption depending on the processing setup. The normal equation system is divided into three parts for epoch, interval, and ambiguity parameters. The epoch part is subdivided further into one subpart per epoch. Each part is divided into blocks and only non-zero blocks are stored in memory to reduce memory consumption and to prevent unnecessary matrix computations.  defaultBlockSizeEpoch ,  defaultBlockSizeInterval , and  defaultBlockSizeAmbiguity  control the size of the blocks within each part of the normal equations.  defaultBlockReceiverCount  can be set to group a number of receivers into one block within the epoch and interval parts. If  keepEpochNormalsInMemory = no  epoch blocks are eliminated after they are set up to reduce the number of parameters in the normal equation system.  defaultBlockCountReduction  controls after how many epoch blocks an elimination step is performed. For larger processing setups or high sampling rates epoch block elimination is recommended as the large number of clock parameters require a lot of memory.     This step can be used to process only a subset of stations in subsequent processing steps. The most common use is to start the processing with a well-distributed network of core stations as seen in  GNSS satellite orbit determination and network analysis . To later process all other stations individually, use the processing step     and select all stations excluding the core stations in that step.     Perform these processing steps for each     separately. All non-receiver related parameters parameters are disabled in these processing steps (see . This step can be used for individual precise point positioning (PPP) of all stations. During  GNSS satellite orbit determination and network analysis  this step is used after the initial processing of the core network to process all other stations individually. In that case provide the same station list as     in this step that was used as     in the     step where the core network was selected.     Perform these processing steps. This step can be used to structure complex processing flows. The     processing steps defined within a group only affect the steps within this group.     Disable transmitter epochs during eclipse. With proper attitude modeling (see  SimulateStarCameraGnss ) this is usually not necessary.', 'config_table': 'computeResiduals boolean  adjustSigma0 boolean adjust sigma0 by scale factor (per receiver and type) computeWeights boolean downweight outliers huber double residuals > huber*sigma0 are downweighted huberPower double residuals > huber: sigma=(e/huber)^huberPower*sigma0 convergenceThreshold double [m] stop iteration once full convergence is reached maxIterationCount uint maximum number of iterations outputfileAmbiguities filename resolved ambiguities sigmaMaxResolve double max. allowed std. dev. of ambiguity to resolve [cycles] searchBlockSize uint block size for blocked integer search maxSearchSteps uint max. steps of integer search for each block incompleteAction choice if not all solutions tested after maxSearchSteps stop  stop searching, ambiguities remain float in this block resolve  use best integer solution found so far shrinkBlockSize  try again with half block size throwException  stop and throw an exception computeResiduals boolean  adjustSigma0 boolean adjust sigma0 by scale factor (per receiver and type) computeWeights boolean downweight outliers huber double residuals > huber*sigma0 are downweighted huberPower double residuals > huber: sigma=(e/huber)^huberPower*sigma0 suffix string appended to every output file name (e.g. orbit.G01.suffix.dat) outputfileNormalEquations filename normals remainingParameters parameterSelectorType parameter order/selection of output normal equations constraintsOnly boolean write only normals of constraints without observations defaultNormalsBlockSize uint block size for distributing the normal equations, 0: one block, empty: original block size outputfileAprioriSolution filename a priori parameters outputfileParameterNames filename parameter names remainingParameters parameterSelectorType parameter order/selection of output normal equations selectReceivers platformSelectorType subset of used stations outputfileResiduals filename variable {station} available selectReceivers platformSelectorType subset of used stations outputfileUsedStationList filename ascii file with names of used stations selectTransmitters platformSelectorType subset of used transmitters outputfileUsedTransmitterList filename ascii file with PRNs parametrization choice  enable sequence  name string wildcards: * and ? disable sequence  name string wildcards: * and ? nthEpoch uint use only every nth epoch in all subsequent processing steps defaultBlockSizeEpoch uint block size of epoch parameters, 0: one block defaultBlockSizeInterval uint block size of interval parameters, 0: one block defaultBlockSizeAmbiguity uint block size of ambiguity parameters, 0: one block defaultBlockReceiverCount uint number of receivers to group into one block for epoch and interval defaultBlockCountReduction uint minimum number of blocks for epoch reduction keepEpochNormalsInMemory boolean speeds up processing but uses much more memory accumulateEpochObservations boolean set up all observations per epoch and receiver at once selectReceivers platformSelectorType  selectReceivers platformSelectorType  variableReceiver string variable is set for each receiver processingStep gnssProcessingStepType steps are processed consecutively processingStep gnssProcessingStepType steps are processed consecutively selectTransmitters platformSelectorType  disableShadowEpochs boolean disable epochs if satellite is in Earth\'s/Moon\'s shadow disablePostShadowRecoveryEpochs boolean disable epochs if satellite is in post-shadow recovery maneuver for GPS block IIA ephemerides ephemeridesType  eclipse eclipseType eclipse model used to determine if a satellite is in Earth\'s shadow', 'display_text': 'Processing step in <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>.</p><p>Processing steps enable a dynamic definition of the consecutive steps performed during any kind of GNSS processing. The most common steps are <a class="groops-class" href="gnssProcessingStepType.html#estimate">estimate</a>, which performs an iterative least squares adjustment, and <a class="groops-class" href="gnssProcessingStepType.html#writeResults">writeResults</a>, which writes all output files defined in <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a> and is usually the last step. Some steps such as <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">selectParametrizations</a>, <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">selectEpochs</a>, <a class="groops-class" href="gnssProcessingStepType.html#selectNormalsBlockStructure">selectNormalsBlockStructure</a>, and <a class="groops-class" href="gnssProcessingStepType.html#selectReceivers">selectReceivers</a> affect all subsequent steps. In case these steps are used within a <a class="groops-class" href="gnssProcessingStepType.html#group">group</a> or <a class="groops-class" href="gnssProcessingStepType.html#forEachReceiverSeparately">forEachReceiverSeparately</a> step, they only affect the steps within this level.</p><p>For usage examples see cookbooks on <a class="groops-ref" href="cookbook.gnssNetwork.html#processing">GNSS satellite orbit determination and network analysis</a> or <a class="groops-ref" href="cookbook.kinematicOrbit.html">Kinematic orbit determination of LEO satellites</a>.  <h2 id="estimate">Estimate</h2><p> Iterative non-linear least squares adjustment. In every iteration it accumulates the system of normal equations, solves the system and updates the estimated parameters. The estimated parameters serve as a priori values in the next iteration and the following processing steps. Iterates until either every single parameter update (converted to an influence in meter) is below a <strong class="groops-config-element">convergenceThreshold</strong> or <strong class="groops-config-element">maxIterationCount</strong> is reached.</p><p>With <strong class="groops-config-element">computeResiduals</strong> the observation equations are computed again after each update to compute the observation residuals.</p><p>The overall standard deviation of a single observation used for the weighting is composed of several factors \\[   \\hat{\\sigma}_i = \\hat{\\sigma}_i^{huber} \\hat{\\sigma}_{[\\tau\\nu a]}^{recv} \\sigma_{[\\tau\\nu a]}^{recv}(E,A), \\]where $[\\tau\\nu a]$ is the signal type, the azmiuth and elevation dependent $\\sigma_{[\\tau\\nu a]}^{recv}(E,A)$ is given by <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">receiver:inputfileAccuracyDefinition</a> and the other factors are estimated iteratively from the residuals.</p><p>With <strong class="groops-config-element">computeWeights</strong> a standardized variance $\\hat{s}_i^2$ for each residual $\\hat{\\epsilon}_i$ is computed \\[   \\hat{s}_i^2 = \\frac{1}{\\hat{\\sigma}_{[\\tau\\nu a]}^{recv} \\sigma_{[\\tau\\nu a]}^{recv}(E,A)}\\frac{\\hat{\\epsilon}_i^2}{r_i}   \\qquad\\text{with}\\qquad   r_i = \\left(\\M A\\left(\\M A^T\\M A\\right)^{-1}\\M A^T\\right)_{ii} \\]taking the redundancy $r_i$ into account. If $\\hat{s}_i$ is above a threshold <strong class="groops-config-element">huber</strong> the observation gets a higher standard deviation used for weighting according to \\[   \\hat{\\sigma}_i^{huber} =   \\left\\{ \\begin{array}{ll}     1                              & s < huber,\\\\     (\\hat{s}_i/huber)^{huberPower} & s \\ge huber   \\end{array} \\right., \\]similar to <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a>.</p><p>With <strong class="groops-config-element">adjustSigma0</strong> individual variance factors can be computed for each station and all phases of a system and each code observation <a class="groops-ref" href="gnssType.html">type</a> (e.g. for each <code>L**G</code>, <code>L**E</code>, <code>C1CG</code>, <code>C2WG</code>, <code>C1CE</code>, ) separately \\[   \\hat{\\sigma}_{[\\tau\\nu a]}^{recv} = \\sqrt{\\frac{\\hat{\\M\\epsilon}^T\\M P\\hat{\\M\\epsilon}}{r}}. \\] <h2 id="resolveAmbiguities">ResolveAmbiguities</h2><p> Performs a least squares adjustment like <a class="groops-class" href="gnssProcessingStepType.html#estimate">processingStep:estimate</a> but with additional integer phase ambiguity resolution. After this step all resolved ambiguities are removed from the normal equation system.</p><p>Integer ambiguity resolution is performed based on the least squares ambiguity decorrelation adjustment (LAMBDA) method (Teunissen 1995, DOI <a href="https://doi.org/10.1007/BF00863419">10.1007/BF00863419</a>), specifically the modified algorithm (MLAMBDA) by Chang et al. (2005, DOI <a href="https://doi.org/10.1007/s00190-005-0004-x">10.1007/s00190-005-0004-x</a>). First the covariance matrix of the integer ambiguity parameters is computed by eliminating all but those parameters from the full normal equation matrix and inverting it. Then, a Z-transformation is performed as described by Chang et al. (2005) to decorrelate the ambiguity parameters without losing their integer nature.</p><p>The search process follows MLAMBDA and uses integer minimization of the weighted sum of squared residuals. It is computationally infeasible to search a hyper-ellipsoid with a dimension of ten thousand or more. Instead, a blocked search algorithm is performed by moving a window with a length of, for example, <strong class="groops-config-element">searchBlockSize</strong>=<code>200</code> parameters over the decorrelated ambiguities, starting from the most accurate. In each step, the window is moved by half of its length and the overlapping parts are compared to each other. If all fixed ambiguities in the overlap agree, the algorithm continues. Otherwise, both windows are combined and the search is repeated using the combined window, again comparing with the overlapping part of the preceding window. If not all solutions could be checked for a block after <strong class="groops-config-element">maxSearchSteps</strong>, the selected <strong class="groops-config-element">incompleteAction</strong> is performed. If the algorithm reaches ambiguities with a standard deviation higher than <strong class="groops-config-element">sigmaMaxResolve</strong>, ambiguity resolution stops and the remaining ambiguities are left as float values. Otherwise, all ambiguity parameters are fixed to integer values.</p><p>In contrast to an integer least squares solution over the full ambiguity vector, it is not guaranteed that the resulting solution is optimal in the sense of minimal variance with given covariance. This trade-off is necessary to cope with large numbers of ambiguities.  <h2 id="computeCovarianceMatrix">ComputeCovarianceMatrix</h2><p> Accumulates the normal equations and computes the covariance matrix as inverse of the normal matrix. It is not the full inverse but only the elements which are set in the normal matrix (see  <a class="groops-class" href="gnssProcessingStepType.html#selectNormalsBlockStructure">gnssProcessingStep:selectNormalsBlockStructure</a>) are computed. The matrix is passed to the <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a>. Only used in <a class="groops-class" href="gnssParametrizationType.html#kinematicPositions">parametrizations:kinematicPositions</a> to get the epoch wise covariance information at the moment.  <h2 id="writeResults">WriteResults</h2><p> In this step all <strong class="groops-config-element">outputfiles</strong> defined in <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a> are written. It considers the settings of <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">processingStep:selectParametrizations</a>, <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">processingStep:selectEpochs</a>, and <a class="groops-class" href="gnssProcessingStepType.html#selectReceivers">processingStep:selectReceivers</a>.</p><p>It is usually the last processing step, but can also be used at other points in the processing in combination with <strong class="groops-config-element">suffix</strong> to write intermediate results, for example before <a class="groops-class" href="gnssProcessingStepType.html#resolveAmbiguities">gnssProcessingStep:resolveAmbiguities</a> to output the float solution.  <h2 id="writeNormalEquations">WriteNormalEquations</h2><p> Accumulates the normal equations matrix and writes it. If <a class="groops-class" href="parameterSelectorType.html">remainingParameters</a> is set only the selected parameters are written to the normal equations and all other parameters are eliminated beforehand (implicitly solved).</p><p>The solution of the normals would results in $\\Delta\\M x$ (see <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a>). To write the appropriate apriori vector $\\M x_0$ use <a class="groops-class" href="gnssProcessingStepType.html#writeAprioriSolution">processingStep:writeAprioriSolution</a>.  <h2 id="writeAprioriSolution">WriteAprioriSolution</h2><p> Writes the current apriori vector $\\M x_0$ (see <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a>). If <a class="groops-class" href="parameterSelectorType.html">remainingParameters</a> is set only the selected parameters are written.  <h2 id="writeResiduals">WriteResiduals</h2><p> Writes the <a class="groops-file" href="fileFormat_instrument.html">observation residuals</a> for all <a class="groops-class" href="platformSelectorType.html">selectReceivers</a>. For for each station a file is written. The file name is interpreted as a template with the variable <code>{station}</code> being replaced by the station name.  <h2 id="writeUsedStationList">WriteUsedStationList</h2><p> Writes a <a class="groops-file" href="fileFormat_stringList.html">list</a> of receivers (stations) which are used in the last step and selected by <a class="groops-class" href="platformSelectorType.html">selectReceivers</a>.  <h2 id="writeUsedTransmitterList">WriteUsedTransmitterList</h2><p> Writes a <a class="groops-file" href="fileFormat_stringList.html">list</a> of transmitters which are used in the last step and selected by <a class="groops-class" href="platformSelectorType.html">selectTransmitters</a>.  <h2 id="printResidualStatistics">PrintResidualStatistics</h2><p> Print residual statistics. <pre>   areq: C1CG**: factor =  0.64, sigma0 = 1.00, count =  2748, outliers =    48 (1.75 %)   areq: C1WG**: factor =  0.50, sigma0 = 1.00, count =  2748, outliers =    43 (1.56 %)   areq: C2WG**: factor =  0.50, sigma0 = 1.00, count =  2748, outliers =    59 (2.15 %)   areq: C5XG**: factor =  0.46, sigma0 = 1.00, count =  1279, outliers =    23 (1.80 %)   areq: L1CG**: factor =  0.86, sigma0 = 0.96, count =  2748, outliers =    40 (1.46 %)   areq: L1WG**: factor =  0.86, sigma0 = 1.02, count =  2748, outliers =    40 (1.46 %)   areq: L2WG**: factor =  0.86, sigma0 = 0.96, count =  2748, outliers =    40 (1.46 %)   areq: L5XG**: factor =  0.86, sigma0 = 1.30, count =  1279, outliers =    14 (1.09 %)   areq: C1PR**: factor =  0.48, sigma0 = 1.00, count =  1713, outliers =    53 (3.09 %)   areq: C2PR**: factor =  0.55, sigma0 = 1.00, count =  1713, outliers =    51 (2.98 %)   areq: L1PR**: factor =  0.85, sigma0 = 1.09, count =  1713, outliers =    29 (1.69 %)   areq: L2PR**: factor =  0.85, sigma0 = 0.88, count =  1713, outliers =    29 (1.69 %)   areq: C1XE**: factor =  0.44, sigma0 = 1.00, count =  1264, outliers =    21 (1.66 %)   areq: C5XE**: factor =  0.33, sigma0 = 1.00, count =  1264, outliers =    27 (2.14 %)   areq: C7XE**: factor =  0.28, sigma0 = 1.00, count =  1264, outliers =    41 (3.24 %)   areq: L1XE**: factor =  0.82, sigma0 = 1.14, count =  1264, outliers =    15 (1.19 %)   areq: L5XE**: factor =  0.82, sigma0 = 0.84, count =  1264, outliers =    15 (1.19 %)   areq: L7XE**: factor =  0.82, sigma0 = 0.94, count =  1264, outliers =    15 (1.19 %)   badg: C1CG**: factor =  1.25, sigma0 = 1.00, count =  2564, outliers =    47 (1.83 %)   ... </pre>  <h2 id="selectParametrizations">SelectParametrizations</h2><p> Enable/disable parameter groups and constraint groups for subsequent steps, e.g. <a class="groops-class" href="gnssProcessingStepType.html#estimate">processingStep:estimate</a> or <a class="groops-class" href="gnssProcessingStepType.html#writeResults">processingStep:writeResults</a>. The <strong class="groops-config-element">name</strong> and <strong class="groops-config-element">nameConstraint</strong> of these groups are defined in <a class="groops-class" href="gnssParametrizationType.html">parametrizations</a>. Prior models or previously estimated parameters used as new apriori $\\M x_0$ values are unaffected and they are always reduced from the observations. This means all unselected parameters are kept fixed to their last result.</p><p>An example would be to process at a 5-minute sampling using <a class="groops-class" href="gnssProcessingStepType.html#selectEpochs">processingStep:selectEpochs</a> and then at the end to densify the clock parameters to the full 30-second observation sampling while keeping all other parameters fixed (<strong class="groops-config-element">disable</strong>=<code>*</code>, <strong class="groops-config-element">enable</strong>=<code>*.clock*</code>, <strong class="groops-config-element">enable</strong>=<code>parameter.STEC</code>).  <h2 id="selectEpochs">SelectEpochs</h2><p> Select epochs for subsequent steps. This step can be used to reduce the processing sampling while keeping the original observation sampling for all preprocessing steps (e.g. outlier and cycle slip detection). Another example is to process at a 5-minute sampling by setting <strong class="groops-config-element">nthEpoch</strong>=<code>10</code> and then at the end to densify only the clock parameters to the full 30-second observation sampling by setting <strong class="groops-config-element">nthEpoch</strong>=<code>1</code> while keeping all other parameters fixed with <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">processingStep:selectParametrizations</a>.  <h2 id="selectNormalsBlockStructure">SelectNormalsBlockStructure</h2><p> Select block structure of sparse normal equations for subsequent steps.</p><p>This step can be used to define the structure of the different parts of the normal equation system, which can have a major impact on computing performance and memory consumption depending on the processing setup.</p><p></p><p>The normal equation system is divided into three parts for epoch, interval, and ambiguity parameters. The epoch part is subdivided further into one subpart per epoch. Each part is divided into blocks and only non-zero blocks are stored in memory to reduce memory consumption and to prevent unnecessary matrix computations. <strong class="groops-config-element">defaultBlockSizeEpoch</strong>, <strong class="groops-config-element">defaultBlockSizeInterval</strong>, and <strong class="groops-config-element">defaultBlockSizeAmbiguity</strong> control the size of the blocks within each part of the normal equations. <strong class="groops-config-element">defaultBlockReceiverCount</strong> can be set to group a number of receivers into one block within the epoch and interval parts.</p><p>If <strong class="groops-config-element">keepEpochNormalsInMemory</strong>=<code>no</code> epoch blocks are eliminated after they are set up to reduce the number of parameters in the normal equation system. <strong class="groops-config-element">defaultBlockCountReduction</strong> controls after how many epoch blocks an elimination step is performed. For larger processing setups or high sampling rates epoch block elimination is recommended as the large number of clock parameters require a lot of memory.  <h2 id="selectReceivers">SelectReceivers</h2><p> This step can be used to process only a subset of stations in subsequent processing steps. The most common use is to start the processing with a well-distributed network of core stations as seen in <a class="groops-ref" href="cookbook.gnssNetwork.html#processing">GNSS satellite orbit determination and network analysis</a>. To later process all other stations individually, use the processing step <a class="groops-class" href="gnssProcessingStepType.html#forEachReceiverSeparately">processingStep:forEachReceiverSeparately</a> and select all stations excluding the core stations in that step.  <h2 id="forEachReceiverSeparately">ForEachReceiverSeparately</h2><p> Perform these processing steps for each <a class="groops-class" href="platformSelectorType.html">selectReceivers</a> separately. All non-receiver related parameters parameters are disabled in these processing steps (see .</p><p>This step can be used for individual precise point positioning (PPP) of all stations. During <a class="groops-ref" href="cookbook.gnssNetwork.html#processing">GNSS satellite orbit determination and network analysis</a> this step is used after the initial processing of the core network to process all other stations individually. In that case provide the same station list as <a class="groops-class" href="fileFormat_stringList.html">inputfileExcludeStationList</a> in this step that was used as <a class="groops-class" href="fileFormat_stringList.html">inputfileStationList</a> in the <a class="groops-class" href="gnssProcessingStepType.html#selectReceivers">selectReceivers</a> step where the core network was selected.  <h2 id="group">Group</h2><p> Perform these processing steps. This step can be used to structure complex processing flows. The <a class="groops-class" href="gnssProcessingStepType.html#selectParametrizations">select..</a> processing steps defined within a group only affect the steps within this group.  <h2 id="disableTransmitterShadowEpochs">DisableTransmitterShadowEpochs</h2><p> Disable transmitter epochs during eclipse. With proper attitude modeling (see <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a>) this is usually not necessary.'},
'gnssReceiverGeneratorType': { 'name': 'gnssReceiverGeneratorType', 'key': 'gnssReceiverGeneratorType', 'description': 'Definition and basic information of GNSS receivers. Most of the input files are provided in GROOPS file formats at  https://ftp.tugraz.at/outgoing/ITSG/groops  (marked with  *  below). These files are regularly updated.        * :         Antenna and receiver information, antenna reference point offsets, antenna orientations.         Created via  GnssStationLog2Platform  or  PlatformCreate .      * :         Antenna center offsets and variations.         Created via  GnssAntex2AntennaDefinition  or  GnssAntennaDefinitionCreate .      :         Observed signal types (optional).         Created via  GnssReceiverDefinitionCreate  in case you want to define which signal         types a receiver model can observe.      * :         Elevation and azimuth dependent accuracy.         Created via  GnssAntennaDefinitionCreate .      :         Converted from RINEX observation files via  RinexObservation2GnssReceiver .  It is possible to limit the observation types to be used in the processing by a list of     and any observation types not defined within the list are ignored and discarded. Similarly observations defined in the list of     are ignored and discarded. The codes used follow the  . Each receiver goes through a  preprocessing  step individually, where observation outliers are removed or downweighted, continuous tracks of phase observations are defined for ambiguity parametrization, cycle slips are detected, and receivers are disabled if they do not fulfill certain requirements. The preprocessing step consists of an initial PPP estimation done by  robust least squares adjustment  and checks whether the position error of the solutions exceeds  codeMaxPositionDiff . If the error exceeds the threshold the receiver will be discarded. The preprocessing also sets initial clock error values and removes tracks that stay below a certain elevation mask ( elevationTrackMinimum ). See also  GnssProcessing  and  GnssSimulateReceiver .     A network of GNSS ground stations is defined via    . Each line can contain more than one station. The first station in each line for which     exists and contains enough observations is used for the processing. All input files except    ,    , and     are read for each station. The file name is interpreted as a template with the variable  {station}  being replaced by the station name. The effects of loading and tidal deformation on station positions can be corrected for via     and    , respectively. Tidal deformations typically include:        : Earth tidal deformations (IERS conventions)      : ocean tidal deformations         (e.g. fes2014b n720,  minDegree = 1 )      : atmospheric tidal deformation         (e.g. AOD1B RL06,  minDegree = 1 )      : pole tidal deformations (IERS conventions)      : ocean pole tidal deformations (IERS conventions)      A single low-Earth orbiting (LEO) satellite with an onboard GNSS receiver. An apriori orbit is needed as    . Attitude data must be provided via    . If no attitude data is available from the satellite operator, the star camera data can be simulated by using  SimulateStarCamera .', 'config_table': 'inputfileStationList filename ascii file with station names maxStationCount uint maximum number of stations to be used inputfileStationInfo filename variable {station} available. station metadata (antennas, receivers, ...) inputfileAntennaDefinition filename antenna center offsets and variations noAntennaPatternFound choice what should happen if no antenna pattern is found for an observation ignoreObservation  ignore observation if no matching pattern is found useNearestFrequency  use pattern of nearest frequency if no matching pattern is found throwException  throw exception if no matching pattern is found inputfileReceiverDefinition filename observed signal types inputfileAccuracyDefinition filename elevation and azimuth dependent accuracy inputfileStationPosition filename variable {station} available. inputfileClock filename variable {station} available inputfileObservations filename variable {station} available loadingDisplacement gravityfieldType loading deformation tidalDisplacement tidesType tidal deformation ephemerides ephemeridesType for tidal deformation inputfileDeformationLoadLoveNumber filename  inputfilePotentialLoadLoveNumber filename if full potential is given and not only loading potential useType gnssType only use observations that match any of these patterns ignoreType gnssType ignore observations that match any of these patterns elevationCutOff angle [degree] ignore observations below cutoff elevationTrackMinimum angle [degree] ignore tracks that never exceed minimum elevation minObsCountPerTrack uint tracks with less number of epochs with observations are dropped minEstimableEpochsRatio double [0,1] drop stations with lower ratio of estimable epochs to total epochs preprocessing sequence settings for preprocessing of observations/stations printStatistics boolean print preprocesssing statistics for all receivers huber double residuals > huber*sigma0 are downweighted huberPower double residuals > huber: sigma=(e/huber)^huberPower*sigma0 codeMaxPositionDiff double [m] max. allowed position error by PPP code only clock error estimation denoisingLambda double regularization parameter for total variation denoising used in cylce slip detection tecWindowSize uint (0 = disabled) window size for TEC smoothness evaluation used in cycle slip detection tecSigmaFactor double factor applied to moving standard deviation used as threshold in TEC smoothness evaluation during cycle slip detection outputfileTrackBefore filename variables {station}, {prn}, {trackTimeStart}, {trackTimeEnd}, {types}, TEC and MW-like combinations in cycles for each track before cycle slip detection outputfileTrackAfter filename variables {station}, {prn}, {trackTimeStart}, {trackTimeEnd}, {types}, TEC and MW-like combinations in cycles for each track after cycle slip detection inputfileStationInfo filename satellite metadata (antenna, receiver, ...) inputfileAntennaDefinition filename antenna center offsets and variations noAntennaPatternFound choice what should happen if no antenna pattern is found for an observation ignoreObservation  ignore observation if no matching pattern is found useNearestFrequency  use pattern of nearest frequency if no matching pattern is found throwException  throw exception if no matching pattern is found inputfileReceiverDefinition filename observed signal types inputfileAccuracyDefinition filename elevation and azimut dependent accuracy inputfileObservations filename  inputfileOrbit filename approximate positions inputfileStarCamera filename satellite attitude sigmaFactorPhase expression PHASE: factor = f(FREQ, ELE, SNR, ROTI, dTEc, IONOINDEX) sigmaFactorCode expression CODE: factor = f(FREQ, ELE, SNR, ROTI, dTEc, IONOINDEX) supportsIntegerAmbiguities boolean receiver tracks full cycle integer ambiguities wavelengthFactor double factor to account for half-wavelength observations (collected by codeless squaring techniques) useType gnssType only use observations that match any of these patterns ignoreType gnssType ignore observations that match any of these patterns elevationCutOff angle [degree] ignore observations below cutoff minObsCountPerTrack uint tracks with less number of epochs with observations are dropped preprocessing sequence settings for preprocessing of observations/stations printStatistics boolean print preprocesssing statistics for all receivers huber double residuals > huber*sigma0 are downweighted huberPower double residuals > huber: sigma=(e/huber)^huberPower*sigma0 codeMaxPositionDiff double [m] max. allowed position error by PPP code only clock error estimation denoisingLambda double regularization parameter for total variation denoising used in cylce slip detection tecWindowSize uint (0 = disabled) window size for TEC smoothness evaluation used in cycle slip detection tecSigmaFactor double factor applied to moving standard deviation used as threshold in TEC smoothness evaluation during cycle slip detection outputfileTrackBefore filename variables {station}, {prn}, {timeStart}, {timeEnd}, {types}, TEC and MW-like combinations in cycles for each track before cycle slip detection outputfileTrackAfter filename variables {station}, {prn}, {timeStart}, {timeEnd}, {types}, TEC and MW-like combinations in cycles for each track after cycle slip detection', 'display_text': 'Definition and basic information of GNSS receivers.</p><p>Most of the input files are provided in GROOPS file formats at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a> (marked with <b>*</b> below). These files are regularly updated. <ul>    <li><a class="groops-class" href="fileFormat_platform.html">inputfileStationInfo</a><b>*</b>:         Antenna and receiver information, antenna reference point offsets, antenna orientations.         Created via <a class="groops-program" href="GnssStationLog2Platform.html">GnssStationLog2Platform</a> or <a class="groops-program" href="PlatformCreate.html">PlatformCreate</a>.   </li><li> <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a><b>*</b>:         Antenna center offsets and variations.         Created via <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a> or <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>.   </li><li> <a class="groops-class" href="fileFormat_gnssReceiverDefinition.html">inputfileReceiverDefinition</a>:         Observed signal types (optional).         Created via <a class="groops-program" href="GnssReceiverDefinitionCreate.html">GnssReceiverDefinitionCreate</a> in case you want to define which signal         types a receiver model can observe.   </li><li> <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAccuracyDefinition</a><b>*</b>:         Elevation and azimuth dependent accuracy.         Created via <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>.   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileObservation</a>:         Converted from RINEX observation files via <a class="groops-program" href="RinexObservation2GnssReceiver.html">RinexObservation2GnssReceiver</a>. </li></ul> </p><p>It is possible to limit the observation types to be used in the processing by a list of <a class="groops-class" href="gnssType.html">useType</a> and any observation types not defined within the list are ignored and discarded. Similarly observations defined in the list of <a class="groops-class" href="gnssType.html">ignoreType</a> are ignored and discarded. The codes used follow the <a href="https://files.igs.org/pub/data/format/rinex305.pdf">RINEX 3 definition</a>.</p><p>Each receiver goes through a <strong class="groops-config-element">preprocessing</strong> step individually, where observation outliers are removed or downweighted, continuous tracks of phase observations are defined for ambiguity parametrization, cycle slips are detected, and receivers are disabled if they do not fulfill certain requirements. The preprocessing step consists of an initial PPP estimation done by <a class="groops-ref" href="fundamentals.robustLeastSquares.html">robust least squares adjustment</a> and checks whether the position error of the solutions exceeds <strong class="groops-config-element">codeMaxPositionDiff</strong>. If the error exceeds the threshold the receiver will be discarded. The preprocessing also sets initial clock error values and removes tracks that stay below a certain elevation mask (<strong class="groops-config-element">elevationTrackMinimum</strong>).</p><p>See also <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a> and <a class="groops-program" href="GnssSimulateReceiver.html">GnssSimulateReceiver</a>.  <h2 id="stationNetwork">StationNetwork</h2><p> A network of GNSS ground stations is defined via <a class="groops-class" href="fileFormat_stringTable.html">inputfileStationList</a>. Each line can contain more than one station. The first station in each line for which <a class="groops-class" href="fileFormat_instrument.html">inputfileObservations</a> exists and contains enough observations is used for the processing. All input files except <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a>, <a class="groops-class" href="fileFormat_gnssReceiverDefinition.html">inputfileReceiverDefinition</a>, and <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAccuracyDefinition</a> are read for each station. The file name is interpreted as a template with the variable <code>{station}</code> being replaced by the station name.</p><p>The effects of loading and tidal deformation on station positions can be corrected for via <a class="groops-class" href="gravityfieldType.html">loadingDisplacement</a> and <a class="groops-class" href="tidesType.html">tidalDisplacement</a>, respectively. Tidal deformations typically include: <ul>    <li><a class="groops-class" href="tidesType.html#earthTide">earthTide</a>: Earth tidal deformations (IERS conventions)   </li><li> <a class="groops-class" href="tidesType.html#doodsonHarmonicTide">doodsonHarmonicTide</a>: ocean tidal deformations         (e.g. fes2014b_n720, <strong class="groops-config-element">minDegree</strong>=<code>1</code>)   </li><li> <a class="groops-class" href="tidesType.html#doodsonHarmonicTide">doodsonHarmonicTide</a>: atmospheric tidal deformation         (e.g. AOD1B RL06, <strong class="groops-config-element">minDegree</strong>=<code>1</code>)   </li><li> <a class="groops-class" href="tidesType.html#poleTide">poleTide</a>: pole tidal deformations (IERS conventions)   </li><li> <a class="groops-class" href="tidesType.html#oceanPoleTide">poleOceanTide</a>: ocean pole tidal deformations (IERS conventions) </li></ul> </p><p> <h2 id="lowEarthOrbiter">LowEarthOrbiter</h2><p> A single low-Earth orbiting (LEO) satellite with an onboard GNSS receiver. An apriori orbit is needed as <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. Attitude data must be provided via <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>. If no attitude data is available from the satellite operator, the star camera data can be simulated by using <a class="groops-program" href="SimulateStarCamera.html">SimulateStarCamera</a>.'},
'gnssTransmitterGeneratorType': { 'name': 'gnssTransmitterGeneratorType', 'key': 'gnssTransmitterGeneratorType', 'description': 'Definition and basic information of GNSS transmitters. See also  GnssProcessing  and  GnssSimulateReceiver .     A list of satellite PRNs (i.e for GPS: G01, G02, G03, ...) must be provided via    . Satellite system codes follow the  , see  GnssType . All input files except    , and     are read for each satellite. The file name is interpreted as a template with the variable  {prn}  being replaced by the satellite PRN. Metadata input files (marked with  *  below) are provided in GROOPS file formats at  https://ftp.tugraz.at/outgoing/ITSG/groops . These files are regularly updated.        * :         PRN-SVN mapping, antenna offsets and orientations.         Created via  GnssAntex2AntennaDefinition  or  PlatformCreate .      * :         Antenna center variations.         Created via  GnssAntex2AntennaDefinition  or  GnssAntennaDefinitionCreate .      * :         Transmitted signal types.         Created via  GnssReceiverDefinitionCreate  in case you want to define which signal         types a satellite transmits.      : Converted via  Sp3Format2Orbit  or         output of  GnssProcessing .      :         Rotation from body frame to CRF. Created via  SimulateStarCameraGnss  or converted via  GnssOrbex2StarCamera .      :         Converted via  GnssClockRinex2InstrumentClock  or  GnssRinexNavigation2OrbitClock  or         output of  GnssProcessing .', 'config_table': 'inputfileTransmitterList filename ascii file with transmitter PRNs, used to loop variable {prn} inputfileTransmitterInfo filename variable {prn} available inputfileAntennaDefintion filename phase centers and variations (ANTEX like) noAntennaPatternFound choice what should happen is no antenna pattern is found for an observation ignoreObservation  ignore observation if no matching pattern is found useNearestFrequency  use pattern of nearest frequency if no matching pattern is found throwException  throw exception if no matching pattern is found inputfileSignalDefintion filename transmitted signal types inputfileOrbit filename variable {prn} available inputfileAttitude filename variable {prn} available inputfileClock filename variable {prn} available interpolationDegree uint for orbit interpolation and velocity calculation', 'display_text': 'Definition and basic information of GNSS transmitters.</p><p>See also <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a> and <a class="groops-program" href="GnssSimulateReceiver.html">GnssSimulateReceiver</a>.  <h2 id="gnss">GNSS</h2><p> A list of satellite PRNs (i.e for GPS: G01, G02, G03, ...) must be provided via <a class="groops-class" href="fileFormat_stringList.html">inputfileTransmitterList</a>. Satellite system codes follow the <a href="https://files.igs.org/pub/data/format/rinex305.pdf">RINEX 3 definition</a>, see <a class="groops-ref" href="gnssType.html">GnssType</a>. All input files except <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a>, and <a class="groops-class" href="fileFormat_gnssReceiverDefinition.html">inputfileReceiverDefinition</a> are read for each satellite. The file name is interpreted as a template with the variable <code>{prn}</code> being replaced by the satellite PRN.</p><p>Metadata input files (marked with <b>*</b> below) are provided in GROOPS file formats at <a href="https://ftp.tugraz.at/outgoing/ITSG/groops" target="_blank">https://ftp.tugraz.at/outgoing/ITSG/groops</a>. These files are regularly updated. <ul>    <li><a class="groops-class" href="fileFormat_platform.html">inputfileTransmitterInfo</a><b>*</b>:         PRN-SVN mapping, antenna offsets and orientations.         Created via <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a> or <a class="groops-program" href="PlatformCreate.html">PlatformCreate</a>.   </li><li> <a class="groops-class" href="fileFormat_gnssAntennaDefinition.html">inputfileAntennaDefinition</a><b>*</b>:         Antenna center variations.         Created via <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a> or <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>.   </li><li> <a class="groops-class" href="fileFormat_gnssReceiverDefinition.html">inputfileReceiverDefinition</a><b>*</b>:         Transmitted signal types.         Created via <a class="groops-program" href="GnssReceiverDefinitionCreate.html">GnssReceiverDefinitionCreate</a> in case you want to define which signal         types a satellite transmits.   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>: Converted via <a class="groops-program" href="Sp3Format2Orbit.html">Sp3Format2Orbit</a> or         output of <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>.   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileAttitude</a>:         Rotation from body frame to CRF. Created via <a class="groops-program" href="SimulateStarCameraGnss.html">SimulateStarCameraGnss</a> or converted via <a class="groops-program" href="GnssOrbex2StarCamera.html">GnssOrbex2StarCamera</a>.   </li><li> <a class="groops-class" href="fileFormat_instrument.html">inputfileClock</a>:         Converted via <a class="groops-program" href="GnssClockRinex2InstrumentClock.html">GnssClockRinex2InstrumentClock</a> or <a class="groops-program" href="GnssRinexNavigation2OrbitClock.html">GnssRinexNavigation2OrbitClock</a> or         output of <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>. </li></ul>'},
'gnssType': { 'name': 'gnssType', 'key': 'gnssType', 'description': 'A GnssType string consists of six parts (type, frequency, attribute, system, PRN, frequency number) represented by seven characters.    The first three characters (representing type, frequency, and attribute) correspond to the observation codes of the        .  The satellite system character also follows the RINEX 3 definition:                  G  = GPS          R  = GLONASS          E  = Galileo          C  = BeiDou          S  = SBAS          J  = QZSS          I  = IRNSS          PRN is a two-digit number identifying a satellite.  Frequency number is only used for GLONASS, where the range -7 to 14 is represented by letters starting with A.  Each part of a GnssType string can be replaced by a wildcard \' * \', enabling the use of these strings as patterns, for example to select a subset of observations (e.g.  C**G**  matches all GPS code/range observations). Trailing wildcards are optional, meaning  L1*R  is automatically expanded to  L1*R*** . For some RINEX 2 types (e.g. Galileo L5) the RINEX 3 attribute is unknown/undefined and can be replaced by  ? , for example  L5?E01 . Examples:    C1CG23  = code/range observation, L1 frequency, derived from C/A code, GPS, PRN 23  L2PR05B  = phase observation, G2 frequency, derived from P code, GLONASS, PRN 05, frequency number -6  *5*E**  = all observation types, E5a frequency, all attributes, Galileo, all PRNs', 'config_table': '', 'display_text': 'A GnssType string consists of six parts (type, frequency, attribute, system, PRN, frequency number) represented by seven characters. <ul>  <li>The first three characters (representing type, frequency, and attribute) correspond to the observation codes of the       <a href="https://files.igs.org/pub/data/format/rinex305.pdf">RINEX 3 definition</a>. </li><li> The satellite system character also follows the RINEX 3 definition:       <ul>          </li><li> <code>G</code> = GPS         </li><li> <code>R</code> = GLONASS         </li><li> <code>E</code> = Galileo         </li><li> <code>C</code> = BeiDou         </li><li> <code>S</code> = SBAS         </li><li> <code>J</code> = QZSS         </li><li> <code>I</code> = IRNSS       </li></ul>  <li>PRN is a two-digit number identifying a satellite. </li><li> Frequency number is only used for GLONASS, where the range -7 to 14 is represented by letters starting with A. </li></ul> </p><p>Each part of a GnssType string can be replaced by a wildcard \'<code>*</code>\', enabling the use of these strings as patterns, for example to select a subset of observations (e.g. <code>C**G**</code> matches all GPS code/range observations). Trailing wildcards are optional, meaning <code>L1*R</code> is automatically expanded to <code>L1*R***</code>. For some RINEX 2 types (e.g. Galileo L5) the RINEX 3 attribute is unknown/undefined and can be replaced by <code>?</code>, for example <code>L5?E01</code>.</p><p>Examples: <ul>  <li><code>C1CG23</code> = code/range observation, L1 frequency, derived from C/A code, GPS, PRN 23 </li><li> <code>L2PR05B</code> = phase observation, G2 frequency, derived from P code, GLONASS, PRN 05, frequency number -6 </li><li> <code>*5*E**</code> = all observation types, E5a frequency, all attributes, Galileo, all PRNs </li></ul>'},
'gravityfieldType': { 'name': 'gravityfieldType', 'key': 'gravityfieldType', 'description': 'This class computes functionals of the time depending gravity field, e.g potential, gravity anomalies or gravity gradients. If several instances of the class are given the results are summed up. Before summation every single result is multiplicated by a  factor . To subtract a normal field like GRS80 from a potential to get the disturbance potential you must choose one factor by 1 and the other by -1. To get the mean of two fields just set each factor to 0.5. Some of the instances gives also information about the accuracy. The variance of the result (sum) is computed by means of variance propagation.     Reads coefficients of a spherical harmonics expansion from file. The potential is given by  If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The computed result is multiplied with  factor . If  setSigmasToZero  is true the variances are set to zero. This option is only important for variance propagation and does not change the result of the gravity field functionals.     Reads coefficients of a spherical harmonics expansion (for inner space) from file. If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. The computed result is multiplied with  factor . If  setSigmasToZero  is true the variances are set to zero. This option is only important for error propagation and does not change the result of the gravity field functionals.     Reads a solution vector from file     which may be computed by a least squares adjustment (e.g. by  NormalsSolverVCE ). The coefficients of the vector are interpreted from position  indexStart  (counting from zero) with help of    . If the solution file contains solution of several right hand sides you can choose one with number  rightSide  (counting from zero). You can also read a vector from file     containing the accuracies of the coefficients. The computed result is multiplied with  factor .     Read a time variable gravity field from file     represented by a spherical harmonics expansion in the spatial domain and spline functions in the time domain. If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly. This file can be created for example by  Gravityfield2TimeSplines  or  PotentialCoefficients2BlockMeanTimeSplines . The computed result is multiplied with  factor .     The given     is interpreted as trend function and the result is computed at time   as follows  with   is  timeStart  and   is  timeStep .     The given     is interpreted as oscillation function and the result is computed at time   as follows  with  .     A     is only evaluated in the interval between  timeStart  inclusively and  timeEnd  exclusively. Outside the interval the result is zero. This class is useful to get a time series of monthly mean GRACE gravity field solutions. In each month another file of potentialCoefficients is valid. This can easily be created with    .     Treat     as gravitational forces. The tides need a realization of     to transform between the CRF and TRF and to compute rotational deformation from polar motion. It also needs     from Sun, moon, and planets.     The gravity is integrated from a topographic mass distribution. For each grid point in     a prisma with  density  is assumed. The horizontal extension is computed from the grid spacing and the vertical extension is given by  radialLowerBound  and  radialUpperBound  above ellipsoid. All values are expressions and computed for each point with given data in the grid file. The standard variables for grids are available, see  dataVariables . Example: The grid file contains the orthometric height of the topography in the first column, the geoid height in the second and the mean density of each prism in the third column. In this case the following settings should be used:    radialUpperBound  =  data0+data1 ,  radialLowerBound  =  data1 ,  density  =  data2 .  As the prim computation is time consuming a maximum distance around the evaluation point can defined with  distancePrism . Afterwards a simplified radial line (the prism mass is concentrated to a line in the center) is used up to a distance of  distanceLine . At last the prim is approximated by a point mass in the center up to a distance  distanceMax  (if set). Prisms nearby the evaluation point can be excluded with  distanceMin .     The given     is interpreted as an oscillation function in the gravitational potential field, caused by large earthquakes. The result is computed at time   as follows:  with  . In this equation,   is the attenuation factor,   is the overtone factor,   is degree,   is order, and   is time in second.   and   are computed with the elastic Earth model or observed from the long period record of superconducting gravimeter measurements after the earthquakes.     Convert     to spherical harmonics and     the coefficients.     Groups a set of     and has no further effect itself.', 'config_table': 'inputfilePotentialCoefficients filename  minDegree uint  maxDegree uint  factor double the result is multiplied by this factor, set -1 to subtract the field setSigmasToZero boolean set variances to zero, should be used by adding back reference fields inputfilePotentialCoefficients filename  minDegree uint  maxDegree uint  factor double the result is multiplied by this factor, set -1 to subtract the field setSigmasToZero boolean set variances to zero, should be used by adding back reference fields parametrization parametrizationGravityType  inputfileSolution filename solution vector inputfileSigmax filename standards deviations or covariance matrix of the solution indexStart uint position in the solution vector rightSide uint if solution contains several right hand sides, select one factor double the result is multiplied by this factor, set -1 to subtract the field inputfileTimeSplinesGravityfield filename  inputfileTimeSplinesCovariance filename  minDegree uint  maxDegree uint  factor double the result is multiplied by this factor, set -1 to subtract the field gravityfield gravityfieldType this field is multiplicated by (time-time0)/timeStep timeStart time reference time timeStep time  gravityfieldCos gravityfieldType multiplicated by cos(2pi/T(time-time0)) gravityfieldSin gravityfieldType multiplicated by sin(2pi/T(time-time0)) time0 time reference time period time [day] gravityfield gravityfieldType  timeStart time first point in time timeEnd time last point in time will be less or equal timeEnd tides tidesType  earthRotation earthRotationType  ephemerides ephemeridesType  inputfileGridRectangular filename Digital Terrain Model density expression expression [kg/m**3] radialUpperBound expression expression (variables \'height\', \'data\', \'L\', \'B\' and, \'area\' are taken from the gridded data radialLowerBound expression expression (variables \'height\', \'data\', \'L\', \'B\' and, \'area\' are taken from the gridded data distanceMin double [km] min. influence distance (ignore near zone) distancePrism double [km] max. distance for prism formular distanceLine double [km] max. distance for radial integration distanceMax double [km] max. influence distance (ignore far zone) factor double the result is multiplied by this factor, set -1 to subtract the field inputCoefficientMatrix filename oscillation model parameters time0 time the time earthquake happened minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius gravityfield gravityfieldType  filter sphericalHarmonicsFilterType  gravityfield gravityfieldType  factor double the result is multiplied by this factor, set -1 to subtract the field', 'display_text': 'This class computes functionals of the time depending gravity field, e.g potential, gravity anomalies or gravity gradients.</p><p>If several instances of the class are given the results are summed up. Before summation every single result is multiplicated by a <strong class="groops-config-element">factor</strong>. To subtract a normal field like GRS80 from a potential to get the disturbance potential you must choose one factor by 1 and the other by -1. To get the mean of two fields just set each factor to 0.5.</p><p>Some of the instances gives also information about the accuracy. The variance of the result (sum) is computed by means of variance propagation.  <h2 id="potentialCoefficients">PotentialCoefficients</h2><p> Reads coefficients of a spherical harmonics expansion from file. The potential is given by \\[ V(\\lambda,\\vartheta,r) = \\frac{GM}{R}\\sum_{n=0}^\\infty \\sum_{m=0}^n \\left(\\frac{R}{r}\\right)^{n+1}   \\left(c_{nm} C_{nm}(\\lambda,\\vartheta) + s_{nm} S_{nm}(\\lambda,\\vartheta)\\right). \\]If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The computed result is multiplied with <strong class="groops-config-element">factor</strong>. If <strong class="groops-config-element">setSigmasToZero</strong> is true the variances are set to zero. This option is only important for variance propagation and does not change the result of the gravity field functionals.  <h2>PotentialCoefficientsInterior</h2><p> Reads coefficients of a spherical harmonics expansion (for inner space) from file. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. The computed result is multiplied with <strong class="groops-config-element">factor</strong>. If <strong class="groops-config-element">setSigmasToZero</strong> is true the variances are set to zero. This option is only important for error propagation and does not change the result of the gravity field functionals.  <h2 id="fromParametrization">FromParametrization</h2><p> Reads a solution vector from file <a class="groops-class" href="fileFormat_matrix.html">inputfileSolution</a> which may be computed by a least squares adjustment (e.g. by <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>). The coefficients of the vector are interpreted from position <strong class="groops-config-element">indexStart</strong> (counting from zero) with help of <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>. If the solution file contains solution of several right hand sides you can choose one with number <strong class="groops-config-element">rightSide</strong> (counting from zero). You can also read a vector from file <a class="groops-class" href="fileFormat_matrix.html">inputfileSigmax</a> containing the accuracies of the coefficients.</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="timeSplines">TimeSplines</h2><p> Read a time variable gravity field from file <a class="groops-class" href="fileFormat_timeSplinesGravityField.html">inputfileTimeSplinesGravityfield</a> represented by a spherical harmonics expansion in the spatial domain and spline functions in the time domain. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly.</p><p>This file can be created for example by <a class="groops-program" href="Gravityfield2TimeSplines.html">Gravityfield2TimeSplines</a> or <a class="groops-program" href="PotentialCoefficients2BlockMeanTimeSplines.html">PotentialCoefficients2BlockMeanTimeSplines</a>.</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="trend">Trend</h2><p> The given <a class="groops-class" href="gravityfieldType.html">gravityfield</a> is interpreted as trend function and the result is computed at time $t$ as follows \\[ V(\\M x,t) = \\frac{t-t_0}{\\Delta t}V(\\M x), \\]with $t_0$ is <strong class="groops-config-element">timeStart</strong> and $\\Delta t$ is <strong class="groops-config-element">timeStep</strong>.  <h2 id="oscillation">Oscillation</h2><p> The given <a class="groops-class" href="gravityfieldType.html">gravityfield</a> is interpreted as oscillation function and the result is computed at time $t$ as follows \\[ V(\\M x,t) = \\cos(\\omega)V_{cos}(\\M x)+\\sin(\\omega)V_{sin}(\\M x), \\]with $\\omega=\\frac{2\\pi}{T}(t-t_0)$.  <h2>InInterval</h2><p> A <a class="groops-class" href="gravityfieldType.html">gravityfield</a> is only evaluated in the interval between <strong class="groops-config-element">timeStart</strong> inclusively and <strong class="groops-config-element">timeEnd</strong> exclusively. Outside the interval the result is zero.</p><p>This class is useful to get a time series of monthly mean GRACE gravity field solutions. In each month another file of potentialCoefficients is valid. This can easily be created with <a class="groops-class" href="loopType.html">loop</a>.  <h2 id="tides">Tides</h2><p> Treat <a class="groops-class" href="tidesType.html">tides</a> as gravitational forces. The tides need a realization of <a class="groops-class" href="earthRotationType.html">earthRotation</a> to transform between the CRF and TRF and to compute rotational deformation from polar motion. It also needs <a class="groops-class" href="ephemeridesType.html">ephemerides</a> from Sun, moon, and planets.  <h2 id="topography">Topography</h2><p> The gravity is integrated from a topographic mass distribution. For each grid point in <a class="groops-class" href="fileFormat_griddedData.html">inputfileGridRectangular</a> a prisma with <strong class="groops-config-element">density</strong> is assumed. The horizontal extension is computed from the grid spacing and the vertical extension is given by <strong class="groops-config-element">radialLowerBound</strong> and <strong class="groops-config-element">radialUpperBound</strong> above ellipsoid. All values are expressions and computed for each point with given data in the grid file. The standard variables for grids are available, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.</p><p>Example: The grid file contains the orthometric height of the topography in the first column, the geoid height in the second and the mean density of each prism in the third column. In this case the following settings should be used: <ul>  <li><strong class="groops-config-element">radialUpperBound</strong> = <code>data0+data1</code>, </li><li> <strong class="groops-config-element">radialLowerBound</strong> = <code>data1</code>, </li><li> <strong class="groops-config-element">density</strong> = <code>data2</code>. </li></ul> </p><p>As the prim computation is time consuming a maximum distance around the evaluation point can defined with <strong class="groops-config-element">distancePrism</strong>. Afterwards a simplified radial line (the prism mass is concentrated to a line in the center) is used up to a distance of <strong class="groops-config-element">distanceLine</strong>. At last the prim is approximated by a point mass in the center up to a distance <strong class="groops-config-element">distanceMax</strong> (if set). Prisms nearby the evaluation point can be excluded with <strong class="groops-config-element">distanceMin</strong>.  <h2>EarthquakeOscillation</h2><p> The given <a class="groops-class" href="gravityfieldType.html">gravityfield</a> is interpreted as an oscillation function in the gravitational potential field, caused by large earthquakes. The result is computed at time $t$ as follows: \\[ C_{lm}(\\M t) = \\sum_{n=0}^NC_{nlm}(1-\\cos(\\omega)\\exp(\\frac{-\\omega}{2Q_{nlm}})), \\]with $\\omega=\\frac{2\\pi}{T_{nlm}}(t-t_0)$. In this equation, $Q_{nlm}$ is the attenuation factor, $n$ is the overtone factor, $m$ is degree, $l$ is order, and $t$ is time in second. $T_{nlm}$ and $Q_{nlm}$ are computed with the elastic Earth model or observed from the long period record of superconducting gravimeter measurements after the earthquakes.  <h2>Filter</h2><p> Convert <a class="groops-class" href="gravityfieldType.html">gravityfield</a> to spherical harmonics and <a class="groops-class" href="sphericalHarmonicsFilterType.html">filter</a> the coefficients.  <h2 id="group">Group</h2><p> Groups a set of <a class="groops-class" href="gravityfieldType.html">gravityfield</a> and has no further effect itself.'},
'gridType': { 'name': 'gridType', 'key': 'gridType', 'description': 'This class generates a set of grid points. In a first step, the grid is always generated globally, with     a regional subset of points can be extracted from the global grid. The parameters  R  and  inverseFlattening  define the shape of the ellipsoid on which the grid is generated. In case  inverseFlattening  is chosen as zero, a sphere is used. With  height  the distance of the points above the ellipsoid can be defined. In addition to the location of the points, weights are assigned to each of the points. These weights can be regarded as the surface element associated with each grid point.     The geographical grid is an equal-angular point distribution with points located along meridians and along circles of latitude.  deltaLambda  denotes the angular difference between adjacent points along meridians and  deltaPhi  describes the angular difference between adjacent points along circles of latitude. The point setting results as follows:  The number of grid points can be determined by  The weights are calculated according to      The zeroth level of densification coincides with the 12 icosahedron vertices, as displayed in the upper left part of Fig.  . Then, depending on the envisaged densification, each triangle edge is divided into   parts, illustrated in the upper right part of Fig.  . The new nodes on the edges are then connected by arcs of great circles parallel to the triangle edges. The intersections of each three corresponding parallel lines become nodes of the densified grid as well. As in case of a spherical triangle those three connecting lines do not exactly intersect in one point, the center of the resulting triangle is used as location for the new node (lower left part of Fig.  ). The lower right side of Fig.   finally shows the densified triangle vertex grid for a level of  . The number of grid points in dependence of the chosen level of densification can be calculated by         The points of the zeroth level are located at the centers of the icosahedron triangles. To achieve a finer grid, each of the triangles is divided into four smaller triangles by connecting the midpoints of the triangle edges. The refined grid points are again located at the center of the triangles. Subsequently, the triangles can be further densified up to the desired level of densification  , which is defined by  level . The number of global grid points for a certain level can be determined by  Thus the quantity of grid points depends exponentially on the level  , as with every additional level the number of grid points quadruplicates.      The grid features equiangular spacing along circles of latitude with   parallelsCount  defining the number   of the parallels.  Along the meridians the points are located at   parallels at the   zeros   of the Legendre polynomial of degree  ,  Consequently, the number of grid points sums up to  The weights can be calculated according to      The Reuter grid features equi-distant spacing along the meridians determined by the control parameter   according to  Thus   denotes the number of points per meridian, as the two poles are included in the point distribution as well. Along the circles of latitude, the number of grid points decreases with increasing latitude in order to achieve an evenly distributed point pattern. This number is chosen, so that the points along each circle of latitude have the same spherical distance as two adjacent latitudes. The resulting relationship is given by  The left hand side of this equation is the spherical distance between adjacent latitudes, the right hand side stands for the spherical distance between two points with the same polar distance   and a longitudinal difference of  . This longitudinal distance can be adjusted depending on   to fulfill Eq.  . The resulting formula for   is  The number of points   for each circle of latitude can then be determined by  Here the Gauss bracket   specifies the largest integer equal to or less than  . The longitudes are subsequently determined by  The number of grid points can be estimated by  The   results from the fact that the   are restricted to integer values.     This kind of grid distributes an arbitrarily chosen number of   points (defined by  globalPointsCount ) following a recursive, quasi random sequence. In longitudinal direction the pattern follows  This implies that every grid point features a unique longitude, with equi-angular longitudinal differences. The polar distance in the form   for each point is determined by the following recursive sequence:    Starting from an interval  .  If  , then the midpoint of the interval is returned as result of the sequence, and the sequence is terminated.  If the number of points is uneven, the  midpoint is included into the list of  .  Subsequently, the interval is bisected into an upper and lower half,        and the sequence is called for both halves.   from upper and lower half are alternately sorted into the list of  .  The polar distances are calculated by       The Driscoll-Healy grid, has equiangular spacing along the meridians as well as along the circles of latitude. In longitudinal direction (along the parallels), these angular differences for a given  dimension    coincide with those described for the corresponding geographical grid and Gauss grid. Along the meridians, the size of the latitudinal differences is half the size compared to the geographical grid. This results in the following point pattern,  Consequently, the number of grid points is  The weights are given by      Creates one single point.     Creates one single point.     In this class grid is read from a file, which is given by    . A corresponding file can be generated with  GriddedDataCreate  or with  Matrix2GriddedData .', 'config_table': 'deltaLambda angle  deltaPhi angle  height double ellipsoidal height expression (variables \'height\', \'L\', \'B\') R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  level uint division of icosahedron, point count = 10*(n+1)**2+2 R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  level uint division of icosahedron, point count = 5*4**(n+1) R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  parallelsCount uint  R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  gamma uint number of parallels height double ellipsoidal height R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  globalPointsCount uint  height double ellipsoidal height R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  dimension uint number of parallels = 2*dimension height double ellipsoidal height R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere border borderType  L angle longitude B angle latitude height double ellipsoidal height area double associated area element on unit sphere R double major axsis of the ellipsoid/sphere inverseFlattening double flattening of the ellipsoid, 0: sphere x double [m] y double [m] z double [m] area double associated area element on unit sphere inputfileGrid filename  border borderType', 'display_text': 'This class generates a set of grid points. In a first step, the grid is always generated globally, with <a class="groops-class" href="borderType.html">border</a> a regional subset of points can be extracted from the global grid. The parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong> define the shape of the ellipsoid on which the grid is generated. In case <strong class="groops-config-element">inverseFlattening</strong> is chosen as zero, a sphere is used. With <strong class="groops-config-element">height</strong> the distance of the points above the ellipsoid can be defined. In addition to the location of the points, weights are assigned to each of the points. These weights can be regarded as the surface element associated with each grid point.  <h2>Geograph</h2><p> The geographical grid is an equal-angular point distribution with points located along meridians and along circles of latitude. <strong class="groops-config-element">deltaLambda</strong> denotes the angular difference between adjacent points along meridians and <strong class="groops-config-element">deltaPhi</strong> describes the angular difference between adjacent points along circles of latitude. The point setting results as follows: \\[ \\lambda_i=\\frac{\\Delta\\lambda}{2}+i\\cdot\\Delta\\lambda\\qquad\\mbox{with}\\qquad 0\\leq i< \\frac{360^\\circ}{\\Delta\\lambda}, \\]\\[ \\varphi_j=-90^\\circ+\\frac{\\Delta\\varphi}{2}+j\\cdot\\Delta\\varphi\\qquad\\mbox{with}\\qquad 0\\leq j<\\frac{180^\\circ}{\\Delta\\varphi}. \\]The number of grid points can be determined by \\[ I=\\frac{360^\\circ}{\\Delta\\lambda}\\cdot\\frac{180^\\circ}{\\Delta\\varphi}. \\]The weights are calculated according to \\[ w_i=\\int\\limits_{\\lambda_i-\\frac{\\Delta\\lambda}{2}}^{\\lambda_i+\\frac{\\Delta\\lambda}{2}}\\int\\limits_{\\vartheta_i-\\frac{\\Delta\\vartheta}{2}}^{\\vartheta_i+\\frac{\\Delta\\vartheta}{2}}=2\\cdot\\Delta\\lambda\\sin(\\Delta\\vartheta)\\sin(\\vartheta_i). \\] <h2>TriangleVertex</h2><p> The zeroth level of densification coincides with the 12 icosahedron vertices, as displayed in the upper left part of Fig. <a href="fig.html#triangle_grid">fig:triangle_grid</a>. Then, depending on the envisaged densification, each triangle edge is divided into $n$ parts, illustrated in the upper right part of Fig. <a href="fig.html#triangle_grid">fig:triangle_grid</a>. The new nodes on the edges are then connected by arcs of great circles parallel to the triangle edges. The intersections of each three corresponding parallel lines become nodes of the densified grid as well. As in case of a spherical triangle those three connecting lines do not exactly intersect in one point, the center of the resulting triangle is used as location for the new node (lower left part of Fig. <a href="fig.html#triangle_grid">fig:triangle_grid</a>). The lower right side of Fig. <a href="fig.html#triangle_grid">fig:triangle_grid</a> finally shows the densified triangle vertex grid for a level of $n=3$. The number of grid points in dependence of the chosen level of densification can be calculated by \\[\\label{eq:numberVertex} I=10\\cdot(n+1)^2+2. \\]   <h2>TriangleCenter</h2><p> The points of the zeroth level are located at the centers of the icosahedron triangles. To achieve a finer grid, each of the triangles is divided into four smaller triangles by connecting the midpoints of the triangle edges. The refined grid points are again located at the center of the triangles. Subsequently, the triangles can be further densified up to the desired level of densification $n$, which is defined by <strong class="groops-config-element">level</strong>.</p><p>The number of global grid points for a certain level can be determined by \\[\\label{eq:numberCenter} I=20\\cdot 4^n. \\]Thus the quantity of grid points depends exponentially on the level $n$, as with every additional level the number of grid points quadruplicates.  <h2>Gauss</h2><p>  The grid features equiangular spacing along circles of latitude with  <strong class="groops-config-element">parallelsCount</strong> defining the number $L$ of the parallels. \\[ \\Delta\\lambda=\\frac{\\pi}{L}\\qquad\\Rightarrow\\qquad\\lambda_i=\\frac{\\Delta\\lambda}{2}+i\\cdot\\Delta\\lambda\\qquad\\mbox{with}\\qquad 0\\leq i< 2L. \\]Along the meridians the points are located at $L$ parallels at the $L$ zeros $\\vartheta_j$ of the Legendre polynomial of degree $L$, \\[ P_L(\\cos\\vartheta_j)=0. \\]Consequently, the number of grid points sums up to \\[ I=2\\cdot L^2. \\]The weights can be calculated according to \\[ w_i(L)=\\Delta\\lambda\\frac{2}{(1-t_i^2)(P\'_{L}(\\cos(\\vartheta _i)))^2},\\label{weights} \\] <h2>Reuter</h2><p> The Reuter grid features equi-distant spacing along the meridians determined by the control parameter $\\gamma$ according to \\[ \\Delta\\vartheta=\\frac{\\pi}{\\gamma}\\qquad\\Rightarrow\\vartheta_j=j\\Delta\\vartheta,\\qquad\\mbox{with}\\qquad 1\\leq j\\leq \\gamma-1. \\]Thus $\\gamma+1$ denotes the number of points per meridian, as the two poles are included in the point distribution as well. Along the circles of latitude, the number of grid points decreases with increasing latitude in order to achieve an evenly distributed point pattern. This number is chosen, so that the points along each circle of latitude have the same spherical distance as two adjacent latitudes. The resulting relationship is given by \\[\\label{eq:sphericalDistance} \\Delta\\vartheta=\\arccos\\left( \\cos^2\\vartheta_j+\\sin^2\\vartheta_j\\cos\\Delta\\lambda_j\\right). \\]The left hand side of this equation is the spherical distance between adjacent latitudes, the right hand side stands for the spherical distance between two points with the same polar distance $\\vartheta_j$ and a longitudinal difference of $\\Delta\\lambda_i$. This longitudinal distance can be adjusted depending on $\\vartheta_j$ to fulfill Eq. \\eqref{eq:sphericalDistance}. The resulting formula for $\\Delta\\lambda_i$ is \\[\\label{eq:deltaLambdai} \\Delta\\lambda_j=\\arccos\\left( \\frac{\\sin\\Delta\\vartheta -\\cos^2\\vartheta_j}{\\sin^2\\vartheta_j}\\right). \\]The number of points $\\gamma_j$ for each circle of latitude can then be determined by \\[\\label{eq:gammai} \\gamma_j=\\left[ \\frac{2\\pi}{\\Delta\\lambda_j}\\right] . \\]Here the Gauss bracket $[x]$ specifies the largest integer equal to or less than $x$. The longitudes are subsequently determined by \\[ \\lambda_{ij}=\\frac{\\Delta\\lambda_j}{2}+i\\cdot(2\\pi/\\gamma_j),\\qquad\\mbox{with}\\qquad 0\\leq i< \\gamma_j. \\]The number of grid points can be estimated by \\[\\label{eq:numberReuter} I=\\leq 2+\\frac{4}{\\pi}\\gamma^2, \\]The $\\leq$ results from the fact that the $\\gamma_j$ are restricted to integer values.  <h2>Corput</h2><p> This kind of grid distributes an arbitrarily chosen number of $I$ points (defined by <strong class="groops-config-element">globalPointsCount</strong>) following a recursive, quasi random sequence. In longitudinal direction the pattern follows \\[ \\Delta\\lambda=\\frac{2\\pi}{I}\\qquad\\Rightarrow\\qquad\\frac{\\Delta\\lambda}{2}+\\lambda_i=i\\cdot\\Delta\\lambda\\qquad\\mbox{with}\\qquad 1\\leq i\\leq I. \\]This implies that every grid point features a unique longitude, with equi-angular longitudinal differences.</p><p>The polar distance in the form $t_i=\\cos\\vartheta_i$ for each point is determined by the following recursive sequence: <ul>  <li>Starting from an interval $t\\in[-1,1]$. </li><li> If $I=1$, then the midpoint of the interval is returned as result of the sequence, and the sequence is terminated. </li><li> If the number of points is uneven, the  midpoint is included into the list of $t_i$. </li><li> Subsequently, the interval is bisected into an upper and lower half,        and the sequence is called for both halves. </li><li> $t$ from upper and lower half are alternately sorted into the list of $t_i$. </li><li> The polar distances are calculated by \\[ \\vartheta_i=\\arccos\\, t_i. \\]</li></ul>   <h2>Driscoll</h2><p> The Driscoll-Healy grid, has equiangular spacing along the meridians as well as along the circles of latitude. In longitudinal direction (along the parallels), these angular differences for a given <strong class="groops-config-element">dimension</strong> $L$ coincide with those described for the corresponding geographical grid and Gauss grid. Along the meridians, the size of the latitudinal differences is half the size compared to the geographical grid. This results in the following point pattern, \\[ \\begin{split} \\Delta\\lambda=\\frac{\\pi}{L}\\qquad&\\Rightarrow\\qquad\\lambda_i=\\frac{\\Delta\\lambda}{2}+i\\cdot\\Delta\\lambda\\qquad&\\mbox{with}\\qquad 0\\leq i< 2L, \\\\ \\Delta\\vartheta=\\frac{\\pi}{2L}\\qquad&\\Rightarrow\\qquad\\vartheta_j=j\\cdot\\Delta\\vartheta\\qquad&\\mbox{with}\\qquad 1\\leq j\\leq 2L. \\end{split} \\]Consequently, the number of grid points is \\[ I=4\\cdot L^2. \\]The weights are given by \\[ w_i=\\Delta\\lambda\\frac{4}{2L}\\sin(\\vartheta_i)\\sum_{l=0}^{L-1}\\frac{\\sin\\left[ (2l+1)\\;\\vartheta_i\\right] }{2l+1}. \\] <h2>SinglePoint</h2><p> Creates one single point.  <h2>SinglePointCartesian</h2><p> Creates one single point.  <h2 id="file">File</h2><p> In this class grid is read from a file, which is given by <a class="groops-class" href="fileFormat_griddedData.html">inputfileGrid</a>. A corresponding file can be generated with <a class="groops-program" href="GriddedDataCreate.html">GriddedDataCreate</a> or with <a class="groops-program" href="Matrix2GriddedData.html">Matrix2GriddedData</a>.'},
'instrumentTypeType': { 'name': 'instrumentTypeType', 'key': 'instrumentTypeType', 'description': 'Defines the type of an  instrument file .', 'config_table': 'instrumentTypeType choice instrument type INSTRUMENTTIME  time without data MISCVALUE  single value MISCVALUES  multiple values VECTOR3D  x, y, z COVARIANCE3D  xx, yy, zz, xy, xz, yz ORBIT  position [m], velocity [m/s], acceleration [m/s^2] (each x, y, z) STARCAMERA  quaternions (q0, qx, qy, qz) ACCELEROMETER  x, y, z [m/s^2] SATELLITETRACKING  range [m], range rate [m/s], range acceleration [m/s^2] GRADIOMETER  xx, yy, zz, xy, xz, yz [1/s^2] GNSSRECEIVER  GNSS phase/code observations [m] OBSERVATIONSIGMA  accuracy MASS   THRUSTER   MAGNETOMETER   ACCHOUSEKEEPING', 'display_text': 'Defines the type of an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>.'},
'interpolatorTimeSeriesType': { 'name': 'interpolatorTimeSeriesType', 'key': 'interpolatorTimeSeriesType', 'description': 'This class resamples data of a times series to new poins in time.     Polynomial prediction using a moving polynomial of  polynomialDegree . The optimal polynomial is chosen based on the centricity of the data points around the resampling point and the distance to all polynomial data points. All polynomial data points must be within  maxDataPointRange . Resampling points within  maxExtrapolationDistance  of the polynomial will be extrapolated. The elements  maxDataPointRange  and  maxExtrapolationDistance  are given in the unit of seconds. If negative values are used, the unit is relative to the median input sampling.      A polynomial of  polynomialDegree  is estimated using all data points within  maxDataPointDistance  of the resampling point. This polynomial is then used to predict the resampling point. A resampling point will be extrapolated if there are only data points before/after as long as the closest one is within  maxExtrapolationDistance . The elements  maxDataPointDistance  and  maxExtrapolationDistance  are given in the unit of seconds. If negative values are used, the unit is relative to the median input sampling.', 'config_table': 'polynomialDegree uint degree of the moving polynomial maxDataPointRange double [seconds] all degree+1 data points must be within this range for a valid polynomial maxExtrapolationDistance double [seconds] resampling points within this range of the polynomial will be extrapolated polynomialDegree uint degree of the estimated polynomial maxDataPointDistance double [seconds] all data points within this distance around the resampling point will be used maxExtrapolationDistance double [seconds] resampling points within this range of the polynomial will be extrapolated polynomialDegree uint degree of the estimated polynomial maxDataGap double [seconds] max data gap to interpolate maxDataSpan double [seconds] time span on each side used for least squares fit margin double [seconds] margin for identical times', 'display_text': 'This class resamples data of a times series to new poins in time.  <h2>Polynomial</h2><p> Polynomial prediction using a moving polynomial of <strong class="groops-config-element">polynomialDegree</strong>. The optimal polynomial is chosen based on the centricity of the data points around the resampling point and the distance to all polynomial data points. All polynomial data points must be within <strong class="groops-config-element">maxDataPointRange</strong>. Resampling points within <strong class="groops-config-element">maxExtrapolationDistance</strong> of the polynomial will be extrapolated. The elements <strong class="groops-config-element">maxDataPointRange</strong> and <strong class="groops-config-element">maxExtrapolationDistance</strong> are given in the unit of seconds. If negative values are used, the unit is relative to the median input sampling.</p><p>  <h2>Least squares polynomial fit</h2><p> A polynomial of <strong class="groops-config-element">polynomialDegree</strong> is estimated using all data points within <strong class="groops-config-element">maxDataPointDistance</strong> of the resampling point. This polynomial is then used to predict the resampling point. A resampling point will be extrapolated if there are only data points before/after as long as the closest one is within <strong class="groops-config-element">maxExtrapolationDistance</strong>. The elements <strong class="groops-config-element">maxDataPointDistance</strong> and <strong class="groops-config-element">maxExtrapolationDistance</strong> are given in the unit of seconds. If negative values are used, the unit is relative to the median input sampling.</p><p>  <h2>Fill gaps with least squares polynomial fit</h2><p>'},
'kernelType': { 'name': 'kernelType', 'key': 'kernelType', 'description': 'Kernel defines harmonic isotropic integral kernels  .  where   is the (disturbance)potential and   is a functional on the spherical surface  . The Kernel can be exapanded into a series of (fully normalized) legendre polynomials  On the one hand the kernel defines the type of the functionals   that are measured or have to be computed, e.g. gravity anomalies given by the Stokes-kernel. On the other hand the kernel functions can be used as basis functions to represent the gravity field, e.g. as spline functions or wavelets.     The geoid height is defined by Bruns formula  with   the disturbance potential and the normal gravity  and  where   is the ellipsoidal height in meter and   the longitude. The kernel is given by  and the coefficients in   are      Gravity anomalies in linearized form are defined by  The Stokes kernel is given by  and the coefficients in   are      Gravity disturbances in linearized form are defined by  The Hotine kernel is given by  and the coefficients in   are      The Abel-Poisson kernel is given by  and the coefficients in   are      This kernel defines a point mass or mass on a single layer ( -kernel) taking the effect of the loading into account. The coefficients of the kernel defined in   are  where   is the gravitational constant and   are the load Love numbers.     Height of equivalent water columns taking the effect of the loading into account. The coefficients of the kernel defined in   are  where   is the gravitational constant,   is the  density  of water and   are the load Love numbers.     Ocean bottom pressure caused by water and atmosphere masses columns taking the effect of the loading into account. The coefficients of the kernel defined in   are  where   is the gravitational constant,   is the normal gravity and   are the load Love numbers.     Computes the radial deformation caused by loading. The coefficients of the kernel defined in   are  where   is the normal gravity defined in  ,   and   are the load Love numbers and the load deformation Love numbers.     This kernel defines the second radial derivative of the (disturbance) potential.  The coefficients of the kernel defined in   are      The kernel is defined by the coefficients   given by file.     Another     is smoothed by a gauss filter which is defined by  with   where   is the given smoothing  radius  in km and   km is the Earth radius. The coefficients   of the  kernel  are multiplicated by      Another     is smoothed by a Blackman low-pass filter. The filter is defined through the beginning and end of the transition from pass-band to stop-band. This transition band is specified by  startDegreeTransition  ( ) and  stopDegreeTransition  ( ). The coefficients of this kernel are defined as  with      Another     is truncated before  minDegree  and after  maxDegree . The coefficients of this kernel are defined as      The selenoid height is defined by Bruns formula  with   the disturbance potential and the normal gravity   of the moon. The kernel is given by  and the coefficients in   are', 'config_table': 'inputfileLoadingLoveNumber filename  density double [kg/m**3] inputfileLoadingLoveNumber filename  inputfileLoadingLoveNumber filename  inputfileDeformationLoadLoveNumber filename  inputfilePotentialLoadLoveNumber filename if full potential is given and not only loading potential inputfileCoefficients filename  kernel kernelType  radius double filter radius [km] kernel kernelType  startDegreeTransition uint minimum degree in transition band stopDegreeTransition uint maximum degree in transition band kernel kernelType  minDegree uint truncate before minDegree maxDegree uint truncate after maxDegree', 'display_text': 'Kernel defines harmonic isotropic integral kernels $K$. \\[ T(P) = \\frac{1}{4\\pi}\\int_\\Omega K(P,Q)\\cdot f(Q)\\,d\\Omega(Q), \\]where $T$ is the (disturbance)potential and $f$ is a functional on the spherical surface $\\Omega$. The Kernel can be exapanded into a series of (fully normalized) legendre polynomials \\[\\label{eq.kernel} K(\\cos\\psi,r,R) = \\sum_n \\left(\\frac{R}{r}\\right)^{n+1} k_n\\sqrt{2n+1}\\bar{P}_n(\\cos\\psi). \\]On the one hand the kernel defines the type of the functionals $f$ that are measured or have to be computed, e.g. gravity anomalies given by the Stokes-kernel. On the other hand the kernel functions can be used as basis functions to represent the gravity field, e.g. as spline functions or wavelets.  <h2 id="geoidHeight">GeoidHeight</h2><p> The geoid height is defined by Bruns formula \\[ N = \\frac{1}{\\gamma}T \\]with $T$ the disturbance potential and the normal gravity \\[\\label{normalgravity} \\gamma  = \\gamma_0 - 0.30877\\cdot 10^{-5}/s^2(1-0.00142\\sin^2(B))h \\]and \\[ \\gamma_0 = 9.780327\\,m/s^2(1+0.0053024\\sin^2(B)-0.0000058\\sin^2(2B)) \\]where $h$ is the ellipsoidal height in meter and $B$ the longitude.</p><p>The kernel is given by \\[ K(\\cos\\psi,r,R) = \\gamma\\frac{R(r^2-R^2)}{l^3}, \\]and the coefficients in \\eqref{eq.kernel} are \\[ k_n = \\gamma. \\] <h2>Anomalies</h2><p> Gravity anomalies in linearized form are defined by \\[ \\Delta g = -\\frac{\\partial T}{\\partial r}-\\frac{2}{r}T. \\]The Stokes kernel is given by \\[ K(\\cos\\psi,r,R) = \\frac{2R^2}{l}-3\\frac{Rl}{r^2}-\\frac{R^2}{r^2}\\cos\\psi \\left(5+3\\ln\\frac{l+r-R\\cos\\psi}{2r}\\right), \\]and the coefficients in \\eqref{eq.kernel} are \\[ k_n = \\frac{R}{n-1}. \\] <h2 id="disturbance">Disturbance</h2><p> Gravity disturbances in linearized form are defined by \\[ \\delta g = -\\frac{dT}{dr}. \\]The Hotine kernel is given by \\[ K(\\cos\\psi,r,R) = \\frac{2R^2}{l}-R\\ln\\frac{l+R-r\\cos\\psi}{r(1-\\cos\\psi)}, \\]and the coefficients in \\eqref{eq.kernel} are \\[ k_n = \\frac{R}{n+1}. \\] <h2>Potential</h2><p> The Abel-Poisson kernel is given by \\[ K(\\cos\\psi,r,R) = \\frac{R(r^2-R^2)}{l^3}, \\]and the coefficients in \\eqref{eq.kernel} are \\[ k_n = 1. \\] <h2>Density</h2><p> This kernel defines a point mass or mass on a single layer ($1/l$-kernel) taking the effect of the loading into account.</p><p>The coefficients of the kernel defined in \\eqref{eq.kernel} are \\[ k_n = 4\\pi G R\\frac{1+k_n\'}{2n+1}, \\]where $G$ is the gravitational constant and $k_n\'$ are the load Love numbers.  <h2 id="waterHeight">WaterHeight</h2><p> Height of equivalent water columns taking the effect of the loading into account.</p><p>The coefficients of the kernel defined in \\eqref{eq.kernel} are \\[ k_n = 4\\pi G \\rho R\\frac{1+k_n\'}{2n+1}, \\]where $G$ is the gravitational constant, $\\rho$ is the <strong class="groops-config-element">density</strong> of water and $k_n\'$ are the load Love numbers.  <h2>BottomPressure</h2><p> Ocean bottom pressure caused by water and atmosphere masses columns taking the effect of the loading into account.</p><p>The coefficients of the kernel defined in \\eqref{eq.kernel} are \\[ k_n = \\frac{4\\pi G R }{\\gamma}\\frac{1+k_n\'}{2n+1}, \\]where $G$ is the gravitational constant, $\\gamma$ is the normal gravity and $k_n\'$ are the load Love numbers.  <h2>Deformation</h2><p> Computes the radial deformation caused by loading.</p><p>The coefficients of the kernel defined in \\eqref{eq.kernel} are \\[ k_n = \\gamma\\frac{1+k_n\'}{h_n\'}, \\]where $\\gamma$ is the normal gravity defined in \\eqref{normalgravity}, $h_n\'$ and $k_n\'$ are the load Love numbers and the load deformation Love numbers.  <h2>RadialGradient</h2><p> This kernel defines the second radial derivative of the (disturbance) potential. \\[ T_{rr} = \\frac{\\partial^2 T}{\\partial r^2}. \\]The coefficients of the kernel defined in \\eqref{eq.kernel} are \\[ k_n = \\frac{r^2}{(n+1)(n+2)}. \\] <h2 id="coefficients">Coefficients</h2><p> The kernel is defined by the coefficients $k_n$ given by file.  <h2>FilterGauss</h2><p> Another <a class="groops-class" href="kernelType.html">kernel</a> is smoothed by a gauss filter which is defined by \\[ F(\\cos\\psi) = \\frac{b\\cdot e^{-b(1-\\cos\\psi)}}{1-e^{-2b}} \\]with $b = \\frac{ln(2)}{1-\\cos(r/R)}$ where $r$ is the given smoothing <strong class="groops-config-element">radius</strong> in km and $R=6378.1366$ km is the Earth radius. The coefficients $k_n$ of the <strong class="groops-config-element">kernel</strong> are multiplicated by \\[ f_n = \\frac{1}{2n+1} \\int_{-1}^1 F(t)\\cdot \\bar{P}_n(t)\\,dt. \\] <h2>BlackmanLowpass</h2><p> Another <a class="groops-class" href="kernelType.html">kernel</a> is smoothed by a Blackman low-pass filter. The filter is defined through the beginning and end of the transition from pass-band to stop-band. This transition band is specified by <strong class="groops-config-element">startDegreeTransition</strong> ($n_1$) and <strong class="groops-config-element">stopDegreeTransition</strong> ($n_2$).</p><p>The coefficients of this kernel are defined as \\[ \\begin{cases} 1 & \\text{for } n < n_1 \\\\ A_n^2 & \\text{for } n_1\\leq n \\leq n_2 \\\\ 0 & \\text{for } n > n_2 \\\\ \\end{cases} \\]with \\[ A_n = 0.42 + 0.5\\cos(\\pi \\frac{n-n_1}{n_2-n_1}) + 0.08 \\cos(2\\pi\\frac{n-n_1}{n_2-n_1}). \\] <h2>Truncation</h2><p> Another <a class="groops-class" href="kernelType.html">kernel</a> is truncated before <strong class="groops-config-element">minDegree</strong> and after <strong class="groops-config-element">maxDegree</strong>. The coefficients of this kernel are defined as \\[   k_n =   \\begin{cases}   1 & \\text{for } n_{\\text{minDegree}} \\leq n \\leq n_{\\text{maxDegree}}\\\\   0 & \\text{else.} \\\\   \\end{cases} \\] <h2>SelenoidHeight</h2><p> The selenoid height is defined by Bruns formula \\[ N = \\frac{1}{\\gamma}T \\]with $T$ the disturbance potential and the normal gravity $\\gamma=\\frac{GM}{R^2}$ of the moon.</p><p>The kernel is given by \\[ K(\\cos\\psi,r,R) = \\gamma\\frac{R(r^2-R^2)}{l^3}, \\]and the coefficients in \\eqref{eq.kernel} are \\[ k_n = \\gamma. \\]'},
'loopType': { 'name': 'loopType', 'key': 'loopType', 'description': 'Generates a sequence with variables to loop over. The variable names can be set with  variableLoop...  and the current values are assigned to the variables for each loop step. With     only a subset of loop steps are performed. The  variableLoopIndex  and  variableLoopCount  are not affected by the condition. The result would therefore be the same as using  LoopPrograms  with a nested  IfPrograms . See  Loop and conditions  for usage.     Loop over points in time.     Loop over the intervals between points in time.     Loop over list of strings.     Loop over rows of a table containing strings. The table can be defined  rowWise  or  columnWise . Each row/column must have the same number of cells.     Loop over list of strings from files.     Loop over rows of a table containing strings. Each row must have the same number of columns.     Loop over lines of a text file.     Loop over rows of a matrix. To define the loop variables the standard data variables of the matrix are available, see  dataVariables .     Loop over sequence of numbers.     Loop over files of a directory.     Loop over lines of command output.     Loop over nested loops. First  loop  is outermost loop, every subsequent  loop  is one level below the previous  loop .     Loop over specific equipment of a  platform file .     DEPRECATDED. Use LoopPlatformEquipment instead.', 'config_table': 'timeSeries timeSeriesType loop is called for every point in time variableLoopTime string variable with time of each loop variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step timeIntervals timeSeriesType loop is called for every interval variableLoopTimeStart string variable with starting time of each interval variableLoopTimeEnd string variable with ending time of each interval variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step string string explicit list of strings variableLoopString string name of the variable to be replaced variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step table choice define table by rows/columns rowWise sequence define table by rows row sequence define table by rows cell string explicit list of cells in row/column columnWise sequence define table by columns column sequence define table by columns cell string explicit list of cells in row/column variableLoopString string 1. variable name for the 1. column, next variable name for the 2. column, ...  variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step inputfile filename simple ASCII file with strings (separated by whitespace) sort boolean sort entries alphabetically (ascending) removeDuplicates boolean remove duplicate entries (order is preserved) startIndex uint start at element startIndex (counting from 0) count uint use count elements (default: use all) variableLoopString string name of the variable to be replaced variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step inputfile filename simple ASCII file with multiple columns (separated by whitespace) startLine uint start at line startLine (counting from 0) countLines uint read count lines (default: all) variableLoopString string 1. variable name for the 1. column, next variable name for the 2. column, ...  variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step inputfile filename simple ASCII file with lines sort boolean sort lines alphabetically (ascending) removeDuplicates boolean remove duplicate lines (order is preserved) startIndex uint start at element startIndex (counting from 0) count uint use number of lines only (default: use all) variableLoopLine string name of the variable to be replaced variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step inputfile filename  transpose boolean effectively loop over columns startRow expression start at this row (variable: rows) countRows expression use this many rows (variable: rows) variableLoop expression define a variable by name = expression (input columns are named data0, data1, ...) variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step rangeStart double start of range rangeEnd double end of range (inclusive) sampling double sampling variableLoopNumber string name of the variable to be replaced variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step directory filename directory pattern string wildcard pattern isRegularExpression boolean pattern is a regular expression variableLoopFile string name of the variable to be replaced variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step command filename each output line becomes a loop iteration silently boolean without showing the output. variableLoopString string name of the variable to be replaced variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step loop loopType subloop variableLoopIndex string variable with index of current iteration (starts with zero) condition conditionType check before each loop step inputfilePlatform filename platform info file equipmentType choice equipment type to loop over all  loop over all types gnssAntenna  loop over antennas gnssReceiver  loop over receivers other  loop over other types variableLoopName string variable with name variableLoopSerial string variable with serial variableLoopInfo string variable with radome (antenna) or version (receiver) variableLoopTimeStart string variable with start time variableLoopTimeEnd string variable with end time variableLoopPositionX string variable with position x variableLoopPositionY string variable with position y variableLoopPositionY string variable with position z variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step inputfileGnssStationInfo filename station/transmitter info file infoType choice info to loop over antenna  loop over antennas receiver  loop over receivers variableLoopName string variable with antenna/receiver name variableLoopSerial string variable with antenna/receiver serial variableLoopInfo string variable with radome (antenna) or version (receiver) variableLoopTimeStart string variable with antenna/receiver start time variableLoopTimeEnd string variable with antenna/receiver end time variableLoopIndex string variable with index of current iteration (starts with zero) variableLoopCount string variable with total number of iterations condition conditionType check before each loop step', 'display_text': 'Generates a sequence with variables to loop over. The variable names can be set with <strong class="groops-config-element">variableLoop...</strong> and the current values are assigned to the variables for each loop step.</p><p>With <a class="groops-class" href="conditionType.html">condition</a> only a subset of loop steps are performed. The <strong class="groops-config-element">variableLoopIndex</strong> and <strong class="groops-config-element">variableLoopCount</strong> are not affected by the condition. The result would therefore be the same as using <a class="groops-program" href="LoopPrograms.html">LoopPrograms</a> with a nested <a class="groops-program" href="IfPrograms.html">IfPrograms</a>.</p><p>See <a class="groops-ref" href="general.loopsAndConditions.html">Loop and conditions</a> for usage.  <h2>TimeSeries</h2><p> Loop over points in time.  <h2>TimeIntervals</h2><p> Loop over the intervals between points in time.  <h2 id="manualList">ManualList</h2><p> Loop over list of strings.  <h2>ManualTable</h2><p> Loop over rows of a table containing strings. The table can be defined <strong class="groops-config-element">rowWise</strong> or <strong class="groops-config-element">columnWise</strong>. Each row/column must have the same number of cells.  <h2>FileAscii</h2><p> Loop over list of strings from files.  <h2>FileAsciiTable</h2><p> Loop over rows of a table containing strings. Each row must have the same number of columns.  <h2>FileLines</h2><p> Loop over lines of a text file.  <h2>Matrix</h2><p> Loop over rows of a matrix. To define the loop variables the standard data variables of the matrix are available, see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.  <h2>UniformSampling</h2><p> Loop over sequence of numbers.  <h2 id="directoryListing">DirectoryListing</h2><p> Loop over files of a directory.  <h2 id="commandOutput">CommandOutput</h2><p> Loop over lines of command output.  <h2>Loop</h2><p> Loop over nested loops. First <strong class="groops-config-element">loop</strong> is outermost loop, every subsequent <strong class="groops-config-element">loop</strong> is one level below the previous <strong class="groops-config-element">loop</strong>.  <h2>PlatformEquipment</h2><p> Loop over specific equipment of a <a class="groops-file" href="fileFormat_platform.html">platform file</a>.  <h2>FileGnssStationInfo</h2><p> DEPRECATDED. Use LoopPlatformEquipment instead.'},
'magnetosphereType': { 'name': 'magnetosphereType', 'key': 'magnetosphereType', 'description': 'This class provides functions of the magnetic field of the Earth.     International Geomagnetic Reference Field.', 'config_table': 'inputfileMagneticNorthPole filename time series of north pole', 'display_text': 'This class provides functions of the magnetic field of the Earth.  <h2>IGRF</h2><p> International Geomagnetic Reference Field.'},
'matrixGeneratorType': { 'name': 'matrixGeneratorType', 'key': 'matrixGeneratorType', 'description': 'This class provides a matrix used e.g. by  MatrixCalculate . If multiple matrices are given the resulting matrix is the sum all and the size is exandeded to fit all matrices. Before the computation of each submatrix the variables  rowsBefore  and  columnsBefore  with current size of the overall matrix are set. As all matrices can be manipulated before, complex matrix operations are possible.     Matrix from  file .     Matrix from a  normal equation file . The symmetric normal matrix, the right hand side vector, the lPl vector, or the observation count   can be selected.     Matrix filled by an expression. For each element of the new matrix the variables  row  and  column  are set and the expression  element  is evaluated. Excample: The  element = if(row==column,1,0)  generates an identity matrix.     The elements of a matrix are replaced an expression. For each element of the matrix the variables  data ,  row ,  column  are set and the expression  element  is evaluated and replaces the element. Additionally the standard data variables are available (assigned each row), see  dataVariables .     Given two matrices   and   this class computes  , where   is an expression (for example  data0*data1 ). For each element of the matrix the variables  data0 ,  data1 ,  row ,  column  are set and the expression  element  is evaluated.     Append matrix to the right (first row) or bottom (first column).     Shift start row and start column of a matrix. In other words: zero lines and columns are inserted at the beginning of the matrix.     Slice of a matrix.     Matrix reshaped columnwise to new row and columns.     Reorder rows or columns of a matrix by an index vectors. The index vector can be created with  ParameterSelection2IndexVector .     Sort matrix by  column  in ascending order by default or in  descending  order.     Transposed of a matrix  .     Multiplication of matrices.     Inverse of a matrix  .     Upper triangular natrix of the cholesky decomposition of a symmetric matrix  .     Symmetric matrix from rank k update:  .     Computes the eigenvalues of a square matrix and gives a vector of eigenvalues for symmetric matrices or a matrix with 2 columns with real and imaginary parts in general case.     Extract the diagonal or subdiagnoal (  vector) of a matrix. The zero  diagonal  means the main diagonal, a positive value the superdiagonal, and a negative the subdiagonal.     Generate a matrix from a diagonal vector.     Set type (matrix, matrixSymmetricUpper, matrixSymmetricLower, matrixTriangularUpper, matrixTriangularLower) of a matrix. If the type is not matrix, the matrix must be quadratic. Symmetric matrices are filled symmetric and for triangular matrix the other triangle is set to zero.', 'config_table': 'inputfileMatrix filename  factor double  inputfileNormalEquation filename  type choice  normalMatrix   rightHandSide   lPl   observationCount   factor double  rows expression (variables: rowsBefore, columnsBefore) columns expression (variables: rowsBefore, columnsBefore) element expression for each element of matrix (variables: row, column, rows, columns, rowsBefore, columnsBefore) matrix matrixGeneratorType  element expression for each element of matrix (variables: data, row, column, rows, columns, rowsBefore, columnsBefore) matrix1 matrixGeneratorType  matrix2 matrixGeneratorType  expression expression for each element of matrix (variables: data0, data1, row, column, rows, columns, rowsBefore, columnsBefore) matrix matrixGeneratorType  side choice  right   bottom   diagonal   matrix matrixGeneratorType  startRow expression start row (variables: rowsBefore, columnsBefore, rows, columns) startColumn expression start column (variables: rowsBefore, columnsBefore, rows, columns) matrix matrixGeneratorType  startRow expression start row of matrix (variables: rowsBefore, columnsBefore, rows, columns) startColumn expression start column of matrix (variables: rowsBefore, columnsBefore, rows, columns) rows expression 0: until end (variables: rowsBefore, columnsBefore, rows, columns) columns expression 0: until end (variables: rowsBefore, columnsBefore, rows, columns) matrix matrixGeneratorType  rows expression 0: auto-determine rows, (variables: rowsBefore, columnsBefore) columns expression 0: auto-determine columns (variables: rowsBefore, columnsBefore) matrix matrixGeneratorType  inputfileIndexVectorRow filename index in input matrix or -1 for new parameter. inputfileIndexVectorColumn filename index in input matrix or -1 for new parameter. matrix matrixGeneratorType  column uint sort by column, top = highest priority descending boolean  matrix matrixGeneratorType  matrix1 matrixGeneratorType  matrix2 matrixGeneratorType  factor double  matrix matrixGeneratorType  pseudoInverse boolean compute pseudo inverse instead of regular one matrix matrixGeneratorType  matrix matrixGeneratorType  factor double  matrix matrixGeneratorType  eigenVectors boolean return eigen vectors instead of eigen values matrix matrixGeneratorType  diagonal int zero: main diagonal, positive: superdiagonal, negative: subdiagonal matrix matrixGeneratorType (nx1) or (1xn) diagonal vector diagonal int zero: main diagonal, positive: superdiagonal, negative: subdiagonal matrix matrixGeneratorType  type choice  matrix   matrixSymmetricUpper   matrixSymmetricLower   matrixTriangularUpper   matrixTriangularLower', 'display_text': 'This class provides a matrix used e.g. by <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a>. If multiple matrices are given the resulting matrix is the sum all and the size is exandeded to fit all matrices. Before the computation of each submatrix the variables <code>rowsBefore</code> and <code>columnsBefore</code> with current size of the overall matrix are set. As all matrices can be manipulated before, complex matrix operations are possible.  <h2>File</h2><p> Matrix from <a class="groops-file" href="fileFormat_matrix.html">file</a>.  <h2>Normals file</h2><p> Matrix from a <a class="groops-file" href="fileFormat_normalEquation.html">normal equation file</a>. The symmetric normal matrix, the right hand side vector, the lPl vector, or the observation count $(1\\times1)$ can be selected.  <h2>Expression</h2><p> Matrix filled by an expression. For each element of the new matrix the variables <code>row</code> and <code>column</code> are set and the expression <strong class="groops-config-element">element</strong> is evaluated.</p><p>Excample: The <strong class="groops-config-element">element</strong>=<code>if(row==column,1,0)</code> generates an identity matrix.  <h2>Element manipulation</h2><p> The elements of a matrix are replaced an expression. For each element of the matrix the variables <code>data</code>, <code>row</code>, <code>column</code> are set and the expression <strong class="groops-config-element">element</strong> is evaluated and replaces the element. Additionally the standard data variables are available (assigned each row), see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.  <h2>ElementWiseOperation</h2><p> Given two matrices $\\mathbf{A}$ and $\\mathbf{B}$ this class computes $c_{ij} = f(a_{ij}, b_{ij})$, where $f$ is an expression (for example <code>data0*data1</code>). For each element of the matrix the variables <code>data0</code>, <code>data1</code>, <code>row</code>, <code>column</code> are set and the expression <strong class="groops-config-element">element</strong> is evaluated.  <h2>Append</h2><p> Append matrix to the right (first row) or bottom (first column).  <h2>Shift</h2><p> Shift start row and start column of a matrix. In other words: zero lines and columns are inserted at the beginning of the matrix.  <h2>Slice</h2><p> Slice of a matrix.  <h2>Reshape</h2><p> Matrix reshaped columnwise to new row and columns.  <h2 id="reorder">Reorder</h2><p> Reorder rows or columns of a matrix by an index vectors. The index vector can be created with <a class="groops-program" href="ParameterSelection2IndexVector.html">ParameterSelection2IndexVector</a>.  <h2>Sort</h2><p> Sort matrix by <strong class="groops-config-element">column</strong> in ascending order by default or in <strong class="groops-config-element">descending</strong> order.  <h2>Transpose</h2><p> Transposed of a matrix $\\M A^T$.  <h2>Multiplication</h2><p> Multiplication of matrices.  <h2>Inverse</h2><p> Inverse of a matrix $\\M A^{-1}$.  <h2>Cholesky</h2><p> Upper triangular natrix of the cholesky decomposition of a symmetric matrix $\\M A=\\M W^T\\M W$.  <h2>RankKUpdate</h2><p> Symmetric matrix from rank k update: $\\M A^T\\M A$.  <h2>EigenValues</h2><p> Computes the eigenvalues of a square matrix and gives a vector of eigenvalues for symmetric matrices or a matrix with 2 columns with real and imaginary parts in general case.  <h2>Diagonal</h2><p> Extract the diagonal or subdiagnoal ($n\\times 1$ vector) of a matrix. The zero <strong class="groops-config-element">diagonal</strong> means the main diagonal, a positive value the superdiagonal, and a negative the subdiagonal.  <h2>FromDiagonal</h2><p> Generate a matrix from a diagonal vector.  <h2>Set type</h2><p> Set type (matrix, matrixSymmetricUpper, matrixSymmetricLower, matrixTriangularUpper, matrixTriangularLower) of a matrix. If the type is not matrix, the matrix must be quadratic. Symmetric matrices are filled symmetric and for triangular matrix the other triangle is set to zero.'},
'miscAccelerationsType': { 'name': 'miscAccelerationsType', 'key': 'miscAccelerationsType', 'description': 'This class gives the non conservative forces acting on satellites.     The relativistic effect to the acceleration of an artificial Earth satellite according to IERS2010 conventions. The macro model and the attitude of the satellite is not needed.     This class computes acceleration acting on a satellite caused by Solar and Earth radiation pressure and thermal radiation. Solar radiation pressure: The solar constant at 1 AU can be set via  solarFlux . The  factorSolarRadation  can be used to scale the computed acceleration of the direct solar radiation. Earth radiation pressure: Input are a time series of gridded albedo values (unitless) as     and a time series of gridded longwave flux (W/m ) as    . Both files are optional and if not specified, the respective effect on the acceleration is not computed. The  factorEarthRadation  can be used to scale the computed acceleration of the earth radiation. The thermal radiation (TRP) of the satellite itself is either computed as direct re-emission or based on the actual temperature of the satellite surfaces, depending on the seetings of the  satellite macro model . The second one uses a transient temperature model with a temporal differential equation which disallows parallel computing. The  factorThermalRadiation  can be used to scale the computed acceleration of the TRP. The algorithms are described in: Woeske et. al. (2019), GRACE accelerometer calibration by high precision non-gravitational force modeling, Advances in Space Research,  https://doi.org/10.1016/j.asr.2018.10.025 .     Atmospheric drag model. Algorithm for the atmospheric drag modelling is based on the free molecule flow theory by Sentman 1961. An analytical expression of this treatise is given in Moe and Moe 2005. Sentman L. (1961), Free molecule flow theory and its application to the determination of aerodynamic forces, Technical report. Moe K., Moe M. M. (2005), Gas-surface interactions and satellite drag coefficients, Planetary and Space Science 53(8), 793-801, doi:10.1016/j.pss.2005.03.005. Optional determination steps: Turn temperature on or off. In the first case, the model mentioned above is applied, which estimates variable drag and lift coefficients - in the latter case a constant drag coefficient can be specified. Turn wind on/off: It enables the usage of the Horizontal Wind Model 2014 to add additional thermospheric winds in the calculation process.     Atmospheric drag computed from thermospheric density along the orbit (   , MISCVALUE). The     is used to to compute temperature and wind. For further details see    .     The thrust (acceleration) in the opposite direction the antenna is facing which is generated by satellite antenna broadcasts. The thrust is defined in the satellite macro model.     Reads a solution vector from file     which may be computed by a least squares adjustment (e.g. by  NormalsSolverVCE ). The coefficients of the vector are interpreted from position  indexStart  (counting from zero) with help of    . If the solution file contains solution of several right hand sides you can choose one with number  rightSide  (counting from zero). The computed result is multiplied with  factor .     Groups a set of     and has no further effect itself.     DEPRECATED. Use radiationPressure instead.     DEPRECATED. Use radiationPressure instead.', 'config_table': 'beta double PPN (parameterized post-Newtonian) parameter gamma double PPN (parameterized post-Newtonian) parameter J double Earths angular momentum per unit mass [m**2/s] GM double Geocentric gravitational constant factor double the result is multiplied by this factor solarflux double solar flux constant in 1 AU [W/m^2] eclipse eclipseType  inputfileAlbedoTimeSeries filename GriddedDataTimeSeries of albedo values (unitless) inputfileLongwaveFluxTimeSeries filename GriddedDataTimeSeries of longwave flux values [W/m^2] factorSolarRadation double Solar radiation pressure is multiplied by this factor factorEarthRadation double Earth radiation preussure is multiplied by this factor factorThermalRadiation double Thermal (re-)radiation is multiplied by this factor thermosphere thermosphereType  earthRotation double [rad/s] considerTemperature boolean compute drag and lift, otherwise simple drag coefficient is used considerWind boolean  factor double the result is multiplied by this factor inputfileDensity filename density along orbit, MISCVALUE (kg/m^3) thermosphere thermosphereType used to compute temperature and wind earthRotation double [rad/s] considerTemperature boolean compute drag and lift, otherwise simple drag coefficient is used considerWind boolean  factor double the result is multiplied by this factor factor double the result is multiplied by this factor parametrization parametrizationAccelerationType  inputfileSolution filename solution vector indexStart uint position in the solution vector rightSide uint if solution contains several right hand sides, select one factor double the result is multiplied by this factor, set -1 to subtract the field miscAccelerations miscAccelerationsType  factor double the result is multiplied by this factor solarflux double solar flux constant in 1 AU [W/m**2] eclipse eclipseType  factor double the result is multiplied by this factor, set -1 to subtract the field inputfileReflectivity filename  inputfileEmissivity filename  solarflux double solar flux constant in 1 AU [W/m**2] factor double the result is multiplied by this factor, set -1 to subtract the field', 'display_text': 'This class gives the non conservative forces acting on satellites.  <h2 id="relativisticEffect">Relativistic effect</h2><p> The relativistic effect to the acceleration of an artificial Earth satellite according to IERS2010 conventions.</p><p>The macro model and the attitude of the satellite is not needed.  <h2 id="RadiationPressure">RadiationPressure</h2><p> This class computes acceleration acting on a satellite caused by Solar and Earth radiation pressure and thermal radiation.</p><p>Solar radiation pressure: The solar constant at 1 AU can be set via <strong class="groops-config-element">solarFlux</strong>. The <strong class="groops-config-element">factorSolarRadation</strong> can be used to scale the computed acceleration of the direct solar radiation.</p><p>Earth radiation pressure: Input are a time series of gridded albedo values (unitless) as <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">inputfileAlbedoTimeSeries</a> and a time series of gridded longwave flux (W/m$^2$) as <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">inputfileLongwaveFluxTimeSeries</a>. Both files are optional and if not specified, the respective effect on the acceleration is not computed. The <strong class="groops-config-element">factorEarthRadation</strong> can be used to scale the computed acceleration of the earth radiation.</p><p>The thermal radiation (TRP) of the satellite itself is either computed as direct re-emission or based on the actual temperature of the satellite surfaces, depending on the seetings of the <a class="groops-file" href="fileFormat_satelliteModel.html">satellite macro model</a>. The second one uses a transient temperature model with a temporal differential equation which disallows parallel computing. The <strong class="groops-config-element">factorThermalRadiation</strong> can be used to scale the computed acceleration of the TRP.</p><p>The algorithms are described in:</p><p>Woeske et. al. (2019), GRACE accelerometer calibration by high precision non-gravitational force modeling, Advances in Space Research, <a href="https://doi.org/10.1016/j.asr.2018.10.025" target="_blank">https://doi.org/10.1016/j.asr.2018.10.025</a>.  <h2 id="atmosphericDrag">AtmosphericDrag</h2><p> Atmospheric drag model. Algorithm for the atmospheric drag modelling is based on the free molecule flow theory by Sentman 1961. An analytical expression of this treatise is given in Moe and Moe 2005.</p><p>Sentman L. (1961), Free molecule flow theory and its application to the determination of aerodynamic forces, Technical report.</p><p>Moe K., Moe M. M. (2005), Gas-surface interactions and satellite drag coefficients, Planetary and Space Science 53(8), 793-801, doi:10.1016/j.pss.2005.03.005.</p><p>Optional determination steps: Turn temperature on or off. In the first case, the model mentioned above is applied, which estimates variable drag and lift coefficients - in the latter case a constant drag coefficient can be specified.</p><p>Turn wind on/off: It enables the usage of the Horizontal Wind Model 2014 to add additional thermospheric winds in the calculation process.  <h2 id="atmosphericDragFromDensityFile">AtmosphericDragFromDensityFile</h2><p> Atmospheric drag computed from thermospheric density along the orbit (<a class="groops-class" href="fileFormat_instrument.html">inputfileDensity</a>, MISCVALUE). The <a class="groops-class" href="thermosphereType.html">thermosphere</a> is used to to compute temperature and wind. For further details see <a class="groops-class" href="miscAccelerationsType.html#atmosphericDrag">atmosphericDrag</a>.  <h2 id="antennaThrust">Antenna thrust</h2><p> The thrust (acceleration) in the opposite direction the antenna is facing which is generated by satellite antenna broadcasts. The thrust is defined in the satellite macro model.  <h2 id="fromParametrization">FromParametrization</h2><p> Reads a solution vector from file <a class="groops-class" href="fileFormat_matrix.html">inputfileSolution</a> which may be computed by a least squares adjustment (e.g. by <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>). The coefficients of the vector are interpreted from position <strong class="groops-config-element">indexStart</strong> (counting from zero) with help of <a class="groops-class" href="parametrizationAccelerationType.html">parametrization</a>. If the solution file contains solution of several right hand sides you can choose one with number <strong class="groops-config-element">rightSide</strong> (counting from zero).</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="group">Group</h2><p> Groups a set of <a class="groops-class" href="miscAccelerationsType.html">miscAccelerations</a> and has no further effect itself.  <h2 id="solarRadiationPressure">SolarRadiationPressure</h2><p> DEPRECATED. Use radiationPressure instead.  <h2 id="albedo">Albedo</h2><p> DEPRECATED. Use radiationPressure instead.'},
'noiseGeneratorType': { 'name': 'noiseGeneratorType', 'key': 'noiseGeneratorType', 'description': 'This class implements the generation of different types of noise. It provides a generic interface that can be implemented by different types of generators. The characteristics of the generated noise is determined by the generators. See the appropriate documentation for more information.     The noise is Gaussian with a standard deviation  sigma . The noise is computed via a pseudo random sequence with a start value given by  initRandom . The same value always yields the same sequence. Be careful in  parallel  mode as all nodes generates the same pseudo random sequence. If this value is set to zero a real random value is used as starting value.     This generator creates noise defined by a one sided PSD. The  psd  is an expression controlled by the variable \'freq\'. To determine the frequency  sampling  must be given.     Generated noise     is filtered by a    .     This generator creates noise that conforms to a power law relationship, where the power of the noise at a frequency is proportional to  , with a typically between -2 and 2.', 'config_table': 'sigma double standard deviation initRandom uint start value for pseudo random sequence, 0: real random noise noiseGeneratorType Basis noise psd expression one sided PSD (variable: freq [Hz]) [unit^2/Hz] sampling double to determine frequency [seconds] filter digitalFilterType digital filter noise noiseGeneratorType Basis noise warmupEpochCount uint number of additional epochs at before start and after end overSamplingFactor uint noise with multiple higher sampling -> filter -> decimate noise noiseGeneratorType Basis noise alpha double Exponent of the power law relationship 1/f^alpha', 'display_text': 'This class implements the generation of different types of noise. It provides a generic interface that can be implemented by different types of generators. The characteristics of the generated noise is determined by the generators. See the appropriate documentation for more information.  <h2>White</h2><p> The noise is Gaussian with a standard deviation <strong class="groops-config-element">sigma</strong>. The noise is computed via a pseudo random sequence with a start value given by <strong class="groops-config-element">initRandom</strong>. The same value always yields the same sequence. Be careful in <a class="groops-ref" href="general.parallelization.html">parallel</a> mode as all nodes generates the same pseudo random sequence. If this value is set to zero a real random value is used as starting value.  <h2>ExpressionPSD</h2><p> This generator creates noise defined by a one sided PSD. The <strong class="groops-config-element">psd</strong> is an expression controlled by the variable \'freq\'. To determine the frequency <strong class="groops-config-element">sampling</strong> must be given.  <h2>Filter</h2><p> Generated noise <a class="groops-class" href="noiseGeneratorType.html">noise</a> is filtered by a <a class="groops-class" href="digitalFilterType.html">filter</a>.  <h2>PowerLaw</h2><p> This generator creates noise that conforms to a power law relationship, where the power of the noise at a frequency is proportional to $1/f^\\alpha$, with a typically between -2 and 2.'},
'normalEquationType': { 'name': 'normalEquationType', 'key': 'normalEquationType', 'description': 'This class provides a system of normal equations. This total system is the weighted sum of individual normals.  The normals do not need to have the same dimension. The dimension of the total combined system is chosen to cover all individual systems. For each normal a  startIndex  is required which indicates the position of the first unknown of the individual normal within the combined parameter vector. The   of the relative weights are defined by  aprioriSigma  in a first step. If an apriori solution     is given or the normals are solved iteratively the weights are determined by means of variance compoment estimation (VCE), see  NormalsSolverVCE :  where   is the number of observations. The square sum of the residuals is calculated by  The system of normal equations can be solved with several right hand sides at once. But only one right hand side, which can be selected with the index  rightHandSide  (counting from zero), can be used to compute the variance factors. The combined normal   and the solution   are taken from the previous iteration step. In case of     the algorithm is a little bit different as described below.     This class acculumates normal equations from observation equations. The class     computes the linearized and decorrelated equation system for each arc  :  The arc depending parameters   are eliminated and the system of normal equations is acculumated according to      This class acculumates normal equations from observation equations. The class     computes the linearized and decorrelated equation system for each arc  :  The arc depending parameters   are eliminated and the system of normal equations is acculumated according to  The variance   of each individual arc is determined by  where   is the number of observations. If an apriori solution is not given at the first iteration step a zero vector is assumed.     Reads a system of normal equations from file     as generated by e.g.  NormalsBuild .     Set up a system of normal equations  where   is a diagonal matrix whose elements are given as a vector by     and   is the right hand side towards which will be regularized. It can be given by    . The diagonal matrix can be generated with  NormalsRegularizationBorders ,  NormalsRegularizationSphericalHarmonics , or  MatrixCalculate . If   is not given a unit matrix is assumed. The right hand side   may be generated with  Gravityfield2SphericalHarmonicsVector . If   is not given a zero vector is assumed.    Generalized regularization which is represented by the observation equation   There are no requirements for partial covariance matrices   except for them being symmetric. The accumulated covariance matrix   must be positive definite however. The variance components   are estimated during the adjustment process and are assumed to be positive. All     must be of same size and must match the dimension of     (if provided, otherwise a zero vector of appropriate dimensions is created). The parameter  aprioriSigma  determines the initial variance factor for the partial covariance matrices. Either one   can be supplied or one for each  . The regularization matrix can be applied to a subset of parameters by adjusting  startIndex .', 'config_table': 'observation observationType  aprioriSigma double  startIndex uint add this normals at index of total matrix (counting from 0) inputfileArcList filename to accelerate computation observation observationType  startIndex uint add this normals at index of total matrix (counting from 0) inputfileArcList filename to accelerate computation inputfileNormalEquation filename  aprioriSigma double  startIndex uint add this normals at index of total matrix (counting from 0) inputfileDiagonalMatrix filename Vector with the diagonal elements of the weight matrix inputfileBias filename Matrix with right hand sides aprioriSigma double  startIndex uint regularization of parameters starts at this index (counting from 0) inputfilePartialCovarianceMatrix filename symmetric matrix (sum of all matrices must be positive definite) inputfileBiasMatrix filename bias vector (default: zero vector) aprioriSigma double apriori sigmas for initial iteration (default: 1.0) startIndex uint regularization of parameters starts at this index (counting from 0)', 'display_text': 'This class provides a system of normal equations. This total system is the weighted sum of individual normals. \\[  \\M N_{total} =  \\sum_{k=1} \\frac{1}{\\sigma_k^2}\\M N_k  \\qquad\\text{and}\\qquad \\M n_{total} = \\sum_{k=1} \\frac{1}{\\sigma_k^2} \\M n_k. \\]The normals do not need to have the same dimension. The dimension of the total combined system is chosen to cover all individual systems. For each normal a <strong class="groops-config-element">startIndex</strong> is required which indicates the position of the first unknown of the individual normal within the combined parameter vector.</p><p>The $\\sigma_k$ of the relative weights are defined by <strong class="groops-config-element">aprioriSigma</strong> in a first step. If an apriori solution <a class="groops-class" href="fileFormat_matrix.html">inputfileApproxSolution</a> is given or the normals are solved iteratively the weights are determined by means of variance compoment estimation (VCE), see <a class="groops-program" href="NormalsSolverVCE.html">NormalsSolverVCE</a>: \\[ \\sigma_k^2 = \\frac{\\M e_k^T\\M P\\M e_k} {n_k-\\frac{1}{\\sigma_k^2}\\text{trace}\\left(\\M N_k\\M N_{total}^{-1}\\right)}, \\]where $n_k$ is the number of observations. The square sum of the residuals is calculated by \\[ \\M e_k^T\\M P\\M e_k = \\M x^T\\M N_k\\M x - 2\\M n_k^T\\M x + \\M l_k^T\\M P_k\\M l_k. \\]The system of normal equations can be solved with several right hand sides at once. But only one right hand side, which can be selected with the index <strong class="groops-config-element">rightHandSide</strong> (counting from zero), can be used to compute the variance factors. The combined normal $\\M N_{total}$ and the solution $\\M x$ are taken from the previous iteration step. In case of <a class="groops-class" href="normalEquationType.html#designVCE">DesignVCE</a> the algorithm is a little bit different as described below.  <h2 id="design">Design</h2><p> This class acculumates normal equations from observation equations. The class <a class="groops-class" href="observationType.html">observation</a> computes the linearized and decorrelated equation system for each arc $i$: \\[ \\M l_i  = \\M A_i \\M x + \\M B_i \\M y_i + \\M e_i. \\]The arc depending parameters $\\M y_i$ are eliminated and the system of normal equations is acculumated according to \\[  \\M N = \\sum_{i=1}^m \\M A_i^T  \\M A_i  \\qquad\\text{and}\\qquad \\M n = \\sum_{i=1}^m \\M A_i^T \\M l_i. \\] <h2 id="designVCE">DesignVCE</h2><p> This class acculumates normal equations from observation equations. The class <a class="groops-class" href="observationType.html">observation</a> computes the linearized and decorrelated equation system for each arc $i$: \\[ \\M l_i  = \\M A_i \\M x + \\M B_i \\M y_i + \\M e_i. \\]The arc depending parameters $\\M y_i$ are eliminated and the system of normal equations is acculumated according to \\[  \\M N =  \\sum_{i=1} \\frac{1}{\\sigma_i^2}\\M A_i^T  \\M A_i  \\qquad\\text{and}\\qquad \\M n = \\sum_{i=1} \\frac{1}{\\sigma_i^2} \\M A_i^T \\M l_i. \\]The variance $\\sigma_i^2$ of each individual arc is determined by \\[ \\sigma_i^2 = \\frac{(\\M l_i-\\M A_i\\M x)^T(\\M l_i-\\M A_i\\M x)} {n_i-\\frac{1}{\\sigma_i^2}\\text{trace}\\left(\\M A_i^T  \\M A_i\\M N_{total}^{-1}\\right)}, \\]where $n_i$ is the number of observations. If an apriori solution is not given at the first iteration step a zero vector is assumed.  <h2 id="file">File</h2><p> Reads a system of normal equations from file <a class="groops-class" href="fileFormat_normalEquation.html">inputfileNormalEquation</a> as generated by e.g. <a class="groops-program" href="NormalsBuild.html">NormalsBuild</a>.  <h2 id="regularization">Regularization</h2><p> Set up a system of normal equations \\[ \\M N = \\M R \\qquad\\text{and}\\qquad \\M n = \\M R \\M b, \\]where $\\M R$ is a diagonal matrix whose elements are given as a vector by <a class="groops-class" href="fileFormat_matrix.html">inputfileDiagonalMatrix</a> and $\\M b$ is the right hand side towards which will be regularized. It can be given by <a class="groops-class" href="fileFormat_matrix.html">inputfileBiasVector</a>. The diagonal matrix can be generated with <a class="groops-program" href="NormalsRegularizationBorders.html">NormalsRegularizationBorders</a>, <a class="groops-program" href="NormalsRegularizationSphericalHarmonics.html">NormalsRegularizationSphericalHarmonics</a>, or <a class="groops-program" href="MatrixCalculate.html">MatrixCalculate</a>. If $\\M R$ is not given a unit matrix is assumed. The right hand side $\\M b$ may be generated with <a class="groops-program" href="Gravityfield2SphericalHarmonicsVector.html">Gravityfield2SphericalHarmonicsVector</a>. If $\\M b$ is not given a zero vector is assumed.  <h2>RegularizationGeneralized</h2><p></p><p>Generalized regularization which is represented by the observation equation \\[ \\mathbf{x}_0 = \\mathbf{I} \\mathbf{x} + \\mathbf{v}, \\mathbf{v} \\sim \\mathcal{N}(0, \\sum_k \\sigma^2_k \\mathbf{V}_k). \\] There are no requirements for partial covariance matrices $\\mathbf{V}_k$ except for them being symmetric. The accumulated covariance matrix $\\sum_k \\sigma^2_k \\mathbf{V}_k$ must be positive definite however. The variance components $\\sigma^2_k$ are estimated during the adjustment process and are assumed to be positive. All <a class="groops-class" href="fileFormat_matrix.html">inputfilePartialCovarianceMatrix</a> must be of same size and must match the dimension of <a class="groops-class" href="fileFormat_matrix.html">inputfileBiasMatrix</a> (if provided, otherwise a zero vector of appropriate dimensions is created).</p><p>The parameter <strong class="groops-config-element">aprioriSigma</strong> determines the initial variance factor for the partial covariance matrices. Either one $\\sigma_0$ can be supplied or one for each $\\mathbf{V}_k$.</p><p>The regularization matrix can be applied to a subset of parameters by adjusting <strong class="groops-config-element">startIndex</strong>.'},
'observationType': { 'name': 'observationType', 'key': 'observationType', 'description': 'This class set up the oberservation equations in linearized Gauss-Makoff model  The observations are divided into short data blocks which can computed independently and so easily can be parallelized. Usually this data blocks are short arcs of a satellites orbit. In most cases the unknown parameter vector contains coefficients of a gravity field parametrization given by    . Additional parameters like instrument calibrations parameters are appended at the end of the vector  . It is possible to give several observation vectors in one model. The observations within each arc are decorrelated in the following way: In a first step a cholesky decomposition of the covariance matrix is performed  where   is an upper regular triangular matrix. In a second step the transformation  gives an estimation from decorrelated observations with equal variance  Usually the arc depending parameters are eliminated in the next step and not mentioned for the parameter names in the following.     The observation equations for precise orbit data (POD) are formulated as variational equations. It is based on  inputfileVariational  calculated with  PreprocessingVariationalEquation . Necessary integrations are performed by integrating a moving interpolation polynomial of degree  integrationDegree . The kinematic positions as pseudo observations are taken from  rightHandSide  and should not given equally spaced in time. The observation equations are interpolated to these times by a moving polynomial of degree  interpolationDegree . The accuracy or the full covariance matrix of the precise orbit data is provided in     and can be estimated with  PreprocessingPod . accelerateComputation : In the event that the sampling of the kinematic orbit is much higher than the sampling of the variational equations (e.g. 1 second vs. 5 seconds) the accumulation of the observation equations can be accelerated by transforming the observation equations  where   describes the interpolation of the sampling of the variational design matrix   to the sampling of the observations   with more rows than columns. The QR decomposition  can be used to transform the observation equations  As the zero lines should not be considered the computational time for the accumulation is reduced. This option is not meaningful for evaluating the residuals such in  PreprocessingPod . The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  &lt;satellite>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite>:arc&lt;no>.&lt;parametrizationAcceleration>:*:* ,  &lt;satellite>:arc&lt;no>.position0.x:: ,  &lt;satellite>:arc&lt;no>.position0.y:: ,  &lt;satellite>:arc&lt;no>.position0.z:: .  &lt;satellite>:arc&lt;no>.velocity0.x:: ,  &lt;satellite>:arc&lt;no>.velocity0.y:: ,  &lt;satellite>:arc&lt;no>.velocity0.z:: .       The observation equations for precise orbit data (POD) of short arcs are given by  with the integral kernel  and the normalized time  The kinematic positions   as pseudo observations are taken from    . From these positions the influence of the reference forces   is subtracted which are computed with the background models in    . The integral is solved by the integration of a moving interpolation polynomial of degree  integrationDegree . The boundary values   and   (satellite\'s state vector) are estimated per arc and are usually directly eliminated if  keepSatelliteStates  is not set. The unknown gravity field   parametrized by     is not evaluated at the observed positions but at the orbit given by    . The same is true for the reference forces. The linearized effect of the gravity field change by the position adjustment is taken into account by  gradientfield . This may be a low order field up to a spherical harmonics degree of   or  . The    ,    , and     must be synchronous and must be given with a constant sampling and without any gaps in each short arc (see  InstrumentSynchronize ). The kinematic positions   should not given equally spaced in time but must be divided into the same arcs as the other instrument data. The observation equations are interpolated to this time by a polynomial interpolation with degree  interpolationDegree . The accuracy or the full covariance matrix of the precise orbit data is provided in     and can be estimated with  PreprocessingPod . For  accelerateComputation  see    . The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  &lt;satellite>:&lt;parametrizationAcceleration>:*:* ,   and for each arc if  keepSatelliteStates  is set    &lt;satellite>:arc&lt;no>.position.start.x:: ,  &lt;satellite>:arc&lt;no>.position.start.y:: ,  &lt;satellite>:arc&lt;no>.position.start.z:: .  &lt;satellite>:arc&lt;no>.position.end.x:: ,  &lt;satellite>:arc&lt;no>.position.end.y:: ,  &lt;satellite>:arc&lt;no>.position.end.z:: .       The observation equations for precise orbit data (POD) are given by  where the accelerations of the satellite   are derived from the kinematic positions in    . The orbit differentation is performed by a moving polynomial interpolation or approximation with degree  interpolationDegree  and number of used epochs  numberOfEpochs . The reference forces   are computed with the background models in    . All instrument data    ,    , and     must be synchronous and be given with a constant sampling without any gaps in each short arc (see  InstrumentSynchronize ). The unknown gravity field   parametrized by     is not evaluated at the observed positions but at the orbit given by    . The same is true for the reference forces. This orbit may be a more accurate dynamical orbit but in most cases the kinematic orbit provides good results. The accuracy or the full covariance matrix of the precise orbit data is provided in     and can be estimated with  PreprocessingPod . The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  &lt;satellite>:&lt;parametrizationAcceleration>:*:* .       The observation equations for precise orbit data (POD) are given by  where the velocities of the satellite   are derived from the kinematic positions in     and the Earth\'s rotation vector   is modeled within    . The orbit differentation is performed by a polynomial interpolation with degree  interpolationDegree . The integrals are solved a polynomial interpolation with degree  integrationDegree . The reference forces   are computed with the background models in    . All instrument data    ,    , and     must be synchronous and be given with a constant sampling without any gaps in each short arc (see  InstrumentSynchronize ). The unknown gravity potential   parametrized by     is not evaluated at the observed positions but at the orbit given by    . The same is true for the reference forces. This orbit may be a more accurate dynamical orbit but in most cases the kinematic orbit provides good results. An unknown energy bias   per arc is parametrized by     and should be a constant in theory but temporal changes might help to absorb other unmodelled effects. The accuracy or the full covariance matrix of the precise orbit data is provided in     and can be estimated with  PreprocessingPod . The following parameters with  parameter names  are set up:  *:&lt;parametrizationGravity>:*:* .     Like     (see there for details) but with two satellites and additional satellite-to-satellite (SST) observations. If multiple     are given all data are add together. So corrections in extra files like the light time correction can easily be added. Empirical parameters for the SST observations can be setup with    . The accuracy or the full covariance matrix of SST is provided in    . The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  &lt;satellite1>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite1>:arc&lt;no>.&lt;parametrizationAcceleration>:*:* ,  &lt;satellite1>:arc&lt;no>.position0.x:: ,  &lt;satellite1>:arc&lt;no>.position0.y:: ,  &lt;satellite1>:arc&lt;no>.position0.z:: .  &lt;satellite1>:arc&lt;no>.velocity0.x:: ,  &lt;satellite1>:arc&lt;no>.velocity0.y:: ,  &lt;satellite1>:arc&lt;no>.velocity0.z:: .  &lt;satellite2>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite2>:arc&lt;no>.&lt;parametrizationAcceleration>:*:* ,  &lt;satellite2>:arc&lt;no>.position0.x:: ,  &lt;satellite2>:arc&lt;no>.position0.y:: ,  &lt;satellite2>:arc&lt;no>.position0.z:: .  &lt;satellite2>:arc&lt;no>.velocity0.x:: ,  &lt;satellite2>:arc&lt;no>.velocity0.y:: ,  &lt;satellite2>:arc&lt;no>.velocity0.z:: .  &lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking>:*:* .       Like     (see there for details) but with two satellites and additional satellite-to-satellite (SST) observations. If multiple     are given all data are add together. So corrections in extra files like the light time correction can easily be added. Empirical parameters for the SST observations can be setup with    . The accuracy or the full covariance matrix of SST is provided in    . The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  &lt;satellite1>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite2>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking>:*:* ,   and for each arc if  keepSatelliteStates  is set    &lt;satellite1>:arc&lt;no>.position.start.x:: ,  &lt;satellite1>:arc&lt;no>.position.start.y:: ,  &lt;satellite1>:arc&lt;no>.position.start.z:: .  &lt;satellite1>:arc&lt;no>.position.end.x:: ,  &lt;satellite1>:arc&lt;no>.position.end.y:: ,  &lt;satellite1>:arc&lt;no>.position.end.z:: .  &lt;satellite2>:arc&lt;no>.position.start.x:: ,  &lt;satellite2>:arc&lt;no>.position.start.y:: ,  &lt;satellite2>:arc&lt;no>.position.start.z:: .  &lt;satellite2>:arc&lt;no>.position.end.x:: ,  &lt;satellite2>:arc&lt;no>.position.end.y:: ,  &lt;satellite2>:arc&lt;no>.position.end.z:: .       Like     (see there for details) but with two simultaneous satellite-to-satellite (SST) observations. This class reads two SST observation files (    and    ). Empirical parameters for the SST observations can be setup independently for both SST observation types with     and    . Both SST observation types are reduced by the same background models and the same impact of accelerometer measurements. The covariance matrix of the reduced observations should not consider the the instrument noise only (   ) but must take the cross correlations     into account. The covariance matrix of the reduced observations is given by   The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  &lt;satellite1>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite1>:arc&lt;no>.&lt;parametrizationAcceleration>:*:* ,  &lt;satellite1>:arc&lt;no>.position0.x:: ,  &lt;satellite1>:arc&lt;no>.position0.y:: ,  &lt;satellite1>:arc&lt;no>.position0.z:: .  &lt;satellite1>:arc&lt;no>.velocity0.x:: ,  &lt;satellite1>:arc&lt;no>.velocity0.y:: ,  &lt;satellite1>:arc&lt;no>.velocity0.z:: .  &lt;satellite2>:&lt;parametrizationAcceleration>:*:* ,  &lt;satellite2>:arc&lt;no>.&lt;parametrizationAcceleration>:*:* ,  &lt;satellite2>:arc&lt;no>.position0.x:: ,  &lt;satellite2>:arc&lt;no>.position0.y:: ,  &lt;satellite2>:arc&lt;no>.position0.z:: .  &lt;satellite2>:arc&lt;no>.velocity0.x:: ,  &lt;satellite2>:arc&lt;no>.velocity0.y:: ,  &lt;satellite2>:arc&lt;no>.velocity0.z:: .  &lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking1>:*:* .  &lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking2>:*:* .       Observation equations for satellite gravity gradiometry (SGG)  From the     observations precomputed     together with other background models are reduced, all given in    . All instrument data    ,    , and     must be synchronous and be diveded into each short arcs (see  InstrumentSynchronize ). Additional to the     an (temporal changing) bias for each gradiometer component and arc can be estimated with    . The accuracy or the full covariance matrix of the gradiometer is provided in  covarianceSgg  and can be estimated with  PreprocessingGradiometer . The following parameters with  parameter names  are set up:  *:&lt;parametrizationGravity>:*:* .     The gravity field is estimated from point wise measurements. The gravity field parametrization is given by    . There is no need to have the data regular distributed or given on a sphere or ellipsoid. The type of the gridded data (e.g gravity anomalies or geoid heights) must be set with    . A     can be reduced beforehand. The observations at given positions are calculated from    . The input columns are enumerated by  data0 ,  data1 ,  , see  dataVariables . The observations can be divided into small blocks for parallelization. With  blockingSize  set the maximum count of observations in each block. The following parameters with  parameter names  are set up:  *:&lt;parametrizationGravity>:*:* .     The gravity field parametrized by     is estimated from deflections of the vertical measurements. A     can be reduced beforehand. The observations   in north direction and   in east direction at given positions are calculated from    . The input columns are enumerated by  data0 ,  data1 ,  , see  dataVariables . The ellipsoid parameters  R  and  inverseFlattening  are used to define the local normal direction. The observations can be divided into small blocks for parallelization. With  blockingSize  set the maximum count of observations in each block. The following parameters with  parameter names  are set up:  *:&lt;parametrizationGravity>:*:* .     Observation equations for displacements of a list of stations due to the effect of time variable loading masses. The displacement   of a station is calculated according to  where   is the normal gravity, the load Love and Shida numbers   are given by     and the load Love numbers   are given by    . The   are the spherical harmonics expansion of degree   of the full time variable gravitational potential (potential of the loading mass + deformation potential) parametrized by    . Additional parameters can be setup to estimate the realization of the reference frame of the station coordinates ( estimateTranslation ,  estimateRotation , and  estimateScale ). The observations at stations coordinates are calculated from    . The input columns are enumerated by  data0 ,  data1 ,  , see  dataVariables . The ellipsoid parameters  R  and  inverseFlattening  are used to define the local frame (north, east, up). The following parameters with  parameter names  are set up:    *:&lt;parametrizationGravity>:*:* ,  *:translation.x:*:* ,  *:translation.y:*:* ,  *:translation.z:*:* ,  *:scale:*:* ,  *:rotation.x:*:* ,  *:rotation.y:*:* ,  *:rotation.z:*:* .  See also  Gravityfield2DisplacementTimeSeries . Reference: Rietbroek (2014): Retrieval of Sea Level and Surface Loading Variations from Geodetic Observations and Model Simulations: an Integrated Approach, Bonn, 2014. - Dissertation,  https://nbn-resolving.org/urn:nbn:de:hbz:5n-35460', 'config_table': 'rightHandSide sequence input for observation vectors inputfileOrbit filename kinematic positions as observations inputfileVariational filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration parametrizationAccelerationType orbit force parameters integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n accelerateComputation boolean acceleration of computation by transforming the observations covariancePod covariancePodType covariance matrix of kinematic orbits inputfileSatelliteModel filename satellite macro model rightHandSide podRightSideType input for the reduced observation vector inputfileOrbit filename used to evaluate the observation equations, not used as observations inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  gradientfield gravityfieldType low order field to estimate the change of the gravity by position adjustement parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration parametrizationAccelerationType orbit force parameters keepSatelliteStates boolean set boundary values of each arc global integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n accelerateComputation boolean acceleration of computation by transforming the observations covariancePod covariancePodType covariance matrix of kinematic orbits inputfileSatelliteModel filename satellite macro model rightHandSide podRightSideType input for the reduced observation vector inputfileOrbit filename used to evaluate the observation equations, not used as observations inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration parametrizationAccelerationType orbit force parameters interpolationDegree uint orbit differentation  by polynomial approximation of degree n numberOfEpochs uint number of used Epochs for polynom computation covariancePod covariancePodType covariance matrix of kinematic orbits inputfileSatelliteModel filename satellite macro model rightHandSide podRightSideType input for the reduced observation vector inputfileOrbit filename used to evaluate the observation equations, not used as observations inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization (potential) parametrizationBias parametrizationTemporalType unknown total energy per arc interpolationDegree uint orbit differentation  by polynomial approximation of degree n integrationDegree uint integration of forces by polynomial approximation of degree n covariancePod covariancePodType covariance matrix of kinematic orbits rightHandSide sequence input for observation vectors inputfileSatelliteTracking filename ranging observations and corrections inputfileOrbit1 filename kinematic positions of satellite A as observations inputfileOrbit2 filename kinematic positions of satellite B as observations sstType choice  range   rangeRate   none   inputfileVariational1 filename approximate position and integrated state matrix inputfileVariational2 filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst parametrizationSatelliteTrackingType satellite tracking parameter integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n covarianceSst covarianceSstType covariance matrix of satellite to satellite tracking observations covariancePod1 covariancePodType covariance matrix of kinematic orbits (satellite 1) covariancePod2 covariancePodType covariance matrix of kinematic orbits (satellite 2) inputfileSatelliteModel1 filename satellite macro model inputfileSatelliteModel2 filename satellite macro model rightHandSide sstRightSideType input for the reduced observation vector sstType choice  range   rangeRate   rangeAcceleration   none   inputfileOrbit1 filename used to evaluate the observation equations, not used as observations inputfileOrbit2 filename used to evaluate the observation equations, not used as observations inputfileStarCamera1 filename  inputfileStarCamera2 filename  earthRotation earthRotationType  ephemerides ephemeridesType  gradientfield gravityfieldType low order field to estimate the change of the gravity by position adjustement parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst parametrizationSatelliteTrackingType satellite tracking parameter keepSatelliteStates boolean set boundary values of each arc global integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n covarianceSst covarianceSstType covariance matrix of satellite to satellite tracking observations covariancePod1 covariancePodType covariance matrix of kinematic orbits (satellite 1) covariancePod2 covariancePodType covariance matrix of kinematic orbits (satellite 2) rightHandSide sequence input for observation vectors inputfileSatelliteTracking1 filename ranging observations and corrections inputfileSatelliteTracking2 filename ranging observations and corrections inputfileOrbit1 filename kinematic positions of satellite A as observations inputfileOrbit2 filename kinematic positions of satellite B as observations sstType choice  range   rangeRate   none   inputfileVariational1 filename approximate position and integrated state matrix inputfileVariational2 filename approximate position and integrated state matrix ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType gravity field parametrization parametrizationAcceleration1 parametrizationAccelerationType orbit1 force parameters parametrizationAcceleration2 parametrizationAccelerationType orbit2 force parameters parametrizationSst1 parametrizationSatelliteTrackingType satellite tracking parameter for first ranging observations parametrizationSst2 parametrizationSatelliteTrackingType satellite tracking parameter for second ranging observations integrationDegree uint integration of forces by polynomial approximation of degree n interpolationDegree uint orbit interpolation by polynomial approximation of degree n covarianceSst1 covarianceSstType covariance matrix of first satellite to satellite tracking observations covarianceSst2 covarianceSstType covariance matrix of second satellite to satellite tracking observations covarianceAcc covarianceSstType common covariance matrix of reduced satellite to satellite tracking observations covariancePod1 covariancePodType covariance matrix of kinematic orbits (satellite 1) covariancePod2 covariancePodType covariance matrix of kinematic orbits (satellite 2) rightHandSide sggRightSideType input for the observation vector inputfileOrbit filename  inputfileStarCamera filename  earthRotation earthRotationType  ephemerides ephemeridesType  parametrizationGravity parametrizationGravityType  parametrizationBias parametrizationTemporalType per arc useXX boolean  useYY boolean  useZZ boolean  useXY boolean  useXZ boolean  useYZ boolean  covarianceSgg sequence  sigma double general variance factor inputfileSigmasPerArc filename different accuaries for each arc (multplicated with sigma) inputfileCovarianceFunction filename covariance function in time rightHandSide sequence input for observation vectors inputfileGriddedData filename  observation expression [SI units] sigma expression accuracy, 1/sigma used as weighting referencefield gravityfieldType  kernel kernelType type of observations parametrizationGravity parametrizationGravityType  time time for reference field and parametrization blockingSize uint segementation of the obervations if designmatrix can\'t be build at once rightHandSide sequence input for observation vectors inputfileGriddedData filename  observationXi expression North-South Deflections of the Vertical [rad] observationEta expression East-West Deflections of the Vertical  [rad] sigmaXi expression accuracy, 1/sigma used as weighting sigmaEta expression accuracy, 1/sigma used as weighting referencefield gravityfieldType  parametrizationGravity parametrizationGravityType  time time for reference field and parametrization R double reference radius for ellipsoid inverseFlattening double reference flattening for ellipsoid, 0: sphere blockingSize uint segementation of the obervations if designmatrix can\'t be build at once rightHandSide sequence input for observation vectors inputfileGriddedData filename station positions with displacement data observationNorth expression displacement [m] observationEast expression displacement [m] observationUp expression displacement [m] sigmaNorth expression accuracy, 1/sigma used as weighting sigmaEast expression accuracy, 1/sigma used as weighting sigmaUp expression accuracy, 1/sigma used as weighting inGlobalFrame boolean obs/sigmas given in global x,y,z frame instead of north,east,up referencefield gravityfieldType  time time for reference field and parametrization parametrizationGravity parametrizationGravityType of loading (+defo) potential estimateTranslation boolean coordinate center estimateScale boolean scale factor of position estimateRotation boolean rotation inputfileDeformationLoadLoveNumber filename  inputfilePotentialLoadLoveNumber filename if full potential is given and not only loading potential R double reference radius for ellipsoid inverseFlattening double reference flattening for ellipsoid, 0: sphere', 'display_text': 'This class set up the oberservation equations in linearized Gauss-Makoff model \\[\\label{gmm} \\M l  = \\M A \\M x + \\M e\\qquad\\text{and}\\qquad\\mathcal{C}(\\M e) = \\sigma^2\\M P^{-1}. \\]The observations are divided into short data blocks which can computed independently and so easily can be parallelized. Usually this data blocks are short arcs of a satellites orbit. In most cases the unknown parameter vector contains coefficients of a gravity field parametrization given by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>. Additional parameters like instrument calibrations parameters are appended at the end of the vector $\\M x$. It is possible to give several observation vectors in one model.</p><p>The observations within each arc are decorrelated in the following way: In a first step a cholesky decomposition of the covariance matrix is performed \\[ \\M P^{-1} = \\M W^T\\M W, \\]where $\\M W$ is an upper regular triangular matrix. In a second step the transformation \\[\\label{dekorrelierung} \\bar{\\M A} = \\M W^{-T}\\M A\\qquad\\text{and}\\qquad \\bar{\\M l} = \\M W^{-T}\\M l \\]gives an estimation from decorrelated observations with equal variance \\[\\label{normal.GMM} \\bar{\\M l} = \\bar{\\M A} \\M x + \\bar{\\M e} \\qquad\\text{and}\\qquad \\mathcal{C}(\\bar{\\M e})= \\sigma^2 \\M I. \\]Usually the arc depending parameters are eliminated in the next step and not mentioned for the parameter names in the following.  <h2 id="podVariational">PodVariational</h2><p> The observation equations for precise orbit data (POD) are formulated as variational equations. It is based on <a class="groops-file" href="fileFormat_variationalEquation.html">inputfileVariational</a> calculated with <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a>. Necessary integrations are performed by integrating a moving interpolation polynomial of degree <strong class="groops-config-element">integrationDegree</strong>.</p><p>The kinematic positions as pseudo observations are taken from <strong class="groops-config-element">rightHandSide</strong> and should not given equally spaced in time. The observation equations are interpolated to these times by a moving polynomial of degree <strong class="groops-config-element">interpolationDegree</strong>.</p><p>The accuracy or the full covariance matrix of the precise orbit data is provided in <a class="groops-class" href="covariancePodType.html">covariancePod</a> and can be estimated with <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>.</p><p><strong class="groops-config-element">accelerateComputation</strong>: In the event that the sampling of the kinematic orbit is much higher than the sampling of the variational equations (e.g. 1 second vs. 5 seconds) the accumulation of the observation equations can be accelerated by transforming the observation equations \\[   \\M l = \\M J \\M A \\M x + \\M e, \\]where $\\M J$ describes the interpolation of the sampling of the variational design matrix $\\M A$ to the sampling of the observations $\\M l$ with more rows than columns. The QR decomposition \\[   \\M J = \\begin{pmatrix} \\M Q_1 & \\M Q_2 \\end{pmatrix}          \\begin{pmatrix} \\M R \\\\ \\M 0 \\end{pmatrix}. \\]can be used to transform the observation equations \\[   \\begin{pmatrix} \\M Q_1^T \\M l \\\\ \\M Q_2^T \\M l \\end{pmatrix} =   \\begin{pmatrix} \\M Q_1^T \\M R \\\\ \\M 0 \\end{pmatrix} \\M A \\M x +   \\begin{pmatrix} \\M Q_1^T \\M e \\\\ \\M Q_2^T \\M e \\end{pmatrix}. \\]As the zero lines should not be considered the computational time for the accumulation is reduced. This option is not meaningful for evaluating the residuals such in <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>&lt;satellite>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position0.x::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position0.y::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position0.z::</code>. </li><li> <code>&lt;satellite>:arc&lt;no>.velocity0.x::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.velocity0.y::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.velocity0.z::</code>. </li></ul>   <h2 id="podIntegral">PodIntegral</h2><p> The observation equations for precise orbit data (POD) of short arcs are given by \\[   {\\M r}_\\epsilon(\\tau) = {\\M r}_A(1-\\tau) + {\\M r}_B\\tau - T^2\\int_0^1 K(\\tau,\\tau\')   \\left(\\M f_0(\\tau\')+\\nabla V(\\tau\')\\right)\\,d\\tau\' \\]with the integral kernel \\[   K(\\tau,\\tau\') = \\begin{cases} \\tau\'(1-\\tau) & \\text{for }\\tau\'\\le\\tau \\\\   \\tau(1-\\tau\') & \\text{for }\\tau\'>\\tau \\end{cases}, \\]and the normalized time \\[   \\tau = \\frac{t-t_A}{T}\\qquad\\text{with}\\qquad T=t_B-t_A. \\]The kinematic positions ${\\M r}_\\epsilon(\\tau)$ as pseudo observations are taken from <a class="groops-class" href="podRightSideType.html">rightHandSide</a>. From these positions the influence of the reference forces $\\M f_0(\\tau)$ is subtracted which are computed with the background models in <a class="groops-class" href="podRightSideType.html">rightHandSide</a>. The integral is solved by the integration of a moving interpolation polynomial of degree <strong class="groops-config-element">integrationDegree</strong>. The boundary values ${\\M r}_A$ and ${\\M r}_B$ (satellite\'s state vector) are estimated per arc and are usually directly eliminated if <strong class="groops-config-element">keepSatelliteStates</strong> is not set.</p><p>The unknown gravity field $\\nabla V(\\M r, t)$ parametrized by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a> is not evaluated at the observed positions but at the orbit given by <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. The same is true for the reference forces. The linearized effect of the gravity field change by the position adjustment is taken into account by <strong class="groops-config-element">gradientfield</strong>. This may be a low order field up to a spherical harmonics degree of $n=2$ or $n=3$.</p><p>The <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>, <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>, and <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> must be synchronous and must be given with a constant sampling and without any gaps in each short arc (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>). The kinematic positions ${\\M r}_\\epsilon(\\tau)$ should not given equally spaced in time but must be divided into the same arcs as the other instrument data. The observation equations are interpolated to this time by a polynomial interpolation with degree <strong class="groops-config-element">interpolationDegree</strong>.</p><p>The accuracy or the full covariance matrix of the precise orbit data is provided in <a class="groops-class" href="covariancePodType.html">covariancePod</a> and can be estimated with <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>.</p><p>For <strong class="groops-config-element">accelerateComputation</strong> see <a class="groops-class" href="observationType.html#podVariational">observation:podVariational</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>&lt;satellite>:&lt;parametrizationAcceleration>:*:*</code>, </li></ul>  and for each arc if <strong class="groops-config-element">keepSatelliteStates</strong> is set <ul>  <li><code>&lt;satellite>:arc&lt;no>.position.start.x::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position.start.y::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position.start.z::</code>. </li><li> <code>&lt;satellite>:arc&lt;no>.position.end.x::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position.end.y::</code>, </li><li> <code>&lt;satellite>:arc&lt;no>.position.end.z::</code>. </li></ul>   <h2 id="podAcceleration">PodAcceleration</h2><p> The observation equations for precise orbit data (POD) are given by \\[ \\ddot{\\M r}(t) - \\M g_0(t) = \\nabla V(\\M r, t), \\]where the accelerations of the satellite $\\ddot{\\M r}(t)$ are derived from the kinematic positions in <a class="groops-class" href="podRightSideType.html">rightHandSide</a>. The orbit differentation is performed by a moving polynomial interpolation or approximation with degree <strong class="groops-config-element">interpolationDegree</strong> and number of used epochs <strong class="groops-config-element">numberOfEpochs</strong>. The reference forces $\\M g_0(t)$ are computed with the background models in <a class="groops-class" href="podRightSideType.html">rightHandSide</a>.</p><p>All instrument data <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>, <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>, and <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> must be synchronous and be given with a constant sampling without any gaps in each short arc (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).</p><p>The unknown gravity field $\\nabla V(\\M r, t)$ parametrized by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a> is not evaluated at the observed positions but at the orbit given by <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. The same is true for the reference forces. This orbit may be a more accurate dynamical orbit but in most cases the kinematic orbit provides good results.</p><p>The accuracy or the full covariance matrix of the precise orbit data is provided in <a class="groops-class" href="covariancePodType.html">covariancePod</a> and can be estimated with <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>&lt;satellite>:&lt;parametrizationAcceleration>:*:*</code>. </li></ul>   <h2 id="podEnergy">PodEnergy</h2><p> The observation equations for precise orbit data (POD) are given by \\[   \\frac{1}{2}\\dot{\\M r}^2   -\\dot{\\M r} \\cdot (\\M\\Omega\\times\\M r)   +\\int_{t_0}^t(\\dot{\\M\\Omega}\\times\\M r)\\cdot \\dot{\\M r}\\,dt   - \\int_{t_0}^t \\M g_0 \\cdot\\dot{\\M r}\'\\,dt   = V + E. \\]where the velocities of the satellite $\\ddot{\\M r}(t)$ are derived from the kinematic positions in <a class="groops-class" href="podRightSideType.html">rightHandSide</a> and the Earth\'s rotation vector $\\M\\Omega(t)$ is modeled within <a class="groops-class" href="earthRotationType.html">earthRotation</a>. The orbit differentation is performed by a polynomial interpolation with degree <strong class="groops-config-element">interpolationDegree</strong>. The integrals are solved a polynomial interpolation with degree <strong class="groops-config-element">integrationDegree</strong>. The reference forces $\\M g_0(t)$ are computed with the background models in <a class="groops-class" href="podRightSideType.html">rightHandSide</a>.</p><p>All instrument data <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>, <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a>, and <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> must be synchronous and be given with a constant sampling without any gaps in each short arc (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).</p><p>The unknown gravity potential $V(\\M r)$ parametrized by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a> is not evaluated at the observed positions but at the orbit given by <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>. The same is true for the reference forces. This orbit may be a more accurate dynamical orbit but in most cases the kinematic orbit provides good results.</p><p>An unknown energy bias $E$ per arc is parametrized by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationBias</a> and should be a constant in theory but temporal changes might help to absorb other unmodelled effects.</p><p>The accuracy or the full covariance matrix of the precise orbit data is provided in <a class="groops-class" href="covariancePodType.html">covariancePod</a> and can be estimated with <a class="groops-program" href="PreprocessingPod.html">PreprocessingPod</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <code>*:&lt;parametrizationGravity>:*:*</code>.  <h2 id="sstVariational">SstVariational</h2><p> Like <a class="groops-class" href="observationType.html#podVariational">observation:podVariational</a> (see there for details) but with two satellites and additional satellite-to-satellite (SST) observations.</p><p>If multiple <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a> are given all data are add together. So corrections in extra files like the light time correction can easily be added. Empirical parameters for the SST observations can be setup with <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrizationSst</a>. The accuracy or the full covariance matrix of SST is provided in <a class="groops-class" href="covarianceSstType.html">covarianceSst</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>&lt;satellite1>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position0.x::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position0.y::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position0.z::</code>. </li><li> <code>&lt;satellite1>:arc&lt;no>.velocity0.x::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.velocity0.y::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.velocity0.z::</code>. </li><li> <code>&lt;satellite2>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position0.x::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position0.y::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position0.z::</code>. </li><li> <code>&lt;satellite2>:arc&lt;no>.velocity0.x::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.velocity0.y::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.velocity0.z::</code>. </li><li> <code>&lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking>:*:*</code>. </li></ul>   <h2 id="sstIntegral">SstIntegral</h2><p> Like <a class="groops-class" href="observationType.html#podIntegral">observation:podIntegral</a> (see there for details) but with two satellites and additional satellite-to-satellite (SST) observations.</p><p>If multiple <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a> are given all data are add together. So corrections in extra files like the light time correction can easily be added. Empirical parameters for the SST observations can be setup with <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrizationSst</a>. The accuracy or the full covariance matrix of SST is provided in <a class="groops-class" href="covarianceSstType.html">covarianceSst</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>&lt;satellite1>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite2>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking>:*:*</code>, </li></ul>  and for each arc if <strong class="groops-config-element">keepSatelliteStates</strong> is set <ul>  <li><code>&lt;satellite1>:arc&lt;no>.position.start.x::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position.start.y::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position.start.z::</code>. </li><li> <code>&lt;satellite1>:arc&lt;no>.position.end.x::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position.end.y::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position.end.z::</code>. </li><li> <code>&lt;satellite2>:arc&lt;no>.position.start.x::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position.start.y::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position.start.z::</code>. </li><li> <code>&lt;satellite2>:arc&lt;no>.position.end.x::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position.end.y::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position.end.z::</code>. </li></ul>   <h2 id="dualSstVariational">DualSstVariational</h2><p> Like <a class="groops-class" href="observationType.html#sstVariational">observation:sstVariational</a> (see there for details) but with two simultaneous satellite-to-satellite (SST) observations.</p><p>This class reads two SST observation files (<a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking1</a> and <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking2</a>). Empirical parameters for the SST observations can be setup independently for both SST observation types with <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrizationSst1</a> and <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrizationSst2</a>.</p><p>Both SST observation types are reduced by the same background models and the same impact of accelerometer measurements. The covariance matrix of the reduced observations should not consider the the instrument noise only (<a class="groops-class" href="covarianceSstType.html">covarianceSst1/2</a>) but must take the cross correlations <a class="groops-class" href="covarianceSstType.html">covarianceAcc</a> into account. The covariance matrix of the reduced observations is given by \\[   \\M\\Sigma(\\begin{bmatrix} \\Delta l_{SST1} \\\\ \\Delta l_{SST2} \\end{bmatrix})   = \\begin{bmatrix} \\M\\Sigma_{SST1} + \\M\\Sigma_{ACC} & \\M\\Sigma_{ACC} \\\\                    \\M\\Sigma_{ACC} & \\M\\Sigma_{SST2} + \\M\\Sigma_{ACC}     \\end{bmatrix}. \\] The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>&lt;satellite1>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position0.x::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position0.y::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.position0.z::</code>. </li><li> <code>&lt;satellite1>:arc&lt;no>.velocity0.x::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.velocity0.y::</code>, </li><li> <code>&lt;satellite1>:arc&lt;no>.velocity0.z::</code>. </li><li> <code>&lt;satellite2>:&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.&lt;parametrizationAcceleration>:*:*</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position0.x::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position0.y::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.position0.z::</code>. </li><li> <code>&lt;satellite2>:arc&lt;no>.velocity0.x::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.velocity0.y::</code>, </li><li> <code>&lt;satellite2>:arc&lt;no>.velocity0.z::</code>. </li><li> <code>&lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking1>:*:*</code>. </li><li> <code>&lt;satellite1>.&lt;satellite2>:&lt;parametrizationSatelliteTracking2>:*:*</code>. </li></ul>   <h2 id="gradiometer">Gradiometer</h2><p> Observation equations for satellite gravity gradiometry (SGG) \\[   \\nabla\\nabla V(\\M r) =   \\begin{pmatrix}     \\frac{\\partial^2 V}{\\partial x^2}         & \\frac{\\partial^2 V}{\\partial x\\partial y} & \\frac{\\partial^2 V}{\\partial x\\partial z} \\\\     \\frac{\\partial^2 V}{\\partial y\\partial x} & \\frac{\\partial^2 V}{\\partial y^2}         & \\frac{\\partial^2 V}{\\partial y\\partial z} \\\\     \\frac{\\partial^2 V}{\\partial z\\partial x} & \\frac{\\partial^2 V}{\\partial z\\partial y} & \\frac{\\partial^2 V}{\\partial z^2}   \\end{pmatrix}. \\]From the <a class="groops-class" href="fileFormat_instrument.html">inputfileGradiometer</a> observations precomputed <a class="groops-class" href="fileFormat_instrument.html">inputfileReferenceGradiometer</a> together with other background models are reduced, all given in <a class="groops-class" href="sggRightSideType.html">rightHandSide</a>.</p><p>All instrument data <a class="groops-class" href="fileFormat_instrument.html">inputfileGradiometer</a>, <a class="groops-class" href="fileFormat_instrument.html">inputfileOrbit</a>, and <a class="groops-class" href="fileFormat_instrument.html">inputfileStarCamera</a> must be synchronous and be diveded into each short arcs (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).</p><p>Additional to the <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a> an (temporal changing) bias for each gradiometer component and arc can be estimated with <a class="groops-class" href="parametrizationTemporalType.html">parametrizationBias</a>.</p><p>The accuracy or the full covariance matrix of the gradiometer is provided in <strong class="groops-config-element">covarianceSgg</strong> and can be estimated with <a class="groops-program" href="PreprocessingGradiometer.html">PreprocessingGradiometer</a>.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <code>*:&lt;parametrizationGravity>:*:*</code>.  <h2 id="terrestrial">Terrestrial</h2><p> The gravity field is estimated from point wise measurements. The gravity field parametrization is given by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>. There is no need to have the data regular distributed or given on a sphere or ellipsoid. The type of the gridded data (e.g gravity anomalies or geoid heights) must be set with <a class="groops-class" href="kernelType.html">kernel</a>. A <a class="groops-class" href="gravityfieldType.html">referencefield</a> can be reduced beforehand.</p><p>The observations at given positions are calculated from <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>. The input columns are enumerated by <code>data0</code>, <code>data1</code>, , see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.</p><p>The observations can be divided into small blocks for parallelization. With <strong class="groops-config-element">blockingSize</strong> set the maximum count of observations in each block.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <code>*:&lt;parametrizationGravity>:*:*</code>.  <h2 id="deflections">Deflections</h2><p> The gravity field parametrized by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a> is estimated from deflections of the vertical measurements. A <a class="groops-class" href="gravityfieldType.html">referencefield</a> can be reduced beforehand.</p><p>The observations $\\xi$ in north direction and $\\eta$ in east direction at given positions are calculated from <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>. The input columns are enumerated by <code>data0</code>, <code>data1</code>, , see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.</p><p>The ellipsoid parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong> are used to define the local normal direction.</p><p>The observations can be divided into small blocks for parallelization. With <strong class="groops-config-element">blockingSize</strong> set the maximum count of observations in each block.</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <code>*:&lt;parametrizationGravity>:*:*</code>.  <h2 id="stationLoading">StationLoading</h2><p> Observation equations for displacements of a list of stations due to the effect of time variable loading masses. The displacement $\\M u$ of a station is calculated according to \\[ \\M u(\\M r) = \\frac{1}{\\gamma}\\sum_{n=0}^\\infty \\left[\\frac{h_n}{1+k_n}V_n(\\M r)\\,\\M e_{up} + R\\frac{l_n}{1+k_n}\\left(  \\frac{\\partial V_n(\\M r)}{\\partial \\M e_{north}}\\M e_{north} +\\frac{\\partial V_n(\\M r)}{\\partial \\M e_{east}} \\M e_{east}\\right)\\right], \\]where $\\gamma$ is the normal gravity, the load Love and Shida numbers $h_n,l_n$ are given by <a class="groops-class" href="fileFormat_matrix.html">inputfileDeformationLoadLoveNumber</a> and the load Love numbers $k_n$ are given by <a class="groops-class" href="fileFormat_matrix.html">inputfilePotentialLoadLoveNumber</a>. The $V_n$ are the spherical harmonics expansion of degree $n$ of the full time variable gravitational potential (potential of the loading mass + deformation potential) parametrized by <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>. Additional parameters can be setup to estimate the realization of the reference frame of the station coordinates (<strong class="groops-config-element">estimateTranslation</strong>, <strong class="groops-config-element">estimateRotation</strong>, and <strong class="groops-config-element">estimateScale</strong>).</p><p>The observations at stations coordinates are calculated from <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>. The input columns are enumerated by <code>data0</code>, <code>data1</code>, , see <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a>.</p><p>The ellipsoid parameters <strong class="groops-config-element">R</strong> and <strong class="groops-config-element">inverseFlattening</strong> are used to define the local frame (north, east, up).</p><p>The following parameters with <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are set up: <ul>  <li><code>*:&lt;parametrizationGravity>:*:*</code>, </li><li> <code>*:translation.x:*:*</code>, </li><li> <code>*:translation.y:*:*</code>, </li><li> <code>*:translation.z:*:*</code>, </li><li> <code>*:scale:*:*</code>, </li><li> <code>*:rotation.x:*:*</code>, </li><li> <code>*:rotation.y:*:*</code>, </li><li> <code>*:rotation.z:*:*</code>. </li></ul> </p><p>See also <a class="groops-program" href="Gravityfield2DisplacementTimeSeries.html">Gravityfield2DisplacementTimeSeries</a>.</p><p>Reference: Rietbroek (2014): Retrieval of Sea Level and Surface Loading Variations from Geodetic Observations and Model Simulations: an Integrated Approach, Bonn, 2014. - Dissertation, <a href="https://nbn-resolving.org/urn:nbn:de:hbz:5n-35460" target="_blank">https://nbn-resolving.org/urn:nbn:de:hbz:5n-35460</a>'},
'orbitPropagatorType': { 'name': 'orbitPropagatorType', 'key': 'orbitPropagatorType', 'description': 'Implements the propagation of a satellite orbit under the influence of     as used in  SimulateOrbit  (dynamic orbits from numerical orbit integration).     This class implements Euler\'s method to propagate a satellite orbit under the influence of    . Satellite is assumed to be oriented along-track.     This class implements the classical Runge-Kutta 4 method of orbit propagation for satellite orbit under the influence of    . No step-width control or other advanced features are implemented. Satellite is assumed to be oriented along-track. See: Montenbruck, Oliver, and Eberhard Gill. 2000. Satellite Orbits     This class implements the Adams-Moulton class of predictor-corrector orbit propagators for a satellite orbit under the influence of     using an implicit Adams-Bashforth corrector. The coefficients for the propagator are derived using the equations given in section 4.2.3 of [1]. Satellite is assumed to be oriented along-track. [1] Montenbruck, Oliver, and Eberhard Gill. 2000. Satellite Orbits     This class implements the Stoermer-Cowell class of predictor-corrector orbit propagators for a satellite orbit under the influence of    . The coefficients for the Stoermer predictor and Cowell corrector are derived using the equations given in section 4.2.6 of [1]. Stoermer-Cowell is a double integration algorithm, yielding positions directly from accelertions. It does not produce velocities. The velocities are derived using Adams-type propagators as suggested in [2]. Satellite is assumed to be oriented along-track. [1] Montenbruck, Oliver, and Eberhard Gill. 2000. Satellite Orbits [2] Berry, Matthew M., and Liam M. Healy. 2004. Implementation of Gauss-Jackson Integration for Orbit Propagation.     This class implements the Gauss-Jackson multi-step predictor-corrector method to propagate a satellite orbit under the influence of    . Satellite is assumed to be oriented along-track. Implementation is based on [1]. [1] Berry, Matthew M., and Liam M. Healy. 2004. Implementation of Gauss-Jackson Integration for Orbit Propagation.     This class implements an integration Polynomial method to propagate a satellite orbit under the influence of    . Satellite is assumed to be oriented along-track. Implementation is based on code by Torsten Mayer-Grr.     Reads an orbit from file. If the needed epochs are not given an exception is thrown.', 'config_table': 'order uint Order of the Adams-Bashforth type propagator. applyMoultonCorrector boolean Corrector step after Adams-Bashforth predcition. warmup orbitPropagatorType  order uint Order of the Stoermer-Cowell type propagator. warmup orbitPropagatorType  order uint of Gauss-Jackson method. warmup orbitPropagatorType  correctorIterations uint Maximum number of iterations to run the corrector step for. epsilon double Convergence criteria for position, velocity, and acceleration tests. degree uint polynomial degree to integrate accelerations shift int shift polynomial in future (predicted accelerations) epsilon double [m] max. position change to recompute forces warmup orbitPropagatorType to compute epochs before start epoch corrector boolean apply corrector iteration if position change is larger than epsilon inputfileOrbit filename epoch at timeStart is not used margin double [seconds] to find identical times recomputeForces boolean', 'display_text': 'Implements the propagation of a satellite orbit under the influence of <a class="groops-class" href="forcesType.html">forces</a> as used in <a class="groops-program" href="SimulateOrbit.html">SimulateOrbit</a> (dynamic orbits from numerical orbit integration).  <h2>Euler</h2><p> This class implements Euler\'s method to propagate a satellite orbit under the influence of <a class="groops-class" href="forcesType.html">Forces</a>. Satellite is assumed to be oriented along-track.  <h2>RungeKutta4</h2><p> This class implements the classical Runge-Kutta 4 method of orbit propagation for satellite orbit under the influence of <a class="groops-class" href="forcesType.html">Forces</a>. No step-width control or other advanced features are implemented. Satellite is assumed to be oriented along-track. See: Montenbruck, Oliver, and Eberhard Gill. 2000. Satellite Orbits  <h2>AdamsBashforthMoulton</h2><p> This class implements the Adams-Moulton class of predictor-corrector orbit propagators for a satellite orbit under the influence of <a class="groops-class" href="forcesType.html">Forces</a> using an implicit Adams-Bashforth corrector. The coefficients for the propagator are derived using the equations given in section 4.2.3 of [1]. Satellite is assumed to be oriented along-track. [1] Montenbruck, Oliver, and Eberhard Gill. 2000. Satellite Orbits  <h2>StoermerCowell</h2><p> This class implements the Stoermer-Cowell class of predictor-corrector orbit propagators for a satellite orbit under the influence of <a class="groops-class" href="forcesType.html">Forces</a>. The coefficients for the Stoermer predictor and Cowell corrector are derived using the equations given in section 4.2.6 of [1]. Stoermer-Cowell is a double integration algorithm, yielding positions directly from accelertions. It does not produce velocities. The velocities are derived using Adams-type propagators as suggested in [2]. Satellite is assumed to be oriented along-track. [1] Montenbruck, Oliver, and Eberhard Gill. 2000. Satellite Orbits [2] Berry, Matthew M., and Liam M. Healy. 2004. Implementation of Gauss-Jackson Integration for Orbit Propagation.  <h2>GaussJackson</h2><p> This class implements the Gauss-Jackson multi-step predictor-corrector method to propagate a satellite orbit under the influence of <a class="groops-class" href="forcesType.html">Forces</a>. Satellite is assumed to be oriented along-track. Implementation is based on [1]. [1] Berry, Matthew M., and Liam M. Healy. 2004. Implementation of Gauss-Jackson Integration for Orbit Propagation.  <h2 id="Polynomial">Polynomial</h2><p> This class implements an integration Polynomial method to propagate a satellite orbit under the influence of <a class="groops-class" href="forcesType.html">Forces</a>. Satellite is assumed to be oriented along-track. Implementation is based on code by Torsten Mayer-Grr.  <h2>File</h2><p> Reads an orbit from file. If the needed epochs are not given an exception is thrown.'},
'parameterNamesType': { 'name': 'parameterNamesType', 'key': 'parameterNamesType', 'description': 'Generate a list of parameter names. All parameters are appended.     The parameter is given by explicitly by four parts:    object: Object this parameter refers to, e.g.  graceA ,  G023 ,  earth ,  type: Type of this parameter, e.g.  accBias ,  position.x ,  temporal: Temporal representation of this parameter, e.g.  trend ,  polynomial.degree1 ,  interval: Interval/epoch this parameter represents, e.g.  2017-01-01_00-00-00_2017-01-02_00-00-00 ,  2018-01-01_00-00-00 .       Read parameter names from  file .     Parameter names of gravity    . An additional  object  name can be included in the parameter names.     Parameter names of satellite acceleration    . Arc related parameters are appended if an     is provided which defines the arc structure. An additional  object  name can be included in the parameter names.     Parameter names of satellite tracking    . An additional  object  name can be included in the parameter names.     Parameter names from temporal parametrization. It is possible to setup the temporal parameters for each    .     Parameter names of GNSS antenna center variation    . An additional  object  name (antenna name) can be included in the parameter names. It is possible to setup the parameters for each    .     Parameter names used in    .     Replaces parts of    s. The star " * " left this part untouched.     Select a subset of    s using    .     Removes all duplicate names (keep first) from    .', 'config_table': 'object string object this parameter refers to, e.g. graceA, G023, earth type string type of this parameter, e.g. accBias, position.x temporal string temporal representation of this parameter, e.g. trend, polynomial.degree1 interval string interval/epoch this parameter refers to, e.g. 2017-01-01_00-00-00_2017-01-02_00-00-00, 2008-01-01_00-00-00 inputfileParameterNames filename file with parameter names object string object these parameters refers to, e.g. earth parametrization parametrizationGravityType  object string object these parameters refers to, e.g. graceA, G023 parameterization parametrizationAccelerationType  inputfileInstrument filename defines the arc structure for arc related parameters object string object these parameters refers to, e.g. grace1.grace2 parameterization parametrizationSatelliteTrackingType  parameterNameBase parameterNamesType  parametrizationTemporal parametrizationTemporalType  object string antenna name parametrization parametrizationGnssAntennaType  gnssType gnssType e.g. C1CG** observation observationType  parameterName parameterNamesType  object string *: left this part untouched, object type string *: left this part untouched, type temporal string *: left this part untouched, temporal representation interval string *: left this part untouched, interval/epoch parameterName parameterNamesType  parameterSelection parameterSelectorType parameter order/selection parameterName parameterNamesType', 'display_text': 'Generate a list of parameter names. All parameters are appended.  <h2>Name</h2><p> The parameter is given by explicitly by four parts: <ol>  <li>object: Object this parameter refers to, e.g. <code>graceA</code>, <code>G023</code>, <code>earth</code>, </li><li> type: Type of this parameter, e.g. <code>accBias</code>, <code>position.x</code>, </li><li> temporal: Temporal representation of this parameter, e.g. <code>trend</code>, <code>polynomial.degree1</code>, </li><li> interval: Interval/epoch this parameter represents, e.g. <code>2017-01-01_00-00-00_2017-01-02_00-00-00</code>, <code>2018-01-01_00-00-00</code>. </li></ol>   <h2>File</h2><p> Read parameter names from <a class="groops-file" href="fileFormat_parameterName.html">file</a>.  <h2>Gravity</h2><p> Parameter names of gravity <a class="groops-class" href="parametrizationGravityType.html">parametrization</a>. An additional <strong class="groops-config-element">object</strong> name can be included in the parameter names.  <h2>Acceleration</h2><p> Parameter names of satellite acceleration <a class="groops-class" href="parametrizationAccelerationType.html">parametrization</a>. Arc related parameters are appended if an <a class="groops-class" href="fileFormat_instrument.html">inputfileInstrument</a> is provided which defines the arc structure. An additional <strong class="groops-config-element">object</strong> name can be included in the parameter names.  <h2>SatelliteTracking</h2><p> Parameter names of satellite tracking <a class="groops-class" href="parametrizationSatelliteTrackingType.html">parametrization</a>. An additional <strong class="groops-config-element">object</strong> name can be included in the parameter names.  <h2>Temporal</h2><p> Parameter names from temporal parametrization. It is possible to setup the temporal parameters for each <a class="groops-class" href="parameterNamesType.html">parameterNameBase</a>.  <h2>GnssAntenna</h2><p> Parameter names of GNSS antenna center variation <a class="groops-class" href="parametrizationGnssAntennaType.html">parametrization</a>. An additional <strong class="groops-config-element">object</strong> name (antenna name) can be included in the parameter names. It is possible to setup the parameters for each <a class="groops-class" href="gnssType.html">gnssType</a>.  <h2>Observation</h2><p> Parameter names used in <a class="groops-class" href="observationType.html">observation equations</a>.  <h2>Rename</h2><p> Replaces parts of <a class="groops-class" href="parameterNamesType.html">parameterName</a>s. The star "<code>*</code>" left this part untouched.  <h2>Selection</h2><p> Select a subset of <a class="groops-class" href="parameterNamesType.html">parameterName</a>s using <a class="groops-class" href="parameterSelectorType.html">parameterSelection</a>.  <h2>WithoutDuplicates</h2><p> Removes all duplicate names (keep first) from <a class="groops-class" href="parameterNamesType.html">parameterName</a>.'},
'parameterSelectorType': { 'name': 'parameterSelectorType', 'key': 'parameterSelectorType', 'description': 'This class provides an index vector from selected parameters, which can be used e.g. to reorder a normal equation matrix. The size of the index vector determines the size of the new matrix. Entries are the indices of the selected parameters in the provided parameter list or NULLINDEX for zero/new parameters.     Parameter index vector from name. Name matching supports wildcards * for any number of characters and ? for exactly one character. Does not add zero/empty parameters if there are no matches.     Parameter index vector from list of parameter names.     Parameter index vector from range.     Parameter index vector from matrix.     Expand parameter index vector by adding zero parameters.     Parameter index vector from a complement of other parameter selector(s).', 'config_table': 'object string object this parameter refers to, e.g. graceA, G023, earth (wildcards: * and ?) type string type of this parameter, e.g. accBias, position.x (wildcards: * and ?) temporal string temporal representation of this parameter, e.g. trend, polynomial.degree1 (wildcards: * and ?) interval string interval/epoch this parameter refers to, e.g. 2017-01-01_00-00-00_2017-01-02_00-00-00, 2008-01-01_00-00-00 (wildcards: * and ?) parameterName parameterNamesType  start expression start at this index (variables: length) count expression count of parameters, default: all parameters to the end (variables: length) inputfileMatrix filename index in old parameter list or -1 for new parameter column expression use this column (counting from 0, variables: columns) startRow expression start at this row (counting from 0, variables: rows) countRows expression use these many rows (default: use all, variables: rows) count expression count of zero parameters (variables: length) parameterSelection parameterSelectorType parameter order/selection', 'display_text': 'This class provides an index vector from selected parameters, which can be used e.g. to reorder a normal equation matrix. The size of the index vector determines the size of the new matrix. Entries are the indices of the selected parameters in the provided parameter list or NULLINDEX for zero/new parameters.  <h2 id="wildcard">Wildcard</h2><p> Parameter index vector from name. Name matching supports wildcards * for any number of characters and ? for exactly one character. Does not add zero/empty parameters if there are no matches.  <h2>Names</h2><p> Parameter index vector from list of parameter names.  <h2>Range</h2><p> Parameter index vector from range.  <h2>Matrix</h2><p> Parameter index vector from matrix.  <h2>Zeros</h2><p> Expand parameter index vector by adding zero parameters.  <h2 id="complement">Complement</h2><p> Parameter index vector from a complement of other parameter selector(s).'},
'parametrizationAccelerationType': { 'name': 'parametrizationAccelerationType', 'key': 'parametrizationAccelerationType', 'description': 'This class defines parameters of satellite accelerations. It will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.     Oscillation once, twice, ... per revolution in Satellite Reference Frame (SRF) with the argument of latitude as input angle.  If the attitude of the satellite is not provided the Celestial Reference Frame (CRF) is used instead. Paramters are estimated in  . The  parameter names  are    *:perRevolution.cos(&lt;order>*u).x::&lt;interval> ,  *:perRevolution.cos(&lt;order>*u).y::&lt;interval> ,  *:perRevolution.cos(&lt;order>*u).z::&lt;interval> ,  *:perRevolution.sin(&lt;order>*u).x::&lt;interval> ,  *:perRevolution.sin(&lt;order>*u).y::&lt;interval> ,  *:perRevolution.sin(&lt;order>*u).z::&lt;interval> .       Temporal changing accelerometer bias per axis in   in Satellite Reference Frame (SRF). If the attitude of the satellite is not provided the Celestial Reference Frame (CRF) is used instead. The  parameter names  are    *:accBias.x:*:* ,  *:accBias.y:*:* ,  *:accBias.z:*:* .       Accelerometer scale factor per axis. The  parameter names  are    *:accScale.x:&lt;temporal>:&lt;interval> ,  *:accScale.y:&lt;temporal>:&lt;interval> ,  *:accScale.z:&lt;temporal>:&lt;interval> ,  *:accScaleCross.xy:&lt;temporal>:&lt;interval> ,  *:accScaleCross.xz:&lt;temporal>:&lt;interval> ,  *:accScaleCross.yz:&lt;temporal>:&lt;interval> ,  *:accScaleRotation.xy:&lt;temporal>:&lt;interval> ,  *:accScaleRotation.xz:&lt;temporal>:&lt;interval> ,  *:accScaleRotation.yz:&lt;temporal>:&lt;interval> .  This parametrization needs the attitude of the satellite.     GNSS solar radiation pressure model. Paramters are estimated in  . The  parameter names  are    *:solarRadiationPressure.ECOM.D0:*:* ,  *:solarRadiationPressure.ECOM.DC2:*:* ,  *:solarRadiationPressure.ECOM.DS2:*:* ,  *:solarRadiationPressure.ECOM.DC4:*:* ,  *:solarRadiationPressure.ECOM.DS4:*:* ,  *:solarRadiationPressure.ECOM.Y0:*:* ,  *:solarRadiationPressure.ECOM.B0:*:* ,  *:solarRadiationPressure.ECOM.BC1:*:* ,  *:solarRadiationPressure.ECOM.BS1:*:* ,  *:solarRadiationPressure.ECOM.BC3:*:* ,  *:solarRadiationPressure.ECOM.BS3:*:* .  This parametrization needs the attitude of the satellite.     Estimate the thermospheric density along the orbit using a satllite macro model. An optional thermospheric model can be used to compute temperature and wind. The temperature is used to estimate variable drag and lift coefficients, otherwise a constant drag coefficient is used. The density is estimated in  . The  parameter names  are  *:density:&lt;temporal>:&lt;interval> . This parametrization needs the macro model and the attitude of the satellite.     Estimate a scale factor for a given model. The  parameter names  are  *:modelScale:&lt;temporal>:&lt;interval> .', 'config_table': 'order uint once, twice, ... estimateX boolean along estimateY boolean cross estimateZ boolean radial interval timeSeriesType setup new parameters each interval perArc boolean  estimateX boolean along estimateY boolean cross estimateZ boolean radial temporal parametrizationTemporalType  perArc boolean  inputfileAccelerometer filename  estimateX boolean along estimateY boolean cross estimateZ boolean radial estimateCrossTalk boolean non-orthognality of axes estimateRotation boolean misalignment temporal parametrizationTemporalType  perArc boolean  estimateD0 boolean constant term along D-axis (sat-sun vector) estimateD2 boolean 2-per-rev terms along D-axis estimateD4 boolean 4-per-rev terms along D-axis estimateY0 boolean constant term along Y-axis (solar panel axis) estimateB0 boolean constant term along B-axis (cross product D x Y) estimateB1 boolean 1-per-rev terms along B-axis estimateB3 boolean 3-per-rev terms along B-axis perArc boolean  eclipse eclipseType  thermosphere thermosphereType for wind and temperature earthRotation double [rad/s] considerTemperature boolean compute drag and lift, otherwise simple drag coefficient is used considerWind boolean  temporalDensity parametrizationTemporalType parameters along orbit perArc boolean  miscAccelerations miscAccelerationsType  temporal parametrizationTemporalType  perArc boolean', 'display_text': 'This class defines parameters of satellite accelerations. It will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.  <h2 id="perRevolution">PerRevolution</h2><p> Oscillation once, twice, ... per revolution in Satellite Reference Frame (SRF) with the argument of latitude as input angle.  If the attitude of the satellite is not provided the Celestial Reference Frame (CRF) is used instead. Paramters are estimated in $[nm/s^2=10^{-9}\\,m/s^2]$.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:perRevolution.cos(&lt;order>*u).x::&lt;interval></code>, </li><li> <code>*:perRevolution.cos(&lt;order>*u).y::&lt;interval></code>, </li><li> <code>*:perRevolution.cos(&lt;order>*u).z::&lt;interval></code>, </li><li> <code>*:perRevolution.sin(&lt;order>*u).x::&lt;interval></code>, </li><li> <code>*:perRevolution.sin(&lt;order>*u).y::&lt;interval></code>, </li><li> <code>*:perRevolution.sin(&lt;order>*u).z::&lt;interval></code>. </li></ul>   <h2 id="accBias">AccBias</h2><p> Temporal changing accelerometer bias per axis in $[m/s^2]$ in Satellite Reference Frame (SRF). If the attitude of the satellite is not provided the Celestial Reference Frame (CRF) is used instead.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:accBias.x:*:*</code>, </li><li> <code>*:accBias.y:*:*</code>, </li><li> <code>*:accBias.z:*:*</code>. </li></ul>   <h2 id="accelerometerScaleFactors">AccelerometerScaleFactors</h2><p> Accelerometer scale factor per axis.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:accScale.x:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScale.y:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScale.z:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScaleCross.xy:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScaleCross.xz:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScaleCross.yz:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScaleRotation.xy:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScaleRotation.xz:&lt;temporal>:&lt;interval></code>, </li><li> <code>*:accScaleRotation.yz:&lt;temporal>:&lt;interval></code>. </li></ul> </p><p>This parametrization needs the attitude of the satellite.  <h2 id="gnssSolarRadiation">GnssSolarRadiation</h2><p> GNSS solar radiation pressure model. Paramters are estimated in $[nm/s^2=10^{-9}\\,m/s^2]$.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:solarRadiationPressure.ECOM.D0:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.DC2:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.DS2:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.DC4:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.DS4:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.Y0:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.B0:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.BC1:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.BS1:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.BC3:*:*</code>, </li><li> <code>*:solarRadiationPressure.ECOM.BS3:*:*</code>. </li></ul> </p><p>This parametrization needs the attitude of the satellite.  <h2 id="thermosphericDensity">ThermosphericDensity</h2><p> Estimate the thermospheric density along the orbit using a satllite macro model. An optional thermospheric model can be used to compute temperature and wind. The temperature is used to estimate variable drag and lift coefficients, otherwise a constant drag coefficient is used. The density is estimated in $[kg/m^3]$.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:density:&lt;temporal>:&lt;interval></code>.</p><p>This parametrization needs the macro model and the attitude of the satellite.  <h2 id="modelScale">ModelScale</h2><p> Estimate a scale factor for a given model. The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:modelScale:&lt;temporal>:&lt;interval></code>.'},
'parametrizationGnssAntennaType': { 'name': 'parametrizationGnssAntennaType', 'key': 'parametrizationGnssAntennaType', 'description': 'Parametrization of antenna center variations. It will be used to set up the design matrix in a least squares adjustment. Usually the parametrization is setup separately for different    . If multiple parametrizations are given the parameters are sequently appended in the design matrix and parameter vector.     Antenna center or, if setup for a specific    , phase/code center offset (e.g.  *1*G  for GPS L1 phase center offset) in  . The  parameter names  are    *:antennaCenter.x:*:* ,  *:antennaCenter.y:*:* ,  *:antennaCenter.z:*:* .       Parametrization of antenna center variations in   in terms of spherical harmonics. As usually only data above the horizon are observed only the even spherical harmonics (degree/order   even), which are symmetric to the equator, are setup. The total count of parameters is   and the  parameter names  are    *:antennaCenterVariations.sphericalHarmonics.c_&lt;degree>_&lt;order>:*:* ,  *:antennaCenterVariations.sphericalHarmonics.s_&lt;degree>_&lt;order>:*:* .      Parametrization of antenna center variations with radial basis functions  where   in   the coefficients which has to be estimated and   are the basis functions   The  parameter names  are  *:antennaCenterVariations.radialBasis.&lt;index>.&lt;total count>:*:* .', 'config_table': 'estimateX boolean  estimateY boolean  estimateZ boolean  minDegree uint min degree maxDegree uint max degree grid gridType nodal points of shannon kernels minDegree uint min degree of shannon kernel maxDegree uint max degree of shannon kernel', 'display_text': 'Parametrization of antenna center variations. It will be used to set up the design matrix in a least squares adjustment. Usually the parametrization is setup separately for different <a class="groops-class" href="gnssType.html">gnssType</a>.</p><p>If multiple parametrizations are given the parameters are sequently appended in the design matrix and parameter vector.  <h2 id="center">Center</h2><p> Antenna center or, if setup for a specific <a class="groops-class" href="gnssType.html">gnssType</a>, phase/code center offset (e.g. <code>*1*G</code> for GPS L1 phase center offset) in $[m]$.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:antennaCenter.x:*:*</code>, </li><li> <code>*:antennaCenter.y:*:*</code>, </li><li> <code>*:antennaCenter.z:*:*</code>. </li></ul>   <h2>SphericalHarmonics</h2><p> Parametrization of antenna center variations in $[m]$ in terms of spherical harmonics. As usually only data above the horizon are observed only the even spherical harmonics (degree/order $m+n$ even), which are symmetric to the equator, are setup.</p><p>The total count of parameters is $((n_{max}+1)(n_{max}+2)-n_{min}(n_{min}+1)/2$ and the <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:antennaCenterVariations.sphericalHarmonics.c_&lt;degree>_&lt;order>:*:*</code>, </li><li> <code>*:antennaCenterVariations.sphericalHarmonics.s_&lt;degree>_&lt;order>:*:*</code>. </li></ul> </p><p> <h2>RadialBasis</h2><p> Parametrization of antenna center variations with radial basis functions \\[   ACV(\\M x(A, E)) = \\sum_i a_i \\Phi(\\M x\\cdot\\M x_i) \\]where $a_i$ in $[m]$ the coefficients which has to be estimated and $\\Phi$ are the basis functions \\[   \\Phi(\\cos\\psi) = \\sum_n \\sqrt{2n+1}P_n(\\cos\\psi). \\] The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:antennaCenterVariations.radialBasis.&lt;index>.&lt;total count>:*:*</code>.</p><p>'},
'parametrizationGravityType': { 'name': 'parametrizationGravityType', 'key': 'parametrizationGravityType', 'description': 'This class gives a parametrization of the time depending gravity field. Together with the class     it will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.     The potential   is parametrized by a expansion of (fully normalized) spherical harmonics  You can set the range of degree   with  minDegree  and  maxDegree . The sorting sequence of the potential coefficients in the parameter vector can be defined by    . The total count of parameters is   and the  parameter names  are    *:sphericalHarmonics.c_&lt;degree>_&lt;order>:*:* ,  *:sphericalHarmonics.s_&lt;degree>_&lt;order>:*:* .       The potential   is represented by a sum of space localizing basis functions  where   the coefficients which has to be estimated and   are the basis functions given by isotropic radial     functions  The basis functions are located on a grid   given by    . This class can also be used to estimate point masses if     is set to density. The  parameter names  are  *:radialBasis.&lt;index>.&lt;total count>:*:* .     The time variable potential is given by  wehre   is the spatial parametrization of the gravity field and can be choosen with    . The parametrization in time domain   is selected by    . The total parameter count is the parameter count of     times the parameter count of    .     Parametrization of the gravity field on the basis of a linear transformation of a source parametrization. The linear transformation changes the original solution space represented by     from  to  through the linear transformation  . It follows that the rows of the matrix   in  inputfileTransformationMatrix  coincides with the number of parameters in    . The new parameter count is given by the number of columns in   and may be smaller, equal or larger than the original parameter count. The  parameter names  are  *:transformedParameter.&lt;index>.&lt;total count>:*:* .     This class is used to estimate the earthquake oscillation function parameters, i.e.  ,  , and  . The results describes the variation in the gravitational potential field caused by large earthquakes.  with   and   . In this equation,   is the attenuation factor,   is the overtone factor,   is degree,   is order, and   is time after earthquake in second. The  parameter names  are    *:earthquakeParameter.c_&lt;degree>_&lt;order>_A:*:* ,  *:earthquakeParameter.s_&lt;degree>_&lt;order>_A:*:* ,  *:earthquakeParameter.c_&lt;degree>_&lt;order>_W:*:* ,  *:earthquakeParameter.s_&lt;degree>_&lt;order>_W:*:* ,  *:earthquakeParameter.c_&lt;degree>_&lt;order>_P:*:* ,  *:earthquakeParameter.s_&lt;degree>_&lt;order>_P:*:* .', 'config_table': 'minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme kernel kernelType shape of the radial basis function grid gridType nodal point distribution parametrizationGravity parametrizationGravityType  parametrizationTemporal parametrizationTemporalType  parametrizationGravitySource parametrizationGravityType  inputfileTransformationMatrix filename transformation matrix from target to source parametrization (rows of this matrix must coincide with the parameter count of the source parametrization) inputInitialCoefficient filename initial values for oscillation parameters time0 time the time earthquake happened minDegree uint  maxDegree uint  GM double Geocentric gravitational constant R double reference radius numbering sphericalHarmonicsNumberingType numbering scheme', 'display_text': 'This class gives a parametrization of the time depending gravity field. Together with the class <a class="groops-class" href="observationType.html">oberservation</a> it will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.  <h2 id="sphericalHarmonics">SphericalHarmonics</h2><p> The potential $V$ is parametrized by a expansion of (fully normalized) spherical harmonics \\[ V(\\lambda,\\vartheta,r) = \\frac{GM}{R}\\sum_{n=0}^\\infty \\sum_{m=0}^n \\left(\\frac{R}{r}\\right)^{n+1}   \\left(c_{nm} C_{nm}(\\lambda,\\vartheta) + s_{nm} S_{nm}(\\lambda,\\vartheta)\\right). \\]You can set the range of degree $n$ with <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong>. The sorting sequence of the potential coefficients in the parameter vector can be defined by <a class="groops-class" href="sphericalHarmonicsNumberingType.html">numbering</a>.</p><p>The total count of parameters is $(n_{max}+1)^2-n_{min}^2$ and the <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:sphericalHarmonics.c_&lt;degree>_&lt;order>:*:*</code>, </li><li> <code>*:sphericalHarmonics.s_&lt;degree>_&lt;order>:*:*</code>. </li></ul>   <h2 id="radialBasis">RadialBasis</h2><p> The potential $V$ is represented by a sum of space localizing basis functions \\[   V(\\M x) = \\sum_i a_i \\Phi(\\M x, \\M x_i) \\]where $a_i$ the coefficients which has to be estimated and $\\Phi$ are the basis functions given by isotropic radial <a class="groops-class" href="kernelType.html">kernel</a> functions \\[   \\Phi(\\cos\\psi,r,R) = \\sum_n \\left(\\frac{R}{r}\\right)^{n+1} k_n\\sqrt{2n+1}\\bar{P}_n(\\cos\\psi). \\]The basis functions are located on a grid $\\M x_i$ given by <a class="groops-class" href="gridType.html">grid</a>. This class can also be used to estimate point masses if <a class="groops-class" href="kernelType.html">kernel</a> is set to density.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:radialBasis.&lt;index>.&lt;total count>:*:*</code>.  <h2>Temporal</h2><p> The time variable potential is given by \\[   V(\\M x,t) = \\sum_i V_i(\\M x)\\Psi_i(t), \\]wehre $V_i(\\M x)$ is the spatial parametrization of the gravity field and can be choosen with <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>. The parametrization in time domain $\\Psi_i(t)$ is selected by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>. The total parameter count is the parameter count of <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a> times the parameter count of <a class="groops-class" href="parametrizationGravityType.html">parametrizationGravity</a>.  <h2>LinearTransformation</h2><p> Parametrization of the gravity field on the basis of a linear transformation of a source parametrization. The linear transformation changes the original solution space represented by <a class="groops-class" href="parametrizationGravityType.html">pararametrizationGravitySource</a> from \\[   \\mathbf{l} = \\mathbf{A}\\mathbf{x} + \\mathbf{e} \\]to \\[   \\mathbf{l} = \\mathbf{A}\\mathbf{F}\\mathbf{y} + \\mathbf{e} \\]through the linear transformation $\\mathbf{x}=\\mathbf{F}\\mathbf{y}$. It follows that the rows of the matrix $\\mathbf{F}$ in <a class="groops-file" href="fileFormat_matrix.html">inputfileTransformationMatrix</a> coincides with the number of parameters in <a class="groops-class" href="parametrizationGravityType.html">pararametrizationGravitySource</a>. The new parameter count is given by the number of columns in $\\mathbf{F}$ and may be smaller, equal or larger than the original parameter count.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:transformedParameter.&lt;index>.&lt;total count>:*:*</code>.  <h2>EarthquakeOscillation</h2><p> This class is used to estimate the earthquake oscillation function parameters, i.e. $C_{nlm}$, $\\omega_{nlm}$, and $P_{nlm}$. The results describes the variation in the gravitational potential field caused by large earthquakes. \\[ C_{lm}(\\M t) = \\sum_{n=0}^NC_{nlm}(1-\\cos(\\omega_{nlm}d\\M t)\\exp(P_{nlm}\\omega_{nlm}d\\M t)), \\]with $\\omega_{nlm}=\\frac{2\\pi}{T_{nlm}}$ and $P_{nlm}=\\frac{-1}{2Q_{nlm}}$ . In this equation, $Q_{nlm}$ is the attenuation factor, $n$ is the overtone factor, $m$ is degree, $l$ is order, and $t$ is time after earthquake in second.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>*:earthquakeParameter.c_&lt;degree>_&lt;order>_A:*:*</code>, </li><li> <code>*:earthquakeParameter.s_&lt;degree>_&lt;order>_A:*:*</code>, </li><li> <code>*:earthquakeParameter.c_&lt;degree>_&lt;order>_W:*:*</code>, </li><li> <code>*:earthquakeParameter.s_&lt;degree>_&lt;order>_W:*:*</code>, </li><li> <code>*:earthquakeParameter.c_&lt;degree>_&lt;order>_P:*:*</code>, </li><li> <code>*:earthquakeParameter.s_&lt;degree>_&lt;order>_P:*:*</code>. </li></ul>'},
'parametrizationSatelliteTrackingType': { 'name': 'parametrizationSatelliteTrackingType', 'key': 'parametrizationSatelliteTrackingType', 'description': 'This class defines parameters of Satellite-to-Satellite tracking observations. It will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.     Estimate the KBR antenna phase centre (APC) coordinates in   for each spacecraft in satellite reference frame (SRF) as constant per axis. The observation equations are computed by taking the derivative of the antenna offset correction equation w.r.t. the KBR APC coordinates. The  parameter names  are    satellite1.satellite2:sstAntennaCenter1.x:*:* ,  satellite1.satellite2:sstAntennaCenter1.y:*:* ,  satellite1.satellite2:sstAntennaCenter1.z:*:* ,  satellite1.satellite2:sstAntennaCenter2.x:*:* ,  satellite1.satellite2:sstAntennaCenter2.y:*:* ,  satellite1.satellite2:sstAntennaCenter2.z:*:* .       Estimate bias for SST observations in   or  ]. The temporal variation is defined by    . The  parameter names  are  satellite1.satellite2:sstBias:&lt;temporal>:&lt;interval> .     Estimate scale factor for SST observations with respect to reference SST data    . The temporal variation is defined by    . The  parameter names  are  satellite1.satellite2:sstScale:&lt;temporal>:&lt;interval> .     Estimate time shift in seconds in SST observations, with defined temporal variation by    . The design matrix is computed by taking the derivative of the ranging data w.r.t. time. The  parameter names  are  satellite1.satellite2:sstTimeBias:&lt;temporal>:&lt;interval> .     Estimate scale factors for deterministic signal models from satellite tracking instrument file    , see  EnsembleAveragingScaleModel . Amplitude variation of model waveforms is defined by    . The  parameter names  are  satellite1.satellite2:scaleModel:&lt;temporal>:&lt;interval> .     Estimate deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. These events can be time-indexed beforehand using satellite position and orientation, see  GraceSstSpecialEvents . The shape of this short-period waveform is nearly constant within one month and can be approximated by a polynomial. The amplitude variation of the waveform can also be taken into account by    . The  parameter names  are  satellite1.satellite2:&lt;type>.legendrePolynomial.n&lt;degree>:&lt;temporal>:&lt;interval> .', 'config_table': 'estimate1X boolean along (satellite 1) estimate1Y boolean cross (satellite 1) estimate1Z boolean nadir (satellite 1) estimate2X boolean along (satellite 2) estimate2Y boolean cross (satellite 2) estimate2Z boolean nadir (satellite 2) interpolationDegree uint differentiation by polynomial approximation of degree n temporal parametrizationTemporalType  perArc boolean  inputfileSatelliteTracking filename  temporal parametrizationTemporalType  perArc boolean  polynomialDegree uint polynomial degree temporal parametrizationTemporalType  perArc boolean  inputfileSatelliteTracking filename  temporal parametrizationTemporalType  perArc boolean  inputfileEvents filename instrument with GRACE events type choice  eclipse1   eclipse2   starCameraBox1   starCameraBox2   starCameraBox3   starCameraBox4   starCameraBox5   starCameraBox6   marginLeft double margin size (on both sides) [seconds] marginRight double margin size (on both sides) [seconds] minNumberOfEvents uint min. number of events to setup parameters polynomialDegree uint polynomial degree temporal parametrizationTemporalType', 'display_text': 'This class defines parameters of Satellite-to-Satellite tracking observations. It will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.  <h2 id="antennaCenter">AntennaCenter</h2><p> Estimate the KBR antenna phase centre (APC) coordinates in $[m]$ for each spacecraft in satellite reference frame (SRF) as constant per axis. The observation equations are computed by taking the derivative of the antenna offset correction equation w.r.t. the KBR APC coordinates.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <ul>  <li><code>satellite1.satellite2:sstAntennaCenter1.x:*:*</code>, </li><li> <code>satellite1.satellite2:sstAntennaCenter1.y:*:*</code>, </li><li> <code>satellite1.satellite2:sstAntennaCenter1.z:*:*</code>, </li><li> <code>satellite1.satellite2:sstAntennaCenter2.x:*:*</code>, </li><li> <code>satellite1.satellite2:sstAntennaCenter2.y:*:*</code>, </li><li> <code>satellite1.satellite2:sstAntennaCenter2.z:*:*</code>. </li></ul>   <h2 id="bias">Bias</h2><p> Estimate bias for SST observations in $[m]$ or $[m/s$]. The temporal variation is defined by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>satellite1.satellite2:sstBias:&lt;temporal>:&lt;interval></code>.  <h2 id="scale">Scale</h2><p> Estimate scale factor for SST observations with respect to reference SST data <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>. The temporal variation is defined by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>satellite1.satellite2:sstScale:&lt;temporal>:&lt;interval></code>.  <h2 id="timeBias">TimeBias</h2><p> Estimate time shift in seconds in SST observations, with defined temporal variation by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>. The design matrix is computed by taking the derivative of the ranging data w.r.t. time.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>satellite1.satellite2:sstTimeBias:&lt;temporal>:&lt;interval></code>.  <h2 id="scaleModel">ScaleModel</h2><p> Estimate scale factors for deterministic signal models from satellite tracking instrument file <a class="groops-class" href="fileFormat_instrument.html">inputfileSatelliteTracking</a>, see <a class="groops-program" href="EnsembleAveragingScaleModel.html">EnsembleAveragingScaleModel</a>. Amplitude variation of model waveforms is defined by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>satellite1.satellite2:scaleModel:&lt;temporal>:&lt;interval></code>.  <h2 id="specialEffect">SpecialEffect</h2><p> Estimate deterministic signals in the GRACE K-Band measurements caused by Sun intrusions into the star camera baffles of GRACE-A and eclipse transits of the satellites. These events can be time-indexed beforehand using satellite position and orientation, see <a class="groops-program" href="GraceSstSpecialEvents.html">GraceSstSpecialEvents</a>. The shape of this short-period waveform is nearly constant within one month and can be approximated by a polynomial. The amplitude variation of the waveform can also be taken into account by <a class="groops-class" href="parametrizationTemporalType.html">parametrizationTemporal</a>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>satellite1.satellite2:&lt;type>.legendrePolynomial.n&lt;degree>:&lt;temporal>:&lt;interval></code>.'},
'parametrizationTemporalType': { 'name': 'parametrizationTemporalType', 'key': 'parametrizationTemporalType', 'description': 'This class gives a parametrization of time depending parameters (gravity field, positions, ...). It will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended. Useally time intervals are defined half open meaning the last time belongs not to the interval. This behaviour can be changed for the last interval with  includeLastTime .     Represents a parameter being constant in time in each  interval . The  parameter names  are  *:*:*:&lt;interval> .     A time variable function is given by a linear trend  with   is  timeStart  and   is  timeStep  in days. A constant term is not included and must added separately. The  parameter name  is  *:*:trend.&lt;timeStep(days)>*(t-&lt;timeStart>):* .     A time variable function is given by  with the (spatial) coefficients   as parameters and the temporal basis functions  . Basis splines are defined as polynomials of degree   in intervals between nodal points in time  , for details see  basis splines . The parameters are ordered timewise. First all parameters of   then   and so on. The total parameter count in each  interval  is  , where   is the count of time points from     in each interval and   is the  degree . The  parameter names  are  *:*:spline.n&lt;degree>:&lt;interval of each spline> .     A time variable function is represented by Legendre polynomials in each  interval . The time is normed to   in each interval. The total parameter count is  , where   is the polynmial degree and   the number of intervals with the  parameter names   *:*:legendrePolynomial.n&lt;degree>:&lt;interval> .     A time variable function is given by a oscillation  with  ,   is  timeStart  and   is  timePeriod  in days. The  parameter names  are  *:*:oscillation.cos(2*pi/&lt;period(days)>*(t-&lt;timeStart>)):*  and  *:*:oscillation.sin(2*pi/&lt;period(days)>*(t-&lt;timeStart>)):* .     A time variable function is given by a fourier expansion  with the normalized time  and   is  timeStart ,   is  timeEnd  in each  interval  and   is the  fourierDegree . The total parameter count is  , where   is the number of intervals. The parameters are sorted in following order:   with the  parameter names   *:*:fourier.cos(&lt;m>*x):&lt;interval>  and  *:*:fourier.sin(&lt;m>*x):&lt;interval> .     The time variable function is given by a fourier expansion  where   are the arguments of the tide constituents    where   are the Doodson\'s fundamental arguments ( ) and   are the Doodson multipliers for the term at frequency  . The multipliers must be given by     coded as Doodson number (e.g. 255.555) or as names intoduced by Darwin (e.g. M2). The major constituents given by     can be used to interpolate minor tidal constituents using the file    . This file can be created with  DoodsonHarmonicsCalculateAdmittance . The total parameter count is   with   the number of doodson frequencies. The parameters are sorted in following order:   with the  parameter names   *:*:doodson.cos(&lt;doodsonName>):*  and  *:*:doodson.sin(&lt;doodsonName>):* .', 'config_table': 'interval timeSeriesType  includeLastTime boolean  timeStart time reference time timeStep time  degree uint degree of splines timeSeries timeSeriesType nodal points in time domain intervals timeSeriesType  includeLastTime boolean  polynomialDegree uint polynomial degree interval timeSeriesType intervals of polynomials includeLastTime boolean  period time [day] time0 time reference time fourierDegree uint  interval timeSeriesType intervals of fourier series includeLastTime boolean  doodson doodson code number (e.g. 255.555) or darwin name (e.g. M2) inputfileAdmittance filename interpolation of minor constituents', 'display_text': 'This class gives a parametrization of time depending parameters (gravity field, positions, ...). It will be used to set up the design matrix in a least squares adjustment. If multiple parametrizations are given the coefficients in the parameter vector are sequently appended.</p><p>Useally time intervals are defined half open meaning the last time belongs not to the interval. This behaviour can be changed for the last interval with <strong class="groops-config-element">includeLastTime</strong>.  <h2 id="constant">Constant</h2><p> Represents a parameter being constant in time in each <strong class="groops-config-element">interval</strong>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:*:*:&lt;interval></code>.  <h2 id="trend">Trend</h2><p> A time variable function is given by a linear trend \\[ f(x,t) = \\frac{1}{T}(t-t_0) \\cdot f_t(x), \\]with $t_0$ is <strong class="groops-config-element">timeStart</strong> and $T$ is <strong class="groops-config-element">timeStep</strong> in days. A constant term is not included and must added separately.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter name</a> is <code>*:*:trend.&lt;timeStep(days)>*(t-&lt;timeStart>):*</code>.  <h2 id="splines">Splines</h2><p> A time variable function is given by \\[ f(x,t) =  \\sum_i f_i(x)\\Psi_i(t), \\]with the (spatial) coefficients $f_i(x)$ as parameters and the temporal basis functions $\\Psi_i(t)$. Basis splines are defined as polynomials of degree $n$ in intervals between nodal points in time $t_i$, for details see <a class="groops-ref" href="fundamentals.basisSplines.html">basis splines</a>.</p><p>The parameters are ordered timewise. First all parameters of $f_{i=1}(x)$ then $f_{i=2}(x)$ and so on. The total parameter count in each <strong class="groops-config-element">interval</strong> is $N=N_t+d-1$, where $N_t$ is the count of time points from <a class="groops-class" href="timeSeriesType.html">timeSeries</a> in each interval and $d$ is the <strong class="groops-config-element">degree</strong>.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:*:spline.n&lt;degree>:&lt;interval of each spline></code>.  <h2>Polynomial</h2><p> A time variable function is represented by Legendre polynomials in each <strong class="groops-config-element">interval</strong>. The time is normed to $[-1,1)$ in each interval.</p><p>The total parameter count is $(N+1)M$, where $N$ is the polynmial degree and $M$ the number of intervals with the <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> <code>*:*:legendrePolynomial.n&lt;degree>:&lt;interval></code>.  <h2>Oscillation</h2><p> A time variable function is given by a oscillation \\[ f(x,t) = f^c(\\M x)\\cos(\\omega_i(t)) + f^s(\\M x)\\sin(\\omega_i(t)) \\]with $\\omega_i=\\frac{2\\pi}{T_i}(t-t_0)$, $t_0$ is <strong class="groops-config-element">timeStart</strong> and $T$ is <strong class="groops-config-element">timePeriod</strong> in days.</p><p>The <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> are <code>*:*:oscillation.cos(2*pi/&lt;period(days)>*(t-&lt;timeStart>)):*</code> and <code>*:*:oscillation.sin(2*pi/&lt;period(days)>*(t-&lt;timeStart>)):*</code>.  <h2>Fourier</h2><p> A time variable function is given by a fourier expansion \\[ f(x,t) = \\sum_{m=1}^M f_m^c(\\M x)\\cos(2\\pi m \\tau) + f_m^s(\\M x)\\sin(2\\pi m \\tau) \\]with the normalized time \\[ \\tau = \\frac{t-t_A}{t_B-t_A}, \\]and $t_A$ is <strong class="groops-config-element">timeStart</strong>, $t_B$ is <strong class="groops-config-element">timeEnd</strong> in each <strong class="groops-config-element">interval</strong> and $M$ is the <strong class="groops-config-element">fourierDegree</strong>.</p><p>The total parameter count is $2MN$, where $N$ is the number of intervals. The parameters are sorted in following order: $f_1^c, f_1^s, f_2^c, \\ldots$ with the <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> <code>*:*:fourier.cos(&lt;m>*x):&lt;interval></code> and <code>*:*:fourier.sin(&lt;m>*x):&lt;interval></code>.  <h2>DoodsonHarmonic</h2><p> The time variable function is given by a fourier expansion \\[   f(x,t) = \\sum_{i} f_i^c(x)\\cos(\\Theta_i(t)) + f_i^s(x)\\sin(\\Theta_i(t)), \\]where $\\Theta_i(t)$ are the arguments of the tide constituents $i$ \\[   \\Theta_i(t) = \\sum_{k=1}^6 n_i^k\\beta_k(t), \\]where $\\beta_k(t)$ are the Doodson\'s fundamental arguments ($\\tau,s,h,p,N\',p_s$) and $n_i^k$ are the Doodson multipliers for the term at frequency $i$. The multipliers must be given by <a class="groops-class" href="doodson.html">doodson</a> coded as Doodson number (e.g. 255.555) or as names intoduced by Darwin (e.g. M2).</p><p>The major constituents given by <a class="groops-class" href="doodson.html">doodson</a> can be used to interpolate minor tidal constituents using the file <a class="groops-class" href="fileFormat_admittance.html">inputfileAdmittance</a>. This file can be created with <a class="groops-program" href="DoodsonHarmonicsCalculateAdmittance.html">DoodsonHarmonicsCalculateAdmittance</a>.</p><p>The total parameter count is $2N$ with $N$ the number of doodson frequencies. The parameters are sorted in following order: $f_1^c, f_1^s, f_2^c, \\ldots$ with the <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a> <code>*:*:doodson.cos(&lt;doodsonName>):*</code> and <code>*:*:doodson.sin(&lt;doodsonName>):*</code>.'},
'planetType': { 'name': 'planetType', 'key': 'planetType', 'description': 'Defines the planet to compute the    .', 'config_table': 'planetType choice planet earth   sun   moon   mercury   venus   mars   jupiter   saturn   uranus   neptune   pluto   solarBaryCenter   earthMoonBaryCenter', 'display_text': 'Defines the planet to compute the <a class="groops-class" href="ephemeridesType.html">ephemeris</a>.'},
'platformSelectorType': { 'name': 'platformSelectorType', 'key': 'platformSelectorType', 'description': 'Select a list of platforms (stations, satellites, ...). See also  GnssProcessing .     Select all platforms.     Select all receivers/transmitters which match the  name ,  markerName , and  markerNumber .     Select receivers/transmitters from each row of    . Additional columns in a row represent alternatives if previous names are not available (e.g. without observation file).     Select all receivers/transmitters except    .', 'config_table': 'name string wildcards: * and ? markerName string wildcards: * and ?, from platform markerNumber string wildcards: * and ?, from platform inputfileStringTable filename list of names with alternatives selector platformSelectorType', 'display_text': 'Select a list of platforms (stations, satellites, ...).</p><p>See also <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>.  <h2 id="all">All</h2><p> Select all platforms.  <h2 id="wildcard">Wildcard</h2><p> Select all receivers/transmitters which match the <strong class="groops-config-element">name</strong>, <strong class="groops-config-element">markerName</strong>, and <strong class="groops-config-element">markerNumber</strong>.  <h2 id="file">File</h2><p> Select receivers/transmitters from each row of <a class="groops-class" href="fileFormat_stringTable.html">inputfileStringTable</a>. Additional columns in a row represent alternatives if previous names are not available (e.g. without observation file).  <h2 id="exclude">Exclude</h2><p> Select all receivers/transmitters except <a class="groops-class" href="platformSelectorType.html">selector</a>.'},
'plotAxisType': { 'name': 'plotAxisType', 'key': 'plotAxisType', 'description': 'Defines the style of the axes of  PlotGraph .     General axis for arbitrary input data.     The input data are interpreted as MJD (modified Julian date). The unit of the tick spacings should be appenend to the number and can be any of    Y (year, plot with 4 digits)  y (year, plot with 2 digits)  O (month, plot using  FORMAT_DATE_MAP )  o (month, plot with 2 digits)  U (ISO week, plot using  FORMAT_DATE_MAP )  u (ISO week, plot using 2 digits)  r (Gregorian week, 7-day stride from start of week  TIME_WEEK_START )  K (ISO weekday, plot name of day)  D (date, plot using  FORMAT_DATE_MAP )  d (day, plot day of month 0-31 or year 1-366, via  FORMAT_DATE_MAP )  R (day, same as d, aligned with  TIME_WEEK_START )  H (hour, plot using  FORMAT_CLOCK_MAP )  h (hour, plot with 2 digits)  M (minute, plot using  FORMAT_CLOCK_MAP )  m (minute, plot with 2 digits)  S (second, plot using  FORMAT_CLOCK_MAP )  s (second, plot with 2 digits).  A secondary time axis can be added to specify larger intervals (e.g dates of hourly data). Examples: Settings for Fig.  :  majorTickSpacing = 6H , secondary:  majorTickSpacing = 1D .  Settings for Fig.  :  majorTickSpacing = 2d , secondary:  majorTickSpacing = 1O ,  options = FORMAT_DATE_MAP="o yyyy" .  Settings for Fig.  :  majorTickSpacing = 1o , secondary:  majorTickSpacing = 1Y ,  options = FORMAT_DATE_MAP="mm" .      Axis with string labels. The coordinate system is based on the label indices (e.g. 0, 1, 2).', 'config_table': 'min double The minimum value of the axis. If no value is given, the minimum scale value is set automatically. max double The maximum value of the axis. If no value is given, the maximum scale value is set automatically. majorTickSpacing double The boundary annotation. minorTickSpacing double The spacing of the frame tick intervals. gridLineSpacing double The spacing of the grid line intervals gridLine plotLineType The style of the grid lines. unit string Naming unit to append to the axis values. label string The description of the axis. logarithmic boolean If set to \'yes\', a logarithmic scale is used for the axis. color plotColorType Setting the color of the axis bars and labels. changeDirection boolean If set to \'yes\', the directions right/up are changed to left/down. min time The minimum value of the time axis. If no value is given, the minimum scale value is set automatically. max time The maximum value of the time axis. If no value is given, the maximum scale value is set automatically. majorTickSpacing string Y: year, o: month minorTickSpacing string D: date, d: day gridLineSpacing string H: clock, h: hour, m: minute, s: second secondary sequence secondary time axis majorTickSpacing string Y: year, o: month minorTickSpacing string D: date, d: day gridLineSpacing string H: clock, h: hour, m: minute, s: second color plotColorType color of axis bars and labels gridLine plotLineType The style of the grid lines. changeDirection boolean right->left / up->down options string adjust date format labels string tick labels (ticks are placed at their index. e.g. 0, 1, ..., 5) min expression minimum value of the axis max expression maximum values of the axis orthogonalLabels boolean labels are oriented orthogonal to axis gridLine plotLineType The style of the grid lines. color plotColorType set the color of the axis and labels changeDirection boolean If set to \'yes\', the directions right/up are changed to left/down.', 'display_text': 'Defines the style of the axes of <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.  <h2>Standard</h2><p> General axis for arbitrary input data.  <h2>Time</h2><p> The input data are interpreted as MJD (modified Julian date). The unit of the tick spacings should be appenend to the number and can be any of <ul>  <li>Y (year, plot with 4 digits) </li><li> y (year, plot with 2 digits) </li><li> O (month, plot using <code>FORMAT_DATE_MAP</code>) </li><li> o (month, plot with 2 digits) </li><li> U (ISO week, plot using <code>FORMAT_DATE_MAP</code>) </li><li> u (ISO week, plot using 2 digits) </li><li> r (Gregorian week, 7-day stride from start of week <code>TIME_WEEK_START</code>) </li><li> K (ISO weekday, plot name of day) </li><li> D (date, plot using <code>FORMAT_DATE_MAP</code>) </li><li> d (day, plot day of month 0-31 or year 1-366, via <code>FORMAT_DATE_MAP</code>) </li><li> R (day, same as d, aligned with <code>TIME_WEEK_START</code>) </li><li> H (hour, plot using <code>FORMAT_CLOCK_MAP</code>) </li><li> h (hour, plot with 2 digits) </li><li> M (minute, plot using <code>FORMAT_CLOCK_MAP</code>) </li><li> m (minute, plot with 2 digits) </li><li> S (second, plot using <code>FORMAT_CLOCK_MAP</code>) </li><li> s (second, plot with 2 digits). </li></ul> </p><p>A secondary time axis can be added to specify larger intervals (e.g dates of hourly data).</p><p>Examples: Settings for Fig. <a href="plotAxisType.html#plotAxisTime1">plotAxisType:plotAxisTime1</a>: <strong class="groops-config-element">majorTickSpacing</strong>=<code>6H</code>, secondary: <strong class="groops-config-element">majorTickSpacing</strong>=<code>1D</code>. </p><p>Settings for Fig. <a href="plotAxisType.html#plotAxisTime2">plotAxisType:plotAxisTime2</a>: <strong class="groops-config-element">majorTickSpacing</strong>=<code>2d</code>, secondary: <strong class="groops-config-element">majorTickSpacing</strong>=<code>1O</code>, <strong class="groops-config-element">options</strong>=<code>FORMAT_DATE_MAP="o yyyy"</code>. </p><p>Settings for Fig. <a href="plotAxisType.html#plotAxisTime3">plotAxisType:plotAxisTime3</a>: <strong class="groops-config-element">majorTickSpacing</strong>=<code>1o</code>, secondary: <strong class="groops-config-element">majorTickSpacing</strong>=<code>1Y</code>, <strong class="groops-config-element">options</strong>=<code>FORMAT_DATE_MAP="mm"</code>. </p><p> <h2>Labeled</h2><p> Axis with string labels. The coordinate system is based on the label indices (e.g. 0, 1, 2).'},
'plotColorType': { 'name': 'plotColorType', 'key': 'plotColorType', 'description': 'Selects a color. Used in  PlotDegreeAmplitudes ,  PlotGraph ,  PlotMap ,  PlotMatrix ,  PlotSphericalHarmonicsTriangle .', 'config_table': 'plotColorType choice color black   red   blue   green   orange   darkred   yellow   lightgreen   gray   rgb sequence  red uint 0..255 green uint 0..255 blue uint 0..255 grayscale sequence  value uint 0..255 namedColor sequence  colorName string name after GMT definition cycler sequence  index uint pick color based on index expression inputfileColorList filename list of colors as defined by GMT', 'display_text': 'Selects a color. Used in <a class="groops-program" href="PlotDegreeAmplitudes.html">PlotDegreeAmplitudes</a>, <a class="groops-program" href="PlotGraph.html">PlotGraph</a>, <a class="groops-program" href="PlotMap.html">PlotMap</a>, <a class="groops-program" href="PlotMatrix.html">PlotMatrix</a>, <a class="groops-program" href="PlotSphericalHarmonicsTriangle.html">PlotSphericalHarmonicsTriangle</a>.</p><p>'},
'plotColorbarType': { 'name': 'plotColorbarType', 'key': 'plotColorbarType', 'description': 'A colorbar as used in  PlotMap ,  PlotMatrix ,  PlotSphericalHarmonicsTriangle .', 'config_table': 'plotColorbarType sequence  min double  max double  annotation double boundary annotation unit string appended to axis values label string description of the axis logarithmic boolean use logarithmic scale triangleLeft boolean  triangleRight boolean  illuminate boolean illuminate vertical boolean plot vertical color bar on the right length double length of colorbar in percent margin double between colorbar and figure [cm] colorTable string name of the color bar reverse boolean reverse direction showColorbar boolean', 'display_text': 'A colorbar as used in <a class="groops-program" href="PlotMap.html">PlotMap</a>, <a class="groops-program" href="PlotMatrix.html">PlotMatrix</a>, <a class="groops-program" href="PlotSphericalHarmonicsTriangle.html">PlotSphericalHarmonicsTriangle</a>.'},
'plotGraphLayerType': { 'name': 'plotGraphLayerType', 'key': 'plotGraphLayerType', 'description': 'Defines the content of an xy-plot of  PlotGraph . Multiple layers are are plotted sequentially. With  plotOnSecondAxis  the alternative y-axis on the right hand side can be selected if provided.     Draws a     and/or points (   ) of xy data. The standard  dataVariables  are available to select the data columns of    . If no     of the     is given a     is required and the color is determined by  valueZ . Additionally a vertical error bar can be plotted at each data point with size  valueErrorBar . See  Gravityfield2AreaMeanTimeSeries  for an example plot.     Draws a symmetrical envelope around  valueY  as function of  valueX  using deviations  valueErrors . The standard  dataVariables  are available to select the data columns of    . The data line itself is not plotted but must be added as extra    .     Creates a bar plot with vertical or  horizontal  bars out of the given x- and y-values. The standard  dataVariables  are available to select the data columns of    . The bars ranges from  valueBase  (can be also an expression) to the  valueY . If no     is given a     is required and the color is determined by  valueZ . See  Instrument2Histogram  for an example plot.     Creates a regular grid of yxz values. The standard  dataVariables  are available to select the data columns of    . Empty grid cells are not plotted. Cells with more than one value will be set to the mean value. The grid spacing is determined by the median spacing of the input data or set by  incrementX/Y . See  Orbit2ArgumentOfLatitude  for an example plot.     Plots a rectangle to highlight an area.     Writes a  text  at  originX  and  originY  position in the graph. With  clip  the text is cutted at the boundaries of the plotting area.     Plot degree amplitudes of potential coefficients computed by  Gravityfield2DegreeAmplitudes  or  PotentialCoefficients2DegreeAmplitudes . The standard  dataVariables  are available to select the data columns of    . It plots a solid line for the  valueSignal  and a dotted line for the  valueError  per default.', 'config_table': 'inputfileMatrix filename each line contains x,y valueX expression expression for x-values (input columns are named data0, data1, ...) valueY expression expression for y-values (input columns are named data0, data1, ...) valueZ expression expression for the colorbar valueErrorBar expression expression for error bars (input columns are named data0, data1, ...) description string text of the legend line plotLineType  symbol plotSymbolType  plotOnSecondAxis boolean draw dataset on a second Y-axis (if available). inputfileMatrix filename each line contains x,y valueX expression expression for x-values (input columns are named data0, data1, ...) valueY expression expression for y-values (input columns are named data0, data1, ...) valueErrors expression expression for error values description string text of the legend fillColor plotColorType fill color of the envelope edgeLine plotLineType edge line style of the envelope plotOnSecondAxis boolean draw dataset on a second Y-axis (if available). inputfileMatrix filename each line contains x,y valueX expression expression for x-values (input columns are named data0, data1, ...) valueY expression expression for y-values (input columns are named data0, data1, ...) valueZ expression expression for the colorbar valueBase expression base value of bars (default: minimum y-value) width expression width of bars (default: minimum x-gap) horizontal boolean draw horizontal bars instead of vertical description string text of the legend color plotColorType  edgeLine plotLineType line plotOnSecondAxis boolean draw dataset on a second Y-axis (if available). inputfileMatrix filename each line contains x,y,z valueX expression expression for x-values (input columns are named data0, data1, ...) valueY expression expression for y-values (input columns are named data0, data1, ...) valueZ expression expression for the colorbar incrementX double the grid spacing incrementY double the grid spacing plotOnSecondAxis boolean draw dataset on a second Y-axis (if available). minX double empty: left maxX double empty: right minY double empty: bottom maxY double empty: top description string text of the legend edgeLine plotLineType  fillColor plotColorType  plotOnSecondAxis boolean draw dataset on a second Y-axis (if available). text string  originX double  originY double  offsetX double [cm] x-offset from origin offsetY double [cm] y-offset from origin alignment string L, C, R (left, center, right) and T, M, B (top, middle, bottom) fontSize double [pt] fontColor plotColorType  clip boolean clip at boundaries plotOnSecondAxis boolean draw dataset on a second Y-axis (if available). inputfileMatrix filename degree amplitudes valueDegree expression expression for x-values (degrees) (input columns are named data0, data1, ...) valueSignal expression expression for y-values (signal) (input columns are named data0, data1, ...) valueErrors expression expression for y-values (formal errors) description string text of the legend lineSignal plotLineType  lineErrors plotLineType  plotOnSecondAxis boolean draw dataset on a second Y-axis (if available).', 'display_text': 'Defines the content of an xy-plot of <a class="groops-program" href="PlotGraph.html">PlotGraph</a>. Multiple layers are are plotted sequentially. With <strong class="groops-config-element">plotOnSecondAxis</strong> the alternative y-axis on the right hand side can be selected if provided.  <h2 id="linesAndPoints">LinesAndPoints</h2><p> Draws a <a class="groops-class" href="plotLineType.html">line</a> and/or points (<a class="groops-class" href="plotSymbolType.html">symbol</a>) of xy data. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data columns of <a class="groops-class" href="fileFormat_matrix.html">inputfileMatrix</a>. If no <a class="groops-class" href="plotColorType.html">color</a> of the <a class="groops-class" href="plotSymbolType.html">symbol</a> is given a <a class="groops-class" href="plotColorbarType.html">colorbar</a> is required and the color is determined by <strong class="groops-config-element">valueZ</strong>. Additionally a vertical error bar can be plotted at each data point with size <strong class="groops-config-element">valueErrorBar</strong>.</p><p>See <a class="groops-program" href="Gravityfield2AreaMeanTimeSeries.html">Gravityfield2AreaMeanTimeSeries</a> for an example plot.  <h2>ErrorEnvelope</h2><p> Draws a symmetrical envelope around <strong class="groops-config-element">valueY</strong> as function of <strong class="groops-config-element">valueX</strong> using deviations <strong class="groops-config-element">valueErrors</strong>. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data columns of <a class="groops-class" href="fileFormat_matrix.html">inputfileMatrix</a>. The data line itself is not plotted but must be added as extra <a class="groops-class" href="plotGraphLayerType.html#linesAndPoints">layer:linesAndPoints</a>.  <h2>Bars</h2><p> Creates a bar plot with vertical or <strong class="groops-config-element">horizontal</strong> bars out of the given x- and y-values. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data columns of <a class="groops-class" href="fileFormat_matrix.html">inputfileMatrix</a>. The bars ranges from <strong class="groops-config-element">valueBase</strong> (can be also an expression) to the <strong class="groops-config-element">valueY</strong>. If no <a class="groops-class" href="plotColorType.html">color</a> is given a <a class="groops-class" href="plotColorbarType.html">colorbar</a> is required and the color is determined by <strong class="groops-config-element">valueZ</strong>.</p><p>See <a class="groops-program" href="Instrument2Histogram.html">Instrument2Histogram</a> for an example plot.  <h2>Gridded</h2><p> Creates a regular grid of yxz values. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data columns of <a class="groops-class" href="fileFormat_matrix.html">inputfileMatrix</a>. Empty grid cells are not plotted. Cells with more than one value will be set to the mean value. The grid spacing is determined by the median spacing of the input data or set by <strong class="groops-config-element">incrementX/Y</strong>.</p><p>See <a class="groops-program" href="Orbit2ArgumentOfLatitude.html">Orbit2ArgumentOfLatitude</a> for an example plot.  <h2>Rectangle</h2><p> Plots a rectangle to highlight an area.  <h2>Text</h2><p> Writes a <strong class="groops-config-element">text</strong> at <strong class="groops-config-element">originX</strong> and <strong class="groops-config-element">originY</strong> position in the graph. With <strong class="groops-config-element">clip</strong> the text is cutted at the boundaries of the plotting area.  <h2>DegreeAmplitudes</h2><p> Plot degree amplitudes of potential coefficients computed by <a class="groops-program" href="Gravityfield2DegreeAmplitudes.html">Gravityfield2DegreeAmplitudes</a> or <a class="groops-program" href="PotentialCoefficients2DegreeAmplitudes.html">PotentialCoefficients2DegreeAmplitudes</a>. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data columns of <a class="groops-class" href="fileFormat_matrix.html">inputfileMatrix</a>. It plots a solid line for the <strong class="groops-config-element">valueSignal</strong> and a dotted line for the <strong class="groops-config-element">valueError</strong> per default.'},
'plotLegendType': { 'name': 'plotLegendType', 'key': 'plotLegendType', 'description': 'Plot a legend of the descriptions provided in     in  PlotGraph .', 'config_table': 'plotLegendType sequence  width double legend width [cm] height double legend height [cm] (default: estimated) positionX double legend x-position in normalized (0-1) coordinates. positionY double legend y-position in normalized (0-1) coordinates. anchorPoint string Two character combination of L, C, R (for left, center, or right) and T, M, B for top, middle, or bottom. e.g., TL for top left columns uint number of columns in legend textColor plotColorType color of the legend text fillColor plotColorType fill color of the legend box edgeLine plotLineType style of the legend box edge', 'display_text': 'Plot a legend of the descriptions provided in <a class="groops-class" href="plotGraphLayerType.html">plotGraphLayer</a> in <a class="groops-program" href="PlotGraph.html">PlotGraph</a>.'},
'plotLineType': { 'name': 'plotLineType', 'key': 'plotLineType', 'description': 'Defines the line style to be plotted.     Draws a solid line.     Draws a dashed line.     Draws a dotted line.     Draws a custom line. The line  style  code is described in  https://docs.generic-mapping-tools.org/latest/cookbook/features.html#specifying-pen-attributes .', 'config_table': 'width double line width [p] color plotColorType  width double line width [p] color plotColorType  width double line width [p] color plotColorType    style string line style code width double line width [p] color plotColorType', 'display_text': 'Defines the line style to be plotted.  <h2>Solid</h2><p> Draws a solid line.  <h2>Dashed</h2><p> Draws a dashed line.  <h2>Dotted</h2><p> Draws a dotted line.  <h2>Custom</h2><p> Draws a custom line. The line <strong class="groops-config-element">style</strong> code is described in <a href="https://docs.generic-mapping-tools.org/latest/cookbook/features.html#specifying-pen-attributes" target="_blank">https://docs.generic-mapping-tools.org/latest/cookbook/features.html#specifying-pen-attributes</a>.'},
'plotMapLayerType': { 'name': 'plotMapLayerType', 'key': 'plotMapLayerType', 'description': 'Defines the content of a map of  PlotMap . Multiple layers are are plotted sequentially.     Creates a regular grid of yxz values. The standard  dataVariables  are available to select the data column of    . Empty grid cells are not plotted. Cells with more than one value will be set to the mean value. The grid spacing can be determined automatically for regular rectangular grids otherwise it must be set with  increment . To get a better display together with some projections the grid should be internally  resample d to higher resolution. It is assumed that the points of     represents centers of grid cells. This assumption can be changed with  gridlineRegistered  (e.g if the data starts at the north pole).     Draws points (   ) and/or    s between the points. If no     of the     is given a     is required and the color is determined by the  value  expression. The standard  dataVariables  are available to select the data column of    .     Draws an arrow for each point in    . The arrows are defined by the expressions  valueNorth/East . The standard  dataVariables  are available to select the correspondent data columns of    . The  scale  factor converts the input units to cm in the plot. If no     is given a     is required and the color is determined by the  value  expression. With  scaleArrow  a reference arrow as legend can be plotted inside or outside the map.     Draws a    . If     is not set and a  value  is given the fill color is taken from a    .     Plots coastlines. GMT provides them in different  resolution s. Features with an area smaller than  minArea  in   will not be plotted.     Plots rivers and lakes. GMT provides different classes ( https://docs.generic-mapping-tools.org/latest/coast.html ).     Plots national boundaries. GMT provides them in different  resolution s.     An image of the Earth\'s surface as seen from outer space - the image is known as  blue marble . The directory of  inputfileChannels  contains several files in different resolutions representing the Earth\'s surface each month throughout a year.      Writes a  text  at  originLongitude  and  originLatitude  position in the map. With  clip  the text is cutted at the boundaries of the plotting area.', 'config_table': 'inputfileGriddedData filename  value expression expression to compute values (input columns are named data0, data1, ...) increment angle the grid spacing [degrees] illuminate boolean illuminate grid resample sequence  intermediateDpi double oversample grid for a smoother visual effect interpolationMethod choice interpolation method for oversampling bspline  B-Spline interpolation bicubic  bicubic interpolation bilinear  bilinear interpolation nearest  nearest neighbour interpolation threshold double A threshold of 1.0 requires all (4 or 16) nodes involved in interpolation to be non-NaN. 0.5 will interpolate about half way from a non-NaN value; 0.1 will go about 90% of the way. gridlineRegistered boolean treat input as point values instead of cell means inputfileGriddedData filename  value expression expression to compute color (input columns are named data0, data1, ...) symbol plotSymbolType  line plotLineType style of connecting lines drawLineAsGreatCircle boolean draw connecting lines as great circles (otherwise, a straight line is drawn instead) inputfileGriddedData filename grid file with north and east values for arrows valueNorth expression expression to compute north values (input columns are named data0, data1, ...) valueEast expression expression to compute east values (input columns are named data0, data1, ...) value expression expression to compute arrow color (input columns are named data0, data1, ...) scale double [cm per input unit] length scale factor penSize double [pt] width of arrow shaft headSize double [pt] size of arrow head, 0: no head, negative: reverse head color plotColorType empty: from value scaleArrow sequence draw an arrow for scale reference originX double [0-1] 0: left, 1: right originY double [0-1] 0: bottom, 1: top length double in same unit as valueNorth and valueEast unit string displayed unit text (e.g. 1 cm) label string description of the arrows inputfilePolygon filename  line plotLineType style of border lines fillColor plotColorType polygon fill color (no fill color: determine from value if given, else: no fill) value double value to compute fill color from a colorbar (ignored if a fillColor is given) drawLineAsGreatCircle boolean draw connecting lines as great circles (otherwise, a straight line is drawn instead) resolution choice  crude   low   medium   high   full   line plotLineType line style for coastlines landColor plotColorType fill land area oceanColor plotColorType fill ocean area minArea uint [km^2] features with a smaller area than this are dropped class choice  riversCanalsLakes   riversCanals   permanentRiversLakes   permanentRivers   intermittentRivers   canals   singleClass sequence  class uint 0-10. See GMT documentation line plotLineType  resolution choice  crude   low   medium   high   full   line plotLineType  inputfileImage filename Blue Marble image file brightness double brightness of bitmap [-1, 1] illuminate sequence add hillshade based on topography inputfileTopography filename GMT grid file containing topography. azimuth angle direction of lighting source [deg] elevation angle direction of lighting source [deg] ambient double ambient lighting diffuse double diffuse lighting specular double specular reflection shine double surface shine amplitude double scale gradient by factor text string  originLongitude angle [deg] originLatitude angle [deg] offsetX double [cm] x-offset from origin offsetY double [cm] y-offset from origin alignment string L, C, R (left, center, right) and T, M, B (top, middle, bottom) fontSize double  fontColor plotColorType  clip boolean clip at boundaries', 'display_text': 'Defines the content of a map of <a class="groops-program" href="PlotMap.html">PlotMap</a>. Multiple layers are are plotted sequentially.  <h2>GriddedData</h2><p> Creates a regular grid of yxz values. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data column of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>. Empty grid cells are not plotted. Cells with more than one value will be set to the mean value. The grid spacing can be determined automatically for regular rectangular grids otherwise it must be set with <strong class="groops-config-element">increment</strong>. To get a better display together with some projections the grid should be internally <strong class="groops-config-element">resample</strong>d to higher resolution. It is assumed that the points of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a> represents centers of grid cells. This assumption can be changed with <strong class="groops-config-element">gridlineRegistered</strong> (e.g if the data starts at the north pole).  <h2 id="points">Points</h2><p> Draws points (<a class="groops-class" href="plotSymbolType.html">symbol</a>) and/or <a class="groops-class" href="plotLineType.html">line</a>s between the points. If no <a class="groops-class" href="plotColorType.html">color</a> of the <a class="groops-class" href="plotSymbolType.html">symbol</a> is given a <a class="groops-class" href="plotColorbarType.html">colorbar</a> is required and the color is determined by the <strong class="groops-config-element">value</strong> expression. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the data column of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>.  <h2>Arrows</h2><p> Draws an arrow for each point in <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>. The arrows are defined by the expressions <strong class="groops-config-element">valueNorth/East</strong>. The standard <a class="groops-ref" href="general.parser.html#dataVariables">dataVariables</a> are available to select the correspondent data columns of <a class="groops-class" href="fileFormat_griddedData.html">inputfileGriddedData</a>. The <strong class="groops-config-element">scale</strong> factor converts the input units to cm in the plot. If no <a class="groops-class" href="plotColorType.html">color</a> is given a <a class="groops-class" href="plotColorbarType.html">colorbar</a> is required and the color is determined by the <strong class="groops-config-element">value</strong> expression. With <strong class="groops-config-element">scaleArrow</strong> a reference arrow as legend can be plotted inside or outside the map.  <h2>Polygon</h2><p> Draws a <a class="groops-class" href="fileFormat_polygon.html">inputfilePolygon</a>. If <a class="groops-class" href="plotColorType.html">fillColor</a> is not set and a <strong class="groops-config-element">value</strong> is given the fill color is taken from a <a class="groops-class" href="plotColorbarType.html">colorbar</a>.  <h2>Coast</h2><p> Plots coastlines. GMT provides them in different <strong class="groops-config-element">resolution</strong>s. Features with an area smaller than <strong class="groops-config-element">minArea</strong> in $km^2$ will not be plotted.  <h2>Rivers</h2><p> Plots rivers and lakes. GMT provides different classes (<a href="https://docs.generic-mapping-tools.org/latest/coast.html" target="_blank">https://docs.generic-mapping-tools.org/latest/coast.html</a>).  <h2>PoliticalBoundary</h2><p> Plots national boundaries. GMT provides them in different <strong class="groops-config-element">resolution</strong>s.  <h2>BlueMarble</h2><p> An image of the Earth\'s surface as seen from outer space - the image is known as <em>blue marble</em>. The directory of <strong class="groops-config-element">inputfileChannels</strong> contains several files in different resolutions representing the Earth\'s surface each month throughout a year.</p><p>  <h2>Text</h2><p> Writes a <strong class="groops-config-element">text</strong> at <strong class="groops-config-element">originLongitude</strong> and <strong class="groops-config-element">originLatitude</strong> position in the map. With <strong class="groops-config-element">clip</strong> the text is cutted at the boundaries of the plotting area.'},
'plotMapProjectionType': { 'name': 'plotMapProjectionType', 'key': 'plotMapProjectionType', 'description': 'Selects the underlying projection of  PlotMap .     The Robinson projection, presented by Arthur H. Robinson in 1963, is a modified cylindrical projection that is neither conformal nor equal-area. Central meridian and all parallels are straight lines; other meridians are curved. It uses lookup tables rather than analytic expressions to make the world map look right.     The orthographic azimuthal projection is a perspective projection from infinite distance. It is therefore often used to give the appearance of a globe viewed from space.     The orthographic azimuthal projection is a perspective projection from infinite distance. It is therefore often used to give the appearance of a globe viewed from space.     Stereographic projection around given central point.     Skyplot used to plot azimuth/elevation data as generated by  GnssAntennaDefinition2Skyplot  or  GnssResiduals2Skyplot .     A particular subset of the transverse Mercator is the Universal Transverse Mercator (UTM) which was adopted by the US Army for large-scale military maps. Here, the globe is divided into 60 zones between 84 S and 84 N, most of which are 6  wide. Each of these UTM zones have their unique central meridian.     This conic projection was designed by Lambert (1772) and has been used extensively for mapping of regions with predominantly east-west orientation.     Linear mapping of longitude/latitude to x/y (Plate Caree).     This pseudo-cylindrical, equal-area projection was developed by Mollweide in 1805. Parallels are unequally spaced straight lines with the meridians being equally spaced elliptical arcs. The scale is only true along latitudes 40 44\' north and south. The projection is used mainly for global maps showing data distributions.', 'config_table': 'centralMeridian angle central meridian [degree] lambdaCenter angle central point [degree] phiCenter angle central point [degree] lambdaCenter angle longitude of central point in degrees phiCenter angle latitude of central point in degrees altitude double [km] azimuth angle to the east of north of view [degrees] tilt angle upward tilt of the plane of projection, if negative, then the view is centered on the horizon [degrees] viewpointTwist angle clockwise twist of the viewpoint [degrees] viewpointWidth angle width of the viewpoint [degrees] viewpointHeight angle height of the viewpoint [degrees] lambdaCenter angle longitude of central point in degrees phiCenter angle latitude of central point in degrees zone string UTM zone code (e.g. 33N) lambda0 angle longitude of projection center [deg] phi0 angle latitude of projection centert [deg] phi1 angle latitude of first standard parallel [deg] phi2 angle latitude of first standard parallel [deg] centralMeridian angle central meridian [degree]', 'display_text': 'Selects the underlying projection of <a class="groops-program" href="PlotMap.html">PlotMap</a>.  <h2>Robinson</h2><p> The Robinson projection, presented by Arthur H. Robinson in 1963, is a modified cylindrical projection that is neither conformal nor equal-area. Central meridian and all parallels are straight lines; other meridians are curved. It uses lookup tables rather than analytic expressions to make the world map look right.  <h2>Orthographic</h2><p> The orthographic azimuthal projection is a perspective projection from infinite distance. It is therefore often used to give the appearance of a globe viewed from space.  <h2>Perspective sphere</h2><p> The orthographic azimuthal projection is a perspective projection from infinite distance. It is therefore often used to give the appearance of a globe viewed from space.  <h2>Polar</h2><p> Stereographic projection around given central point.  <h2>Skyplot</h2><p> Skyplot used to plot azimuth/elevation data as generated by <a class="groops-program" href="GnssAntennaDefinition2Skyplot.html">GnssAntennaDefinition2Skyplot</a> or <a class="groops-program" href="GnssResiduals2Skyplot.html">GnssResiduals2Skyplot</a>.  <h2>UTM</h2><p> A particular subset of the transverse Mercator is the Universal Transverse Mercator (UTM) which was adopted by the US Army for large-scale military maps. Here, the globe is divided into 60 zones between 84$^{o}$S and 84$^{o}$N, most of which are 6$^{o}$ wide. Each of these UTM zones have their unique central meridian.  <h2>Lambert</h2><p> This conic projection was designed by Lambert (1772) and has been used extensively for mapping of regions with predominantly east-west orientation.  <h2>Linear</h2><p> Linear mapping of longitude/latitude to x/y (Plate Caree).  <h2>Mollweide</h2><p> This pseudo-cylindrical, equal-area projection was developed by Mollweide in 1805. Parallels are unequally spaced straight lines with the meridians being equally spaced elliptical arcs. The scale is only true along latitudes 40$^{o}$44\' north and south. The projection is used mainly for global maps showing data distributions.'},
'plotSymbolType': { 'name': 'plotSymbolType', 'key': 'plotSymbolType', 'description': 'Plots a symbol as used e.g. in     or    .', 'config_table': 'plotSymbolType choice symbol circle sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean  star sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean  cross sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean  square sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean  triangle sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean  diamond sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean  dash sequence  color plotColorType empty: determined from value size double size of symbol [point] blackContour boolean', 'display_text': 'Plots a symbol as used e.g. in <a class="groops-class" href="plotGraphLayerType.html#linesAndPoints">plotGraphLayer:linesAndPoints</a> or <a class="groops-class" href="plotMapLayerType.html#points">plotMapLayer:points</a>.'},
'podRightSideType': { 'name': 'podRightSideType', 'key': 'podRightSideType', 'description': 'Observation vector for precise orbit data (POD) of     equations in a least squares adjustment. The observations are reduced by the effect of     and     (observed minus computed).', 'config_table': 'podRightSideType sequence  inputfileOrbit filename kinematic positions of satellite as observations inputfileAccelerometer filename non-gravitational forces in satellite reference frame forces forcesType', 'display_text': 'Observation vector for precise orbit data (POD) of <a class="groops-class" href="observationType.html">observation</a> equations in a least squares adjustment. The observations are reduced by the effect of <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> and <a class="groops-class" href="forcesType.html">forces</a> (observed minus computed).'},
'sggRightSideType': { 'name': 'sggRightSideType', 'key': 'sggRightSideType', 'description': 'Observation vector for gradiometer data (satellite gravity gradiometry, SGG) of     equations in a least squares adjustment. The observations are reduced by an    , the effect of    , and     (observed minus computed). The reference gradiometer data can be precomputed with  SimulateGradiometer .', 'config_table': 'sggRightSideType sequence  inputfileGradiometer filename observed gravity gradients inputfileReferenceGradiometer filename precomputed gradients at orbit positions referencefield gravityfieldType  tides tidesType', 'display_text': 'Observation vector for gradiometer data (satellite gravity gradiometry, SGG) of <a class="groops-class" href="observationType.html">observation</a> equations in a least squares adjustment. The observations are reduced by an <a class="groops-class" href="fileFormat_instrument.html">inputfileReferenceGradiometer</a>, the effect of <a class="groops-class" href="gravityfieldType.html">referencefield</a>, and <a class="groops-class" href="tidesType.html">tides</a> (observed minus computed).</p><p>The reference gradiometer data can be precomputed with <a class="groops-program" href="SimulateGradiometer.html">SimulateGradiometer</a>.'},
'sphericalHarmonicsFilterType': { 'name': 'sphericalHarmonicsFilterType', 'key': 'sphericalHarmonicsFilterType', 'description': 'Filtering of a spherical harmonics expansion.     Orderwise filtering with the DDK filter by Kusche et al. 2009.     Filtering the spherical harmonics expansion with a Gaussian filter.  radius  gives the filter radius on the Earth surface in km.     Filtering the spherical harmonics expansion with a matrix filter.', 'config_table': 'level uint DDK filter level (1, 2, 3, ...) inputfileNormalEquation filename  radius double filter radius [km] inputfileMatrix filename  minDegree uint of matrix maxDegree uint of matrix numbering sphericalHarmonicsNumberingType numbering scheme of the matrix', 'display_text': 'Filtering of a spherical harmonics expansion.  <h2>DDK</h2><p> Orderwise filtering with the DDK filter by Kusche et al. 2009.  <h2>Gauss</h2><p> Filtering the spherical harmonics expansion with a Gaussian filter. <strong class="groops-config-element">radius</strong> gives the filter radius on the Earth surface in km.  <h2>Matrix</h2><p> Filtering the spherical harmonics expansion with a matrix filter.'},
'sphericalHarmonicsNumberingType': { 'name': 'sphericalHarmonicsNumberingType', 'key': 'sphericalHarmonicsNumberingType', 'description': 'This class organizes the numbering scheme of spherical harmonics coefficients in a parameter vector (e.g  Gravityfield2SphericalHarmonicsVector  and the design matrix of    .     Numbering degree by degree:       Numbering order by order:       Numbering order by order with cnm, snm non-alternating:       Numbering as specified in the chosen file. The     is a matrix with the first column indicating cnm/snm with 0 or 1. The second and third column specify degree and order.', 'config_table': 'inputfile filename', 'display_text': 'This class organizes the numbering scheme of spherical harmonics coefficients in a parameter vector (e.g <a class="groops-program" href="Gravityfield2SphericalHarmonicsVector.html">Gravityfield2SphericalHarmonicsVector</a> and the design matrix of <a class="groops-class" href="parametrizationGravityType.html#sphericalHarmonics">parametrizationGravity:sphericalHarmoncis</a>.  <h2>Degree</h2><p> Numbering degree by degree: \\[ c20, c21, s21, c22, s22, c30, c31, s31, c32, s32,\\ldots \\]  <h2>Order</h2><p> Numbering order by order: \\[ c20, c30, c40, \\ldots, c21, s21, c31, s31, \\ldots, c22, s22 \\]  <h2>OrderNonAlternating</h2><p> Numbering order by order with cnm, snm non-alternating: \\[ c20, c30, c40, \\ldots, c21, c31, c41, \\ldots, s21, s31, s41, \\]  <h2>File</h2><p> Numbering as specified in the chosen file. The <a class="groops-class" href="fileFormat_matrix.html">inputfile</a> is a matrix with the first column indicating cnm/snm with 0 or 1. The second and third column specify degree and order.'},
'sstRightSideType': { 'name': 'sstRightSideType', 'key': 'sstRightSideType', 'description': 'Observation vector for GRACE like data (satellite-tracking and precise orbit data (POD)) of     equations in a least squares adjustment. The observations are reduced by the effect of     and     (observed minus computed).', 'config_table': 'sstRightSideType sequence  inputfileSatelliteTracking filename ranging observations and corrections inputfileOrbit1 filename kinematic positions of satellite A as observations inputfileOrbit2 filename kinematic positions of satellite B as observations inputfileAccelerometer1 filename non-gravitational forces in satellite reference frame A inputfileAccelerometer2 filename non-gravitational forces in satellite reference frame B forces forcesType', 'display_text': 'Observation vector for GRACE like data (satellite-tracking and precise orbit data (POD)) of <a class="groops-class" href="observationType.html">observation</a> equations in a least squares adjustment. The observations are reduced by the effect of <a class="groops-class" href="fileFormat_instrument.html">inputfileAccelerometer</a> and <a class="groops-class" href="forcesType.html">forces</a> (observed minus computed).'},
'thermosphereType': { 'name': 'thermosphereType', 'key': 'thermosphereType', 'description': 'This class provides functions for calculating the density, temperature and velocity in the thermosphere. The wind is computed by HWM14 model if  hwm14DataDirectory  is provided. A quiet thermosphere is assumed if  inputfileMagnetic3hAp  is not given.     Thermosphere parameters from the JB2008 model: Bowman, B. R., Tobiska, W. K., Marcos, F. A., Huang, C. Y., Lin, C. S., Burke, W. J. (2008). A new empirical thermospheric density model JB2008 using new solar and geomagnetic indices.  In AIAA/AAS Astrodynamics Specialist Conference and Exhibit.  https://doi.org/10.2514/6.2008-6438      Thermosphere parameters from the NRLMSIS2 model: Emmert J.D, D.P.Drob, J.M. Picone, et al. (2020), NRLMSIS 2.0: A whole-atmosphere empirical model of temperature and neutral species densities. Earth and Space Science, Volume 8, 3  https://doi.org/10.1029/2020EA001321', 'config_table': 'inputfileSolfsmy filename solar indices inputfileDtc filename  inputfileMagnetic3hAp filename indicies for wind model hwm14DataDirectory filename directory containing dwm07b104i.dat, gd2qd.dat, hwm123114.bin inputfileMsis filename input NRLMSIS 2.0 inputfileModelParameters filename path to msis20.parm file inputfileMagnetic3hAp filename indicies for wind model hwm14DataDirectory filename directory containing dwm07b104i.dat, gd2qd.dat, hwm123114.bin', 'display_text': 'This class provides functions for calculating the density, temperature and velocity in the thermosphere. The wind is computed by HWM14 model if <strong class="groops-config-element">hwm14DataDirectory</strong> is provided. A quiet thermosphere is assumed if <strong class="groops-config-element">inputfileMagnetic3hAp</strong> is not given.  <h2>JB2008</h2><p> Thermosphere parameters from the JB2008 model:</p><p>Bowman, B. R., Tobiska, W. K., Marcos, F. A., Huang, C. Y., Lin, C. S., Burke, W. J. (2008). A new empirical thermospheric density model JB2008 using new solar and geomagnetic indices.  In AIAA/AAS Astrodynamics Specialist Conference and Exhibit. <a href="https://doi.org/10.2514/6.2008-6438" target="_blank">https://doi.org/10.2514/6.2008-6438</a>  <h2>NRLMSIS2</h2><p> Thermosphere parameters from the NRLMSIS2 model:</p><p>Emmert J.D, D.P.Drob, J.M. Picone, et al. (2020), NRLMSIS 2.0: A whole-atmosphere empirical model of temperature and neutral species densities. Earth and Space Science, Volume 8, 3 <a href="https://doi.org/10.1029/2020EA001321" target="_blank">https://doi.org/10.1029/2020EA001321</a>'},
'tidesType': { 'name': 'tidesType', 'key': 'tidesType', 'description': 'This class computes functionals of the time depending tide potential, e.g potential, acceleration or gravity gradients. If several instances of the class are given the results are summed up. Before summation every single result is multiplicated by a  factor . To get the difference between two ocean tide models you must choose one factor by 1 and the other by -1. To get the mean of two models just set each factor to 0.5.     This class computes the tide generating potential (TGP) of sun, moon and planets (Mercury, Venus, Mars, Jupiter, Saturn). It takes into account the flattening of the Earth (At the moment only at the acceleration level). The computed result is multiplied with  factor .     This class computes the earth tide according to the IERS2003 conventions. The values of solid Earth tide external potential Love numbers and the frequency dependent corrections of these values are given in the file    . The effect of the permanent tide is removed if  includePermanentTide  is set to false. The computed result is multiplied with  factor .     The potential coefficients of the solid Earth pole tide according to the IERS2003 conventions are given by  with   is the  scale ,   is the  outPhase  and   are the wobble variables in seconds of arc. They are related to the polar motion variables   according to  The mean pole   is approximated by a polynomial read from    . The displacment is calculated with  where   is the  horizontalDisplacement  and   is the  verticalDisplacement . The computed result is multiplied with  factor .     The ocean pole tide is generated by the centrifugal effect of polar motion on the oceans. The potential coefficients of this effect is given by IERS2003 conventions are given by  where the coefficients are read from file    ,   is given by  gammaReal  and  gammaImaginary  and   are the wobble variables in radians. They are related to the polar motion variables   according to  The mean pole   is approximated by a polynomial read from    . The computed result is multiplied with  factor .     The time variable potential of ocean tides is given by a fourier expansion  where   and   are spherical harmonics expansions and are read from the file    . If set the expansion is limited in the range between  minDegree  and  maxDegree  inclusivly.   are the arguments of the tide constituents  :  where   are the Doodson\'s fundamental arguments ( ) and   are the Doodson multipliers for the term at frequency  . The major constituents given by     can be used to interpolate minor tidal constituents using the file    . This file can be created with  DoodsonHarmonicsCalculateAdmittance . After the interpolation step a selection of the computed constituents can be choosen by    . Only these constiuents are considered for the results. If no     is set all constituents will be used. The constituents can be coded as Doodson number (e.g. 255.555) or as names intoduced by Darwin (e.g. M2). The computed result is multiplied with  factor .     Computes the centrifugal potential in a rotating system  The current rotation vector   is computed from the     provided by the calling program. The computed result is multiplied with  factor . Be careful, the centrifugal potential is not harmonic. Convolution with a harmonic kernel (e.g. to compute gravity anomalies) is not meaningful.     This class computes the solid moon tide according to the IERS2010 conventions. The values of solid Moon tide external potential Love numbers are given and there are no frequency dependent corrections of these values. The computed result is multiplied with  factor .     Groups a set of     and has no further effect itself.', 'config_table': 'useMoon boolean TGP of moon useSun boolean TGP of sun usePlanets boolean TGP of planets useEarth boolean TGP of Earth c20Earth double J2 flattening of the Earth factor double the result is multiplied by this factor, set -1 to subtract the field inputfileEarthtide filename  includePermanentTide boolean results in FALSE: zero tide, TRUE: tide free gravity field factor double the result is multiplied by this factor, set -1 to subtract the field scale double  outPhase double  inputfileMeanPole filename  horizontalDisplacement double [m] verticalDisplacement double [m] factor double the result is multiplied by this factor, set -1 to subtract the field inputfileOceanPole filename  minDegree uint  maxDegree uint  gammaReal double  gammaImaginary double  inputfileMeanPole filename  factor double the result is multiplied by this factor, set -1 to subtract the field inputfileTides filename  inputfileAdmittance filename interpolation of minor constituents selectDoodson doodson consider only these constituents, code number (e.g. 255.555) or darwin name (e.g. M2) minDegree uint  maxDegree uint  nodeCorr uint nodal corrections: 0-no corr, 1-IHO, 2-Schureman factor double the result is multiplied by this factor, set -1 to subtract the field factor double the result is multiplied by this factor, set -1 to subtract the field k20 double  k30 double  factor double the result is multiplied by this factor, set -1 to subtract the field tides tidesType  factor double the result is multiplied by this factor', 'display_text': 'This class computes functionals of the time depending tide potential, e.g potential, acceleration or gravity gradients.</p><p>If several instances of the class are given the results are summed up. Before summation every single result is multiplicated by a <strong class="groops-config-element">factor</strong>. To get the difference between two ocean tide models you must choose one factor by 1 and the other by -1. To get the mean of two models just set each factor to 0.5.  <h2 id="astronomicalTide">AstronomicalTide</h2><p> This class computes the tide generating potential (TGP) of sun, moon and planets (Mercury, Venus, Mars, Jupiter, Saturn). It takes into account the flattening of the Earth (At the moment only at the acceleration level).</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="earthTide">EarthTide</h2><p> This class computes the earth tide according to the IERS2003 conventions. The values of solid Earth tide external potential Love numbers and the frequency dependent corrections of these values are given in the file <a class="groops-class" href="fileFormat_earthTide.html">inputfileEarthtide</a>. The effect of the permanent tide is removed if <strong class="groops-config-element">includePermanentTide</strong> is set to false.</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="poleTide">PoleTide</h2><p> The potential coefficients of the solid Earth pole tide according to the IERS2003 conventions are given by \\[ \\begin{split} \\Delta c_{21} &= s\\cdot(m_1 + o\\cdot m_2), \\\\ \\Delta s_{21} &= s\\cdot(m_2 - o\\cdot m_1), \\end{split} \\]with $s$ is the <strong class="groops-config-element">scale</strong>, $o$ is the <strong class="groops-config-element">outPhase</strong> and $(m_1,m_2)$ are the wobble variables in seconds of arc. They are related to the polar motion variables $(x_p,y_p)$ according to \\[ \\begin{split} m_1 &=  (x_p - \\bar{x}_p), \\\\ m_2 &= -(y_p - \\bar{y}_p), \\end{split} \\]The mean pole $(\\bar{x}_p, \\bar{y}_p)$ is approximated by a polynomial read from <a class="groops-class" href="fileFormat_meanPolarMotion.html">inputfileMeanPole</a>.</p><p>The displacment is calculated with \\[ \\begin{split} S_r          &= -v\\sin2\\vartheta(m_1\\cos\\lambda+m_2\\sin\\lambda),\\\\ S_\\vartheta &= -h\\cos2\\vartheta(m_1\\cos\\lambda+m_2\\sin\\lambda),\\\\ S_\\lambda   &=  h\\cos\\vartheta(m_1\\sin\\lambda-m_2\\cos\\lambda), \\end{split} \\]where $h$ is the <strong class="groops-config-element">horizontalDisplacement</strong> and $v$ is the <strong class="groops-config-element">verticalDisplacement</strong>.</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="oceanPoleTide">OceanPoleTide</h2><p> The ocean pole tide is generated by the centrifugal effect of polar motion on the oceans. The potential coefficients of this effect is given by IERS2003 conventions are given by \\[ \\begin{Bmatrix} \\Delta c_{nm}  \\\\ \\Delta s_{nm} \\end{Bmatrix}= \\begin{Bmatrix} c_{nm}^R  \\\\ s_{nm}^R \\end{Bmatrix} (m_1\\gamma^R+m_2\\gamma^I)+ \\begin{Bmatrix} c_{nm}^I  \\\\ s_{nm}^I \\end{Bmatrix} (m_2\\gamma^R-m_1\\gamma^I) \\]where the coefficients are read from file <a class="groops-class" href="fileFormat_oceanPoleTide.html">inputfileOceanPole</a>, $\\gamma=\\gamma^R+i\\gamma^I$ is given by <strong class="groops-config-element">gammaReal</strong> and <strong class="groops-config-element">gammaImaginary</strong> and $(m_1,m_2)$ are the wobble variables in radians. They are related to the polar motion variables $(x_p,y_p)$ according to \\[ \\begin{split} m_1 &=  (x_p - \\bar{x}_p), \\\\ m_2 &= -(y_p - \\bar{y}_p), \\end{split} \\]The mean pole $(\\bar{x}_p, \\bar{y}_p)$ is approximated by a polynomial read from <a class="groops-class" href="fileFormat_meanPolarMotion.html">inputfileMeanPole</a>.</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="doodsonHarmonicTide">DoodsonHarmonicTide</h2><p> The time variable potential of ocean tides is given by a fourier expansion \\[ V(\\M x,t) = \\sum_{f} V_f^c(\\M x)\\cos(\\Theta_f(t)) + V_f^s(\\M x)\\sin(\\Theta_f(t)), \\]where $V_f^c(\\M x)$ and $V_f^s(\\M x)$ are spherical harmonics expansions and are read from the file <a class="groops-class" href="fileFormat_doodsonHarmonic.html">inputfileDoodsonHarmonic</a>. If set the expansion is limited in the range between <strong class="groops-config-element">minDegree</strong> and <strong class="groops-config-element">maxDegree</strong> inclusivly. $\\Theta_f(t)$ are the arguments of the tide constituents $f$: \\[ \\Theta_f(t) = \\sum_{i=1}^6 n_f^i\\beta_i(t), \\]where $\\beta_i(t)$ are the Doodson\'s fundamental arguments ($\\tau,s,h,p,N\',p_s$) and $n_f^i$ are the Doodson multipliers for the term at frequency $f$.</p><p>The major constituents given by <a class="groops-class" href="fileFormat_doodsonHarmonic.html">inputfileDoodsonHarmonic</a> can be used to interpolate minor tidal constituents using the file <a class="groops-class" href="fileFormat_admittance.html">inputfileAdmittance</a>. This file can be created with <a class="groops-program" href="DoodsonHarmonicsCalculateAdmittance.html">DoodsonHarmonicsCalculateAdmittance</a>.</p><p>After the interpolation step a selection of the computed constituents can be choosen by <a class="groops-class" href="doodson.html">selectDoodson</a>. Only these constiuents are considered for the results. If no <a class="groops-class" href="doodson.html">selectDoodson</a> is set all constituents will be used. The constituents can be coded as Doodson number (e.g. 255.555) or as names intoduced by Darwin (e.g. M2).</p><p>The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="centrifugal">Centrifugal</h2><p> Computes the centrifugal potential in a rotating system \\[ V(\\M r, t) = \\frac{1}{2} (\\M\\omega(t)\\times\\M r)^2. \\]The current rotation vector $\\M\\omega(t)$ is computed from the <a class="groops-class" href="earthRotationType.html">earthRotation</a> provided by the calling program. The computed result is multiplied with <strong class="groops-config-element">factor</strong>.</p><p>Be careful, the centrifugal potential is not harmonic. Convolution with a harmonic kernel (e.g. to compute gravity anomalies) is not meaningful.  <h2>SolidMoonTide</h2><p> This class computes the solid moon tide according to the IERS2010 conventions. The values of solid Moon tide external potential Love numbers are given and there are no frequency dependent corrections of these values. The computed result is multiplied with <strong class="groops-config-element">factor</strong>.  <h2 id="group">Group</h2><p> Groups a set of <a class="groops-class" href="tidesType.html">tides</a> and has no further effect itself.'},
'timeSeriesType': { 'name': 'timeSeriesType', 'key': 'timeSeriesType', 'description': 'This class generates a series of points in time. The series is always sorted in ascending order. Depending of the application the series is interpreted as list of points or as intervals between the points.      Generates a time series with uniform sampling. The first point in time will be  timeStart . The last generated point in time will be less or equal  timeEnd . The time step between generated points in time is given by  sampling .     Generates a time series with uniform sampling between  timeStart  and  timeEnd .  intervallCount  gives the count of intervals. This class generates count+1 points in time inclusive  timeStart  and  timeEnd .     The points of the time series are given explicitly with  time .     If  monthMiddle  is set, time points are generated at mid of each month inclusively the  monthStart  in  yearStart  and  monthEnd  in  yearEnd . Otherwise times are given at the first of each month and a time point after the last month.     If  yearMiddle  is set, time points are generated at mid of each year inclusively  yearStart  and  yearEnd . Otherwise times are given at the first of each year and a time point after the last year.     Generates a time series with monthly sampling. The first point in time will be  timeStart  and the following points are generated for each month at the same day and time in month. The last generated point in time will be less or equal  timeEnd .     Generates a time series with yearly sampling. The first point in time will be  timeStart  and the following points are generated for each year at the same day and time in year. The last generated point in time will be less or equal  timeEnd .     Read a time series (epochs) from an  instrument file . The time series can be restricted to the interval starting from  timeStart  and before  timeEnd .     Reconstruct a time series from an  instrument file . The time series is the first epoch of each arc plus one time step beyond the last epoch of the last arc (using median sampling).     Reads an  orbit file  and create a time stamp for each ascending equator crossing. The time series can be restricted to the interval starting from  timeStart  and before  timeEnd .     In a first step a     is generated. In a second step all times are removed which are in range before or after  excludeMargin  seconds of the times given by    .     Only times for which the     is met are included in the time series. The  variableLoopTime  is set to every time and the     is evaluated.     Interpolates  nodeInterpolation  count points between the given     uniformly.', 'config_table': 'timeStart time first point in time timeEnd time last point in time will be less or equal timeEnd sampling time time step between points in time timeStart time 1st point of the time series timeEnd time last point of the time series intervalCount uint count of intervals, count+1 points in time will generated time time explicit list of points in time monthStart uint  yearStart uint  monthEnd uint  yearEnd uint  useMonthMiddle boolean time points are mid of months, otherwise the 1st of each month + a time point behind the last month yearStart uint  yearEnd uint  useYearMiddle boolean time points are mid of years, otherwise the 1st of each year + a time point behind the last year timeStart time first point in time timeEnd time last point in time will be less or equal timeEnd timeStart time first point in time timeEnd time last point in time will be less or equal timeEnd inputfileInstrument filename  timeStart time exclude peochs before this epoch timeEnd time only epochs before this time are used inputfileInstrument filename Must be regular. Time series is first epoch of each arc plus one time step extrapolated from last epoch of last arc. inputfileOrbit filename  timeStart time exclude peochs before this epoch timeEnd time only epochs before this time are used timeSeries timeSeriesType time series to be created timeSeriesExclude timeSeriesType exclude this time points from time series (within margin) excludeMargin double on both sides [seconds] timeSeries timeSeriesType only times for which condition is met will be included variableLoopTime string variable with time of each loop condition conditionType test for each time timeSeries timeSeriesType time series to be created nodeInterpolation uint interpolates count points in each time interval given by the time series', 'display_text': 'This class generates a series of points in time. The series is always sorted in ascending order. Depending of the application the series is interpreted as list of points or as intervals between the points.</p><p>  <h2 id="uniformSampling">UniformSampling</h2><p> Generates a time series with uniform sampling. The first point in time will be <strong class="groops-config-element">timeStart</strong>. The last generated point in time will be less or equal <strong class="groops-config-element">timeEnd</strong>. The time step between generated points in time is given by <strong class="groops-config-element">sampling</strong>.  <h2>UniformInterval</h2><p> Generates a time series with uniform sampling between <strong class="groops-config-element">timeStart</strong> and <strong class="groops-config-element">timeEnd</strong>. <strong class="groops-config-element">intervallCount</strong> gives the count of intervals. This class generates count+1 points in time inclusive <strong class="groops-config-element">timeStart</strong> and <strong class="groops-config-element">timeEnd</strong>.  <h2 id="irregular">Irregular</h2><p> The points of the time series are given explicitly with <strong class="groops-config-element">time</strong>.  <h2>Monthly</h2><p> If <strong class="groops-config-element">monthMiddle</strong> is set, time points are generated at mid of each month inclusively the <strong class="groops-config-element">monthStart</strong> in <strong class="groops-config-element">yearStart</strong> and <strong class="groops-config-element">monthEnd</strong> in <strong class="groops-config-element">yearEnd</strong>. Otherwise times are given at the first of each month and a time point after the last month.  <h2>Yearly</h2><p> If <strong class="groops-config-element">yearMiddle</strong> is set, time points are generated at mid of each year inclusively <strong class="groops-config-element">yearStart</strong> and <strong class="groops-config-element">yearEnd</strong>. Otherwise times are given at the first of each year and a time point after the last year.  <h2>EveryMonth</h2><p> Generates a time series with monthly sampling. The first point in time will be <strong class="groops-config-element">timeStart</strong> and the following points are generated for each month at the same day and time in month. The last generated point in time will be less or equal <strong class="groops-config-element">timeEnd</strong>.  <h2>EveryYear</h2><p> Generates a time series with yearly sampling. The first point in time will be <strong class="groops-config-element">timeStart</strong> and the following points are generated for each year at the same day and time in year. The last generated point in time will be less or equal <strong class="groops-config-element">timeEnd</strong>.  <h2 id="instrument">Instrument</h2><p> Read a time series (epochs) from an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>. The time series can be restricted to the interval starting from <strong class="groops-config-element">timeStart</strong> and before <strong class="groops-config-element">timeEnd</strong>.  <h2>InstrumentArcIntervals</h2><p> Reconstruct a time series from an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a>. The time series is the first epoch of each arc plus one time step beyond the last epoch of the last arc (using median sampling).  <h2>Revolution</h2><p> Reads an <a class="groops-file" href="fileFormat_instrument.html">orbit file</a> and create a time stamp for each ascending equator crossing. The time series can be restricted to the interval starting from <strong class="groops-config-element">timeStart</strong> and before <strong class="groops-config-element">timeEnd</strong>.  <h2>Exclude</h2><p> In a first step a <a class="groops-class" href="timeSeriesType.html">timeSeries</a> is generated. In a second step all times are removed which are in range before or after <strong class="groops-config-element">excludeMargin</strong> seconds of the times given by <a class="groops-class" href="timeSeriesType.html">timeSeriesExclude</a>.  <h2>Conditional</h2><p> Only times for which the <a class="groops-class" href="conditionType.html">condition</a> is met are included in the time series. The <strong class="groops-config-element">variableLoopTime</strong> is set to every time and the <a class="groops-class" href="conditionType.html">condition</a> is evaluated.  <h2>Interpolate</h2><p> Interpolates <strong class="groops-config-element">nodeInterpolation</strong> count points between the given <a class="groops-class" href="timeSeriesType.html">timeSeries</a> uniformly.'},
'troposphereType': { 'name': 'troposphereType', 'key': 'troposphereType', 'description': 'This class provides functions for calculating and estimating the signal delay in the dry and wet atmosphere.    Tropospheric delays based on the Vienna Mapping Functions 3 (VMF3) model (Landskron and Boehm 2017, DOI:  ). Hydrostatic and wet mapping function coefficients ( ,  ) and zenith delays (ZHD, ZWD) have to be provided via    . This file can contain either station-specific data (see  ViennaMappingFunctionStation2File ) or data on a regular global grid (see  ViennaMappingFunctionGrid2File ). In the second case mapping coefficients and zenith delays are interpolated to the requested coordinates. This includes a height correction that requires approximate meteorological data provided via    .    Tropospheric delays based on the Global Pressure and Temperature 3 (GPT3) model (Landskron and Boehm 2017, DOI:  ). It is an empirical model derived from the Vienna Mapping Functions 3 (VMF3, see    ) and thus does not require additional mapping coefficients and zenith delay values.', 'config_table': 'inputfileVmfCoefficients filename ah, aw, zhd, zwd coefficients inputfileGpt filename gridded GPT data aHeight double parameter a (height correction) bHeight double parameter b (height correction) cHeight double parameter c (height correction) inputfileGpt filename gridded GPT data aHeight double parameter a (height correction) bHeight double parameter b (height correction) cHeight double parameter c (height correction)', 'display_text': 'This class provides functions for calculating and estimating the signal delay in the dry and wet atmosphere.  <h2 id="viennaMapping">ViennaMapping</h2><p></p><p>Tropospheric delays based on the Vienna Mapping Functions 3 (VMF3) model (Landskron and Boehm 2017, DOI: <a href="https://doi.org/10.1007/s00190-017-1066-2">10.1007/s00190-017-1066-2</a>).</p><p>Hydrostatic and wet mapping function coefficients ($a_h$, $a_w$) and zenith delays (ZHD, ZWD) have to be provided via <a class="groops-class" href="fileFormat_griddedDataTimeSeries.html">inputfileVmfCoefficients</a>. This file can contain either station-specific data (see <a class="groops-program" href="ViennaMappingFunctionStation2File.html">ViennaMappingFunctionStation2File</a>) or data on a regular global grid (see <a class="groops-program" href="ViennaMappingFunctionGrid2File.html">ViennaMappingFunctionGrid2File</a>). In the second case mapping coefficients and zenith delays are interpolated to the requested coordinates. This includes a height correction that requires approximate meteorological data provided via <a class="groops-class" href="fileFormat_griddedData.html">inputfileGpt</a>.  <h2 id="gpt">GPT</h2><p></p><p>Tropospheric delays based on the Global Pressure and Temperature 3 (GPT3) model (Landskron and Boehm 2017, DOI: <a href="https://doi.org/10.1007/s00190-017-1066-2">10.1007/s00190-017-1066-2</a>).</p><p>It is an empirical model derived from the Vienna Mapping Functions 3 (VMF3, see <a class="groops-class" href="troposphereType.html#viennaMapping">viennaMapping</a>) and thus does not require additional mapping coefficients and zenith delay values.'},
'general.fileFormat': { 'name': 'general.fileFormat', 'key': 'general.fileFormat', 'description': 'All GROOPS files are written either in XML, binary, or ASCII format depending on the filename extension.    .xml : XML format  .dat : binary format  .txt  and all other extensions: ASCII format  With an additional extension of \' .gz \' files are directly compressed and uncompressed. It is also possible to directly uncompress and read (but not write)  \'d files (\' .Z \'). Comments are allowed in ASCII files and all the text starting from the character \' # \' to the end of the line is ignored. The program  FileConvert  can be used to convert between the different formats. This program is also useful to get some general information of files in binary format. The following special file types are used in GROOPS:', 'config_table': '', 'display_text': 'All GROOPS files are written either in XML, binary, or ASCII format depending on the filename extension. <ul>  <li><code>.xml</code>: XML format </li><li> <code>.dat</code>: binary format </li><li> <code>.txt</code> and all other extensions: ASCII format </li></ul> </p><p>With an additional extension of \'<code>.gz</code>\' files are directly compressed and uncompressed. It is also possible to directly uncompress and read (but not write) <a href="https://en.wikipedia.org/wiki/Compress">Unix compress</a>\'d files (\'<code>.Z</code>\').</p><p>Comments are allowed in ASCII files and all the text starting from the character \'<code>#</code>\' to the end of the line is ignored.</p><p>The program <a class="groops-program" href="FileConvert.html">FileConvert</a> can be used to convert between the different formats. This program is also useful to get some general information of files in binary format.</p><p>The following special file types are used in GROOPS:'},
'fileFormat_admittance': { 'name': 'Admittance', 'key': 'fileFormat_admittance', 'description': 'Interpolation matrix to create ocean minor tides from modeled major tides. The file can be created with  DoodsonHarmonicsCalculateAdmittance  and used e.g. in   Interpolation matrix to create ocean minor tides from modeled major tides. The file can be created with  . See  DoodsonHarmonicsCalculateAdmittance .', 'config_table': '', 'display_text': 'Interpolation matrix to create ocean minor tides from modeled major tides. The file can be created with <a class="groops-program" href="DoodsonHarmonicsCalculateAdmittance.html">DoodsonHarmonicsCalculateAdmittance</a> and used e.g. in <a class="groops-class" href="tidesType.html#doodsonHarmonicTide">doodsonHarmonicTide</a>.</p><p>See <a class="groops-program" href="DoodsonHarmonicsCalculateAdmittance.html">DoodsonHarmonicsCalculateAdmittance</a>.'},
'fileFormat_arcList': { 'name': 'ArcList', 'key': 'fileFormat_arcList', 'description': 'With the  InstrumentSynchronize  an  instrument file  can be divided into time intervals and within the intervals into arcs. This file provides the information about the mapping of arcs to time intervals. This file can be used for the variational equation approach or  KalmanBuildNormals .  groops arclist version=20200123          32  # number of times # time [MJD]               first arc # ==================================  58909.000000000000000000          0  58910.000000000000000000          8  58911.000000000000000000         17  58912.000000000000000000         25  58913.000000000000000000         29  58914.000000000000000000         37  58915.000000000000000000         45  58916.000000000000000000         53  58917.000000000000000000         61  58918.000000000000000000         69  58919.000000000000000000         78  58920.000000000000000000         86  58921.000000000000000000         95  58922.000000000000000000        103  58923.000000000000000000        112  58924.000000000000000000        120  58925.000000000000000000        128  58926.000000000000000000        136  58927.000000000000000000        144  58928.000000000000000000        153  58929.000000000000000000        161  58930.000000000000000000        169  58931.000000000000000000        177  58932.000000000000000000        185  58933.000000000000000000        193  58934.000000000000000000        201  58935.000000000000000000        210  58936.000000000000000000        218  58937.000000000000000000        226  58938.000000000000000000        234  58939.000000000000000000        242  58940.000000000000000000        250', 'config_table': '', 'display_text': 'With the <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a> an <a class="groops-file" href="fileFormat_instrument.html">instrument file</a> can be divided into time intervals and within the intervals into arcs. This file provides the information about the mapping of arcs to time intervals.</p><p>This file can be used for the variational equation approach or <a class="groops-program" href="KalmanBuildNormals.html">KalmanBuildNormals</a>.</p><p><pre> groops arclist version=20200123          32  # number of times # time [MJD]               first arc # ==================================  58909.000000000000000000          0  58910.000000000000000000          8  58911.000000000000000000         17  58912.000000000000000000         25  58913.000000000000000000         29  58914.000000000000000000         37  58915.000000000000000000         45  58916.000000000000000000         53  58917.000000000000000000         61  58918.000000000000000000         69  58919.000000000000000000         78  58920.000000000000000000         86  58921.000000000000000000         95  58922.000000000000000000        103  58923.000000000000000000        112  58924.000000000000000000        120  58925.000000000000000000        128  58926.000000000000000000        136  58927.000000000000000000        144  58928.000000000000000000        153  58929.000000000000000000        161  58930.000000000000000000        169  58931.000000000000000000        177  58932.000000000000000000        185  58933.000000000000000000        193  58934.000000000000000000        201  58935.000000000000000000        210  58936.000000000000000000        218  58937.000000000000000000        226  58938.000000000000000000        234  58939.000000000000000000        242  58940.000000000000000000        250 </pre>'},
'fileFormat_doodsonEarthOrientationParameter': { 'name': 'DoodsonEarthOrientationParameter', 'key': 'fileFormat_doodsonEarthOrientationParameter', 'description': 'Corrections for Earth orientation parameters (EOP) ( ) as cos/sin oscillations for a list of doodson tidal frequencies.  groops doodsonEarthOrientationParameter version=20200123         11 # number of constituents # dood.   xpCos [arcsec]            xpSin [arcsec]            ypCos [arcsec]            ypSin [arcsec]            ut1Cos [sec]              ut1Sin [sec]              lodCos [sec]              lodSin [sec]             name # ===========================================================================================================================================================================================================================  155.645  2.399999999999999786e-07  1.799999999999999971e-07  1.799999999999999971e-07 -2.399999999999999786e-07 -2.000000000000000042e-08  2.000000000000000042e-08 -1.499999999999999932e-07 -1.400000000000000095e-07 ""  155.655 -8.220000000000000920e-06 -6.280000000000000012e-06 -6.280000000000000012e-06  8.220000000000000920e-06  7.899999999999999537e-07 -8.599999999999999187e-07  5.219999999999999150e-06  4.829999999999999496e-06 m1  155.665 -1.649999999999999872e-06 -1.260000000000000007e-06 -1.260000000000000007e-06  1.649999999999999872e-06  1.600000000000000033e-07 -1.700000000000000135e-07  1.049999999999999900e-06  9.700000000000000302e-07 ""  157.455 -1.539999999999999867e-06 -1.199999999999999946e-06 -1.199999999999999946e-06  1.539999999999999867e-06  1.499999999999999932e-07 -1.600000000000000033e-07  9.799999999999999345e-07  8.899999999999999491e-07 chi1  157.465 -3.400000000000000270e-07 -2.599999999999999988e-07 -2.599999999999999988e-07  3.400000000000000270e-07  2.999999999999999732e-08 -4.000000000000000084e-08  2.099999999999999746e-07  1.999999999999999909e-07 ""  161.557  9.999999999999999547e-08  8.000000000000000167e-08  8.000000000000000167e-08 -9.999999999999999547e-08 -1.000000000000000021e-08  1.000000000000000021e-08 -7.000000000000000477e-08 -4.999999999999999774e-08 ""  162.556  2.549999999999999726e-06  2.019999999999999718e-06  2.019999999999999718e-06 -2.549999999999999726e-06 -2.099999999999999746e-07  2.899999999999999763e-07 -1.799999999999999919e-06 -1.289999999999999931e-06 pi1  163.545 -4.899999999999999672e-07 -3.799999999999999616e-07 -3.799999999999999616e-07  4.899999999999999672e-07  4.000000000000000084e-08 -5.999999999999999464e-08  3.499999999999999842e-07  2.399999999999999786e-07 ""  163.555  4.272999999999999238e-05  3.010999999999999801e-05  3.010999999999999801e-05 -4.272999999999999238e-05 -3.079999999999999734e-06  5.219999999999999150e-06 -3.270999999999999684e-05 -1.929999999999999817e-05 p1  164.554 -3.599999999999999943e-07 -2.800000000000000191e-07 -2.800000000000000191e-07  3.599999999999999943e-07  2.999999999999999732e-08 -4.000000000000000084e-08  2.700000000000000090e-07  1.700000000000000135e-07 ""  164.556 -1.029999999999999879e-06 -7.999999999999999638e-07 -7.999999999999999638e-07  1.029999999999999879e-06  8.000000000000000167e-08 -1.199999999999999893e-07  7.599999999999999233e-07  4.899999999999999672e-07 ""', 'config_table': '', 'display_text': 'Corrections for Earth orientation parameters (EOP) ($x_p, y_p, UT1, LOD$) as cos/sin oscillations for a list of doodson tidal frequencies.</p><p><pre> groops doodsonEarthOrientationParameter version=20200123         11 # number of constituents # dood.   xpCos [arcsec]            xpSin [arcsec]            ypCos [arcsec]            ypSin [arcsec]            ut1Cos [sec]              ut1Sin [sec]              lodCos [sec]              lodSin [sec]             name # ===========================================================================================================================================================================================================================  155.645  2.399999999999999786e-07  1.799999999999999971e-07  1.799999999999999971e-07 -2.399999999999999786e-07 -2.000000000000000042e-08  2.000000000000000042e-08 -1.499999999999999932e-07 -1.400000000000000095e-07 ""  155.655 -8.220000000000000920e-06 -6.280000000000000012e-06 -6.280000000000000012e-06  8.220000000000000920e-06  7.899999999999999537e-07 -8.599999999999999187e-07  5.219999999999999150e-06  4.829999999999999496e-06 m1  155.665 -1.649999999999999872e-06 -1.260000000000000007e-06 -1.260000000000000007e-06  1.649999999999999872e-06  1.600000000000000033e-07 -1.700000000000000135e-07  1.049999999999999900e-06  9.700000000000000302e-07 ""  157.455 -1.539999999999999867e-06 -1.199999999999999946e-06 -1.199999999999999946e-06  1.539999999999999867e-06  1.499999999999999932e-07 -1.600000000000000033e-07  9.799999999999999345e-07  8.899999999999999491e-07 chi1  157.465 -3.400000000000000270e-07 -2.599999999999999988e-07 -2.599999999999999988e-07  3.400000000000000270e-07  2.999999999999999732e-08 -4.000000000000000084e-08  2.099999999999999746e-07  1.999999999999999909e-07 ""  161.557  9.999999999999999547e-08  8.000000000000000167e-08  8.000000000000000167e-08 -9.999999999999999547e-08 -1.000000000000000021e-08  1.000000000000000021e-08 -7.000000000000000477e-08 -4.999999999999999774e-08 ""  162.556  2.549999999999999726e-06  2.019999999999999718e-06  2.019999999999999718e-06 -2.549999999999999726e-06 -2.099999999999999746e-07  2.899999999999999763e-07 -1.799999999999999919e-06 -1.289999999999999931e-06 pi1  163.545 -4.899999999999999672e-07 -3.799999999999999616e-07 -3.799999999999999616e-07  4.899999999999999672e-07  4.000000000000000084e-08 -5.999999999999999464e-08  3.499999999999999842e-07  2.399999999999999786e-07 ""  163.555  4.272999999999999238e-05  3.010999999999999801e-05  3.010999999999999801e-05 -4.272999999999999238e-05 -3.079999999999999734e-06  5.219999999999999150e-06 -3.270999999999999684e-05 -1.929999999999999817e-05 p1  164.554 -3.599999999999999943e-07 -2.800000000000000191e-07 -2.800000000000000191e-07  3.599999999999999943e-07  2.999999999999999732e-08 -4.000000000000000084e-08  2.700000000000000090e-07  1.700000000000000135e-07 ""  164.556 -1.029999999999999879e-06 -7.999999999999999638e-07 -7.999999999999999638e-07  1.029999999999999879e-06  8.000000000000000167e-08 -1.199999999999999893e-07  7.599999999999999233e-07  4.899999999999999672e-07 "" </pre>'},
'fileFormat_doodsonHarmonic': { 'name': 'DoodsonHarmonic', 'key': 'fileFormat_doodsonHarmonic', 'description': 'Ocean tides are represented as time variable gravitational potential and is given by a fourier expansion  where   and   are spherical harmonics. The   are the arguments of the tide constituents  :  where   are the Doodson\'s fundamental arguments ( ) and   are the Doodson multipliers for the term at frequency  . To extract the potential coefficients of   and   for each frequency   use  DoodsonHarmonics2PotentialCoefficients . See also  PotentialCoefficients2DoodsonHarmonics .', 'config_table': '', 'display_text': 'Ocean tides are represented as time variable gravitational potential and is given by a fourier expansion \\[ V(\\M x,t) = \\sum_{f} V_f^c(\\M x)\\cos(\\Theta_f(t)) + V_f^s(\\M x)\\sin(\\Theta_f(t)), \\]where $V_f^c(\\M x)$ and $V_f^s(\\M x)$ are spherical harmonics. The $\\Theta_f(t)$ are the arguments of the tide constituents $f$: \\[ \\Theta_f(t) = \\sum_{i=1}^6 n_f^i\\beta_i(t), \\]where $\\beta_i(t)$ are the Doodson\'s fundamental arguments ($\\tau,s,h,p,N\',p_s$) and $n_f^i$ are the Doodson multipliers for the term at frequency $f$.</p><p>To extract the potential coefficients of $V_f^c$ and $V_f^s$ for each frequency $f$ use <a class="groops-program" href="DoodsonHarmonics2PotentialCoefficients.html">DoodsonHarmonics2PotentialCoefficients</a>.</p><p>See also <a class="groops-program" href="PotentialCoefficients2DoodsonHarmonics.html">PotentialCoefficients2DoodsonHarmonics</a>.'},
'fileFormat_earthOrientationParameter': { 'name': 'EarthOrientationParameter', 'key': 'fileFormat_earthOrientationParameter', 'description': 'Earth Orientation Parameter (EOP) as provided by the International Earth Rotation and Reference Systems Service (IERS) (e.g  EOP 14 C04 (IAU2000A) ). See  IersC04IAU2000EarthOrientationParameter ,  IersRapidIAU2000EarthOrientationParameter .  groops earthOrientationParameter version=20200123        9641 # number of epochs # UTC [MJD]                 xp [arcsec]               yp [arcsec]               deltUT [sec]              LOD [sec]                 dX [arcsec]               dY [arcsec] # ====================================================================================================================================================================================   5.894700000000000000e+04  5.690599999999999825e-02  4.099130000000000273e-01 -2.316246000000000138e-01  1.636400000000000094e-03 -2.900000000000000017e-05  5.800000000000000034e-05   5.894800000000000000e+04  5.771400000000000141e-02  4.110159999999999925e-01 -2.332083000000000073e-01  1.520099999999999923e-03 -6.000000000000000152e-05  2.199999999999999943e-05   5.894900000000000000e+04  5.813000000000000111e-02  4.120099999999999874e-01 -2.346157000000000104e-01  1.293099999999999935e-03 -7.200000000000000182e-05  3.199999999999999855e-05   5.895000000000000000e+04  5.854100000000000276e-02  4.129849999999999910e-01 -2.357567999999999886e-01  9.872999999999999832e-04 -7.600000000000000418e-05  5.899999999999999754e-05   5.895100000000000000e+04  5.908599999999999963e-02  4.139869999999999939e-01 -2.366149999999999920e-01  7.075000000000000126e-04 -8.000000000000000654e-05  8.600000000000000331e-05   5.895200000000000000e+04  5.976900000000000268e-02  4.154180000000000095e-01 -2.372105999999999937e-01  4.798000000000000073e-04 -8.399999999999999535e-05  1.129999999999999955e-04   5.895300000000000000e+04  6.095400000000000124e-02  4.167310000000000181e-01 -2.375994999999999913e-01  3.118999999999999919e-04 -8.700000000000000051e-05  1.399999999999999877e-04   5.895400000000000000e+04  6.210199999999999748e-02  4.180929999999999924e-01 -2.378588000000000091e-01  1.710000000000000094e-04 -9.100000000000000287e-05  1.669999999999999935e-04   5.895500000000000000e+04  6.290999999999999370e-02  4.196619999999999795e-01 -2.380454999999999932e-01  1.719000000000000042e-04 -6.000000000000000152e-06  8.100000000000000375e-05   5.895600000000000000e+04  6.385599999999999610e-02  4.214060000000000028e-01 -2.382557999999999898e-01  2.683000000000000163e-04  1.029999999999999964e-04 -3.600000000000000091e-05   5.895700000000000000e+04  6.455500000000000127e-02  4.229890000000000039e-01 -2.385857000000000117e-01  4.040000000000000080e-04  1.019999999999999992e-04 -2.000000000000000164e-05   5.895800000000000000e+04  6.440300000000000191e-02  4.242549999999999932e-01 -2.390210000000000112e-01  4.910999999999999567e-04  5.899999999999999754e-05  4.399999999999999886e-05', 'config_table': '', 'display_text': 'Earth Orientation Parameter (EOP) as provided by the International Earth Rotation and Reference Systems Service (IERS) (e.g <code>EOP 14 C04 (IAU2000A)</code>).</p><p>See <a class="groops-program" href="IersC04IAU2000EarthOrientationParameter.html">IersC04IAU2000EarthOrientationParameter</a>, <a class="groops-program" href="IersRapidIAU2000EarthOrientationParameter.html">IersRapidIAU2000EarthOrientationParameter</a>.</p><p><pre> groops earthOrientationParameter version=20200123        9641 # number of epochs # UTC [MJD]                 xp [arcsec]               yp [arcsec]               deltUT [sec]              LOD [sec]                 dX [arcsec]               dY [arcsec] # ====================================================================================================================================================================================   5.894700000000000000e+04  5.690599999999999825e-02  4.099130000000000273e-01 -2.316246000000000138e-01  1.636400000000000094e-03 -2.900000000000000017e-05  5.800000000000000034e-05   5.894800000000000000e+04  5.771400000000000141e-02  4.110159999999999925e-01 -2.332083000000000073e-01  1.520099999999999923e-03 -6.000000000000000152e-05  2.199999999999999943e-05   5.894900000000000000e+04  5.813000000000000111e-02  4.120099999999999874e-01 -2.346157000000000104e-01  1.293099999999999935e-03 -7.200000000000000182e-05  3.199999999999999855e-05   5.895000000000000000e+04  5.854100000000000276e-02  4.129849999999999910e-01 -2.357567999999999886e-01  9.872999999999999832e-04 -7.600000000000000418e-05  5.899999999999999754e-05   5.895100000000000000e+04  5.908599999999999963e-02  4.139869999999999939e-01 -2.366149999999999920e-01  7.075000000000000126e-04 -8.000000000000000654e-05  8.600000000000000331e-05   5.895200000000000000e+04  5.976900000000000268e-02  4.154180000000000095e-01 -2.372105999999999937e-01  4.798000000000000073e-04 -8.399999999999999535e-05  1.129999999999999955e-04   5.895300000000000000e+04  6.095400000000000124e-02  4.167310000000000181e-01 -2.375994999999999913e-01  3.118999999999999919e-04 -8.700000000000000051e-05  1.399999999999999877e-04   5.895400000000000000e+04  6.210199999999999748e-02  4.180929999999999924e-01 -2.378588000000000091e-01  1.710000000000000094e-04 -9.100000000000000287e-05  1.669999999999999935e-04   5.895500000000000000e+04  6.290999999999999370e-02  4.196619999999999795e-01 -2.380454999999999932e-01  1.719000000000000042e-04 -6.000000000000000152e-06  8.100000000000000375e-05   5.895600000000000000e+04  6.385599999999999610e-02  4.214060000000000028e-01 -2.382557999999999898e-01  2.683000000000000163e-04  1.029999999999999964e-04 -3.600000000000000091e-05   5.895700000000000000e+04  6.455500000000000127e-02  4.229890000000000039e-01 -2.385857000000000117e-01  4.040000000000000080e-04  1.019999999999999992e-04 -2.000000000000000164e-05   5.895800000000000000e+04  6.440300000000000191e-02  4.242549999999999932e-01 -2.390210000000000112e-01  4.910999999999999567e-04  5.899999999999999754e-05  4.399999999999999886e-05 </pre>'},
'fileFormat_earthTide': { 'name': 'EarthTide', 'key': 'fileFormat_earthTide', 'description': 'Containing the Love numbers together with frequency corrections to compute the gravitational potential and the geometric displacements due to solid Earth tides. It is used by   Containing the Love numbers together with frequency corrections to compute the gravitational potential and the geometric displacements due to solid Earth tides. It is used by  .', 'config_table': '', 'display_text': 'Containing the Love numbers together with frequency corrections to compute the gravitational potential and the geometric displacements due to solid Earth tides. It is used by <a class="groops-class" href="tidesType.html">tides</a>.'},
'fileFormat_ephemerides': { 'name': 'Ephemerides', 'key': 'fileFormat_ephemerides', 'description': 'Ephemerides of sun, moon, and planets stored as coefficients of Chebyshev polynomials. Used in   Ephemerides of sun, moon, and planets stored as coefficients of Chebyshev polynomials. Used in  . See also  JplAscii2Ephemerides .', 'config_table': '', 'display_text': 'Ephemerides of sun, moon, and planets stored as coefficients of Chebyshev polynomials. Used in <a class="groops-class" href="ephemeridesType.html#jpl">Ephemerides:jpl</a>.</p><p>See also <a class="groops-program" href="JplAscii2Ephemerides.html">JplAscii2Ephemerides</a>.'},
'fileFormat_gnssAntennaDefinition': { 'name': 'GnssAntennaDefinition', 'key': 'fileFormat_gnssAntennaDefinition', 'description': 'Contains a list of GNSS antennas which are identified by its name (type), serial, and radome. Each antenna consists of antenna center offsets (ACO) and antenna center variations (ACV) for different signal   Contains a list of GNSS antennas which are identified by its name (type), serial, and radome. Each antenna consists of antenna center offsets (ACO) and antenna center variations (ACV) for different signal   (code and phase). The ACV values for each type are stored in an elevation and azimuth dependent grid.     See also  GnssAntennaDefinitionCreate ,  GnssAntex2AntennaDefinition .  &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="antennaDefinition" version="20190429">     &lt;antennaCount>65&lt;/antennaCount>     ...     &lt;antenna>         &lt;name>BLOCK IIIA&lt;/name>         &lt;serial>G074&lt;/serial>         &lt;radome>2018-109A&lt;/radome>         &lt;comment>PCO provided by the Aerospace Corporation, PV from estimations by ESA/CODE&lt;/comment>         &lt;pattern>             &lt;count>3&lt;/count>             &lt;cell>                 &lt;type>*1*G**&lt;/type>                 &lt;offset>                     &lt;x>-1.23333333333333e-03&lt;/x>                     &lt;y>4.33333333333333e-04&lt;/y>                     &lt;z>3.15200000000000e-01&lt;/z>                 &lt;/offset>                 &lt;dZenit>1.00000000000000e+00&lt;/dZenit>                 &lt;pattern>                     &lt;type>0&lt;/type>                     &lt;rows>1&lt;/rows>                     &lt;columns>18&lt;/columns>                     &lt;cell row="0" col="0">1.39000000000000e-02&lt;/cell>                     &lt;cell row="0" col="1">1.28000000000000e-02&lt;/cell>                     &lt;cell row="0" col="2">1.02000000000000e-02&lt;/cell>                     &lt;cell row="0" col="3">5.80000000000000e-03&lt;/cell>                     &lt;cell row="0" col="4">1.10000000000000e-03&lt;/cell>                     &lt;cell row="0" col="5">-4.50000000000000e-03&lt;/cell>                     &lt;cell row="0" col="6">-9.70000000000000e-03&lt;/cell>                     &lt;cell row="0" col="7">-1.28000000000000e-02&lt;/cell>                     &lt;cell row="0" col="8">-1.34000000000000e-02&lt;/cell>                     &lt;cell row="0" col="9">-1.18000000000000e-02&lt;/cell>                     &lt;cell row="0" col="10">-8.90000000000000e-03&lt;/cell>                     &lt;cell row="0" col="11">-4.50000000000000e-03&lt;/cell>                     &lt;cell row="0" col="12">1.20000000000000e-03&lt;/cell>                     &lt;cell row="0" col="13">7.20000000000000e-03&lt;/cell>                     &lt;cell row="0" col="14">1.33000000000000e-02&lt;/cell>                     &lt;cell row="0" col="15">1.33000000000000e-02&lt;/cell>                     &lt;cell row="0" col="16">1.33000000000000e-02&lt;/cell>                     &lt;cell row="0" col="17">1.33000000000000e-02&lt;/cell>                 &lt;/pattern>             &lt;/cell>             ...         &lt;/pattern>     &lt;/antenna> &lt;/groops>', 'config_table': '', 'display_text': 'Contains a list of GNSS antennas which are identified by its name (type), serial, and radome. Each antenna consists of antenna center offsets (ACO) and antenna center variations (ACV) for different signal <a class="groops-class" href="gnssType.html">types</a> (code and phase). The ACV values for each type are stored in an elevation and azimuth dependent grid.</p><p>  </p><p>See also <a class="groops-program" href="GnssAntennaDefinitionCreate.html">GnssAntennaDefinitionCreate</a>, <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a>.</p><p></p><p><pre> &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="antennaDefinition" version="20190429">     &lt;antennaCount>65&lt;/antennaCount>     ...     &lt;antenna>         &lt;name>BLOCK IIIA&lt;/name>         &lt;serial>G074&lt;/serial>         &lt;radome>2018-109A&lt;/radome>         &lt;comment>PCO provided by the Aerospace Corporation, PV from estimations by ESA/CODE&lt;/comment>         &lt;pattern>             &lt;count>3&lt;/count>             &lt;cell>                 &lt;type>*1*G**&lt;/type>                 &lt;offset>                     &lt;x>-1.23333333333333e-03&lt;/x>                     &lt;y>4.33333333333333e-04&lt;/y>                     &lt;z>3.15200000000000e-01&lt;/z>                 &lt;/offset>                 &lt;dZenit>1.00000000000000e+00&lt;/dZenit>                 &lt;pattern>                     &lt;type>0&lt;/type>                     &lt;rows>1&lt;/rows>                     &lt;columns>18&lt;/columns>                     &lt;cell row="0" col="0">1.39000000000000e-02&lt;/cell>                     &lt;cell row="0" col="1">1.28000000000000e-02&lt;/cell>                     &lt;cell row="0" col="2">1.02000000000000e-02&lt;/cell>                     &lt;cell row="0" col="3">5.80000000000000e-03&lt;/cell>                     &lt;cell row="0" col="4">1.10000000000000e-03&lt;/cell>                     &lt;cell row="0" col="5">-4.50000000000000e-03&lt;/cell>                     &lt;cell row="0" col="6">-9.70000000000000e-03&lt;/cell>                     &lt;cell row="0" col="7">-1.28000000000000e-02&lt;/cell>                     &lt;cell row="0" col="8">-1.34000000000000e-02&lt;/cell>                     &lt;cell row="0" col="9">-1.18000000000000e-02&lt;/cell>                     &lt;cell row="0" col="10">-8.90000000000000e-03&lt;/cell>                     &lt;cell row="0" col="11">-4.50000000000000e-03&lt;/cell>                     &lt;cell row="0" col="12">1.20000000000000e-03&lt;/cell>                     &lt;cell row="0" col="13">7.20000000000000e-03&lt;/cell>                     &lt;cell row="0" col="14">1.33000000000000e-02&lt;/cell>                     &lt;cell row="0" col="15">1.33000000000000e-02&lt;/cell>                     &lt;cell row="0" col="16">1.33000000000000e-02&lt;/cell>                     &lt;cell row="0" col="17">1.33000000000000e-02&lt;/cell>                 &lt;/pattern>             &lt;/cell>             ...         &lt;/pattern>     &lt;/antenna> &lt;/groops> </pre>'},
'fileFormat_gnssReceiverDefinition': { 'name': 'GnssReceiverDefinition', 'key': 'fileFormat_gnssReceiverDefinition', 'description': 'Contains a list of GNSS receivers which are identified by its name, serial, and version. Defines for each receiver a list of signal   Contains a list of GNSS receivers which are identified by its name, serial, and version. Defines for each receiver a list of signal   which can be observed. Can also be used for GNSS transmitters to define a list of transmitted signal types. For GLONASS satellites the frequency number can be stored in the  version  field. See  GnssReceiverDefinitionCreate .  &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="receiverDefinition" version="20190429">     &lt;receiverCount>112&lt;/receiverCount>     &lt;receiver>         &lt;name>GLONASS&lt;/name>         &lt;serial>R779&lt;/serial>         &lt;version>2&lt;/version>         &lt;comment/>         &lt;types>             &lt;count>4&lt;/count>             &lt;cell>*1CR**J&lt;/cell>             &lt;cell>*1PR**J&lt;/cell>             &lt;cell>*2CR**J&lt;/cell>             &lt;cell>*2PR**J&lt;/cell>         &lt;/types>     &lt;/receiver>     ...     &lt;receiver>         &lt;name>GLONASS-K1&lt;/name>         &lt;serial>R802&lt;/serial>         &lt;version>7&lt;/version>         &lt;comment/>         &lt;types>             &lt;count>10&lt;/count>             &lt;cell>*1CR**O&lt;/cell>             &lt;cell>*1PR**O&lt;/cell>             &lt;cell>*2CR**O&lt;/cell>             &lt;cell>*2PR**O&lt;/cell>             &lt;cell>*3IR**&lt;/cell>             &lt;cell>*3QR**&lt;/cell>             &lt;cell>*4AR**&lt;/cell>             &lt;cell>*4BR**&lt;/cell>             &lt;cell>*6AR**&lt;/cell>             &lt;cell>*6BR**&lt;/cell>         &lt;/types>     &lt;/receiver> &lt;/groops>', 'config_table': '', 'display_text': 'Contains a list of GNSS receivers which are identified by its name, serial, and version. Defines for each receiver a list of signal <a class="groops-class" href="gnssType.html">types</a> which can be observed. Can also be used for GNSS transmitters to define a list of transmitted signal types. For GLONASS satellites the frequency number can be stored in the <em>version</em> field.</p><p>See <a class="groops-program" href="GnssReceiverDefinitionCreate.html">GnssReceiverDefinitionCreate</a>.</p><p><pre> &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="receiverDefinition" version="20190429">     &lt;receiverCount>112&lt;/receiverCount>     &lt;receiver>         &lt;name>GLONASS&lt;/name>         &lt;serial>R779&lt;/serial>         &lt;version>2&lt;/version>         &lt;comment/>         &lt;types>             &lt;count>4&lt;/count>             &lt;cell>*1CR**J&lt;/cell>             &lt;cell>*1PR**J&lt;/cell>             &lt;cell>*2CR**J&lt;/cell>             &lt;cell>*2PR**J&lt;/cell>         &lt;/types>     &lt;/receiver>     ...     &lt;receiver>         &lt;name>GLONASS-K1&lt;/name>         &lt;serial>R802&lt;/serial>         &lt;version>7&lt;/version>         &lt;comment/>         &lt;types>             &lt;count>10&lt;/count>             &lt;cell>*1CR**O&lt;/cell>             &lt;cell>*1PR**O&lt;/cell>             &lt;cell>*2CR**O&lt;/cell>             &lt;cell>*2PR**O&lt;/cell>             &lt;cell>*3IR**&lt;/cell>             &lt;cell>*3QR**&lt;/cell>             &lt;cell>*4AR**&lt;/cell>             &lt;cell>*4BR**&lt;/cell>             &lt;cell>*6AR**&lt;/cell>             &lt;cell>*6BR**&lt;/cell>         &lt;/types>     &lt;/receiver> &lt;/groops> </pre>'},
'fileFormat_gnssSignalBias': { 'name': 'GnssSignalBias', 'key': 'fileFormat_gnssSignalBias', 'description': 'Signal biases of GNSS transmitters or receivers for different   Signal biases of GNSS transmitters or receivers for different  .  groops gnssSignalBias version=20200123           5 # number of signals # type   bias [m] # ===============================  C1CG06 -1.752461109688110974e-01  C1WG06  4.005884595055994590e-02  C2WG06  6.597469378913034532e-02  L1*G06 -2.736169875580296909e-02  L2*G06  3.422596762686257871e-02   See also  GnssProcessing ,  GnssSimulateReceiver ,  GnssSignalBias2Matrix ,  GnssSignalBias2SinexBias .', 'config_table': '', 'display_text': 'Signal biases of GNSS transmitters or receivers for different <a class="groops-class" href="gnssType.html">gnssType</a>.</p><p><pre> groops gnssSignalBias version=20200123           5 # number of signals # type   bias [m] # ===============================  C1CG06 -1.752461109688110974e-01  C1WG06  4.005884595055994590e-02  C2WG06  6.597469378913034532e-02  L1*G06 -2.736169875580296909e-02  L2*G06  3.422596762686257871e-02  </pre></p><p>See also <a class="groops-program" href="GnssProcessing.html">GnssProcessing</a>, <a class="groops-program" href="GnssSimulateReceiver.html">GnssSimulateReceiver</a>, <a class="groops-program" href="GnssSignalBias2Matrix.html">GnssSignalBias2Matrix</a>, <a class="groops-program" href="GnssSignalBias2SinexBias.html">GnssSignalBias2SinexBias</a>.'},
'fileFormat_gnssStationInfo': { 'name': 'GnssStationInfo', 'key': 'fileFormat_gnssStationInfo', 'description': 'DEPRECATED. Use  Platform  instead.', 'config_table': '', 'display_text': 'DEPRECATED. Use <a class="groops-file" href="fileFormat_platform.html">Platform</a> instead.'},
'fileFormat_griddedData': { 'name': 'GriddedData', 'key': 'fileFormat_griddedData', 'description': 'List of arbitrarily distributed points defined by geographic coordinates and ellipsoidal height. Each point can also have an associated area (projected on the unit sphere with a total area of  ). This file format supports multiple values per point (called  data0 ,  data1  and so on). For regular gridded data and binary format ( *.dat ) a more efficient storage scheme is used. See also:  GriddedDataCreate .  groops griddedData version=20200123  1  2  6.378137000000000000e+06  6.356752314140356146e+06 72 # hasArea, data columns, ellipoid a, ellipoid b, data rows # longitude [deg]           latitude [deg]            height [m]                unit areas [-]             data0                     data1 # ===========================================================================================================================================================  -1.650000000000000000e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.350000000000000000e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.050000000000000142e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -7.500000000000001421e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -4.500000000000002132e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.500000000000002132e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.499999999999997691e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   4.499999999999997868e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   7.499999999999997158e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.049999999999999574e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.349999999999999432e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.649999999999999432e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.650000000000000000e+02  4.500000000000000711e+01  0.000000000000000000e+00  1.916504532594049681e-01  1.000000000000000000e+00  2.000000000000000000e+00  -1.350000000000000000e+02  4.500000000000000711e+01  0.000000000000000000e+00  1.916504532594049681e-01  1.000000000000000000e+00  2.000000000000000000e+00', 'config_table': '', 'display_text': 'List of arbitrarily distributed points defined by geographic coordinates and ellipsoidal height. Each point can also have an associated area (projected on the unit sphere with a total area of $4\\pi$). This file format supports multiple values per point (called <code>data0</code>, <code>data1</code> and so on).</p><p>For regular gridded data and binary format (<code>*.dat</code>) a more efficient storage scheme is used.</p><p>See also: <a class="groops-program" href="GriddedDataCreate.html">GriddedDataCreate</a>.</p><p><pre> groops griddedData version=20200123  1  2  6.378137000000000000e+06  6.356752314140356146e+06 72 # hasArea, data columns, ellipoid a, ellipoid b, data rows # longitude [deg]           latitude [deg]            height [m]                unit areas [-]             data0                     data1 # ===========================================================================================================================================================  -1.650000000000000000e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.350000000000000000e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.050000000000000142e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -7.500000000000001421e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -4.500000000000002132e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.500000000000002132e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.499999999999997691e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   4.499999999999997868e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   7.499999999999997158e+01  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.049999999999999574e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.349999999999999432e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00   1.649999999999999432e+02  7.500000000000000000e+01  0.000000000000000000e+00  7.014893453974438420e-02  1.000000000000000000e+00  2.000000000000000000e+00  -1.650000000000000000e+02  4.500000000000000711e+01  0.000000000000000000e+00  1.916504532594049681e-01  1.000000000000000000e+00  2.000000000000000000e+00  -1.350000000000000000e+02  4.500000000000000711e+01  0.000000000000000000e+00  1.916504532594049681e-01  1.000000000000000000e+00  2.000000000000000000e+00 </pre></p><p>'},
'fileFormat_griddedDataTimeSeries': { 'name': 'GriddedDataTimeSeries', 'key': 'fileFormat_griddedDataTimeSeries', 'description': 'Time series of data for arbitrarily distributed points defined by geographic coordinates and ellipsoidal height. The data can be temporal interpolated by  basis splines . The file format consists of a  griddedData , a time series, and for each spatial point and spline node pair multiple values called  data0 ,  data1 ,  . A GriddedDataTimeSeries can be generated from individual  griddedData  with the program  GriddedData2GriddedDataTimeSeries . Vice-versa, a GriddedDataTimeSeries can be evaluated at a  specific time stamp to obtain a  griddedData  with  GriddedDataTimeSeries2GriddedData .', 'config_table': '', 'display_text': 'Time series of data for arbitrarily distributed points defined by geographic coordinates and ellipsoidal height. The data can be temporal interpolated by <a class="groops-ref" href="fundamentals.basisSplines.html">basis splines</a>. The file format consists of a <a class="groops-file" href="fileFormat_griddedData.html">griddedData</a>, a time series, and for each spatial point and spline node pair multiple values called <code>data0</code>, <code>data1</code>, .</p><p>A GriddedDataTimeSeries can be generated from individual <a class="groops-file" href="fileFormat_griddedData.html">griddedData</a> with the program <a class="groops-program" href="GriddedData2GriddedDataTimeSeries.html">GriddedData2GriddedDataTimeSeries</a>. Vice-versa, a GriddedDataTimeSeries can be evaluated at a  specific time stamp to obtain a <a class="groops-file" href="fileFormat_griddedData.html">griddedData</a> with <a class="groops-program" href="GriddedDataTimeSeries2GriddedData.html">GriddedDataTimeSeries2GriddedData</a>.'},
'fileFormat_instrument': { 'name': 'Instrument', 'key': 'fileFormat_instrument', 'description': 'This template file format can store different observations in a epoch wise manner. Each epoch consists of a time and additional data, e.g orbits, accelerometer data, star camera quaternions (see   This template file format can store different observations in a epoch wise manner. Each epoch consists of a time and additional data, e.g orbits, accelerometer data, star camera quaternions (see  ). The time series can be divided in several arcs (see  InstrumentSynchronize ). Also a  matrix  file is allowed as one single arc. The first column must contain times [MJD]. Without any extra column the instrument type is INSTRUMENTTIME, with one additional column the type is MISCVALUE, and for more columns the type MISCVALUES is used.  groops instrument version=20200123 # SATELLITETRACKING          -9         60  # instrument type, number of arcs # Time [MJD]               data0: range [m]          data1: range-rate [m/s]   data2: range-acc [m/s^2] # =====================================================================================================          12 # number of epochs of 1. arc  54588.000000000000000000 -5.074649470097549492e+05  5.755440207134928654e-01  1.877605261528093308e-03  54588.000057870370255841 -5.074620458130163024e+05  5.849357691551860805e-01  1.878948916234051596e-03  54588.000115740740966430 -5.074590976427756250e+05  5.943331739937073310e-01  1.879937220634776869e-03  54588.000173611111222272 -5.074561024756557308e+05  6.037340169611068452e-01  1.880370529387525701e-03  54588.000231481481478113 -5.074530602992626373e+05  6.131368121270999172e-01  1.880680632122925426e-03  54588.000289351851733954 -5.074499711071007187e+05  6.225398878861636565e-01  1.880495369480403561e-03  54588.000347222222444543 -5.074468349029610981e+05  6.319414138081351773e-01  1.880073731783055927e-03  54588.000405092592700385 -5.074436516971451929e+05  6.413404243585696385e-01  1.879464843086203459e-03  54588.000462962962956226 -5.074404215058300761e+05  6.507353310092597320e-01  1.878578987216372124e-03  54588.000520833333212067 -5.074371443491023383e+05  6.601267978060636477e-01  1.877878184949659246e-03  54588.000578703703922656 -5.074338202460713219e+05  6.695136489207137442e-01  1.876962042758626532e-03  54588.000636574074178498 -5.074304492190054734e+05  6.788964444122400632e-01  1.876091925462087043e-03          12 # number of epochs of 2. arc  54588.000694444444434339 -5.074270312892858055e+05  6.882748400534359767e-01  1.875376456928801432e-03  54588.000752314814690180 -5.074235664742725785e+05  6.976508178537534910e-01  1.874929898412159559e-03  54588.000810185185400769 -5.074200547868391732e+05  7.070236200716006891e-01  1.874312324351668077e-03  54588.000868055555656611 -5.074164962409950094e+05  7.163943828291452487e-01  1.873924188388115340e-03  54588.000925925925912452 -5.074128908454515622e+05  7.257639682023964145e-01  1.874025826380292404e-03  54588.000983796296168293 -5.074092386012640782e+05  7.351333608427884636e-01  1.873680487441316657e-03  54588.001041666666878882 -5.074055395130896359e+05  7.445020815182646912e-01  1.873849502509668122e-03  54588.001099537037134724 -5.074017935789784533e+05  7.538716732272922050e-01  1.873971633320137753e-03  54588.001157407407390565 -5.073980007962241652e+05  7.632414098560330595e-01  1.873984767500571974e-03  54588.001215277777646406 -5.073941611626467784e+05  7.726123093411200182e-01  1.874295246964456478e-03  54588.001273148148356995 -5.073902746728868224e+05  7.819835205798950639e-01  1.874226146744964808e-03  54588.001331018518612836 -5.073863413272026228e+05  7.913547196412918927e-01  1.874173804634685515e-03', 'config_table': '', 'display_text': 'This template file format can store different observations in a epoch wise manner. Each epoch consists of a time and additional data, e.g orbits, accelerometer data, star camera quaternions (see <a class="groops-class" href="instrumentTypeType.html">InstrumentType</a>). The time series can be divided in several arcs (see <a class="groops-program" href="InstrumentSynchronize.html">InstrumentSynchronize</a>).</p><p>Also a <a class="groops-file" href="fileFormat_matrix.html">matrix</a> file is allowed as one single arc. The first column must contain times [MJD]. Without any extra column the instrument type is INSTRUMENTTIME, with one additional column the type is MISCVALUE, and for more columns the type MISCVALUES is used.</p><p><pre> groops instrument version=20200123 # SATELLITETRACKING          -9         60  # instrument type, number of arcs # Time [MJD]               data0: range [m]          data1: range-rate [m/s]   data2: range-acc [m/s^2] # =====================================================================================================          12 # number of epochs of 1. arc  54588.000000000000000000 -5.074649470097549492e+05  5.755440207134928654e-01  1.877605261528093308e-03  54588.000057870370255841 -5.074620458130163024e+05  5.849357691551860805e-01  1.878948916234051596e-03  54588.000115740740966430 -5.074590976427756250e+05  5.943331739937073310e-01  1.879937220634776869e-03  54588.000173611111222272 -5.074561024756557308e+05  6.037340169611068452e-01  1.880370529387525701e-03  54588.000231481481478113 -5.074530602992626373e+05  6.131368121270999172e-01  1.880680632122925426e-03  54588.000289351851733954 -5.074499711071007187e+05  6.225398878861636565e-01  1.880495369480403561e-03  54588.000347222222444543 -5.074468349029610981e+05  6.319414138081351773e-01  1.880073731783055927e-03  54588.000405092592700385 -5.074436516971451929e+05  6.413404243585696385e-01  1.879464843086203459e-03  54588.000462962962956226 -5.074404215058300761e+05  6.507353310092597320e-01  1.878578987216372124e-03  54588.000520833333212067 -5.074371443491023383e+05  6.601267978060636477e-01  1.877878184949659246e-03  54588.000578703703922656 -5.074338202460713219e+05  6.695136489207137442e-01  1.876962042758626532e-03  54588.000636574074178498 -5.074304492190054734e+05  6.788964444122400632e-01  1.876091925462087043e-03          12 # number of epochs of 2. arc  54588.000694444444434339 -5.074270312892858055e+05  6.882748400534359767e-01  1.875376456928801432e-03  54588.000752314814690180 -5.074235664742725785e+05  6.976508178537534910e-01  1.874929898412159559e-03  54588.000810185185400769 -5.074200547868391732e+05  7.070236200716006891e-01  1.874312324351668077e-03  54588.000868055555656611 -5.074164962409950094e+05  7.163943828291452487e-01  1.873924188388115340e-03  54588.000925925925912452 -5.074128908454515622e+05  7.257639682023964145e-01  1.874025826380292404e-03  54588.000983796296168293 -5.074092386012640782e+05  7.351333608427884636e-01  1.873680487441316657e-03  54588.001041666666878882 -5.074055395130896359e+05  7.445020815182646912e-01  1.873849502509668122e-03  54588.001099537037134724 -5.074017935789784533e+05  7.538716732272922050e-01  1.873971633320137753e-03  54588.001157407407390565 -5.073980007962241652e+05  7.632414098560330595e-01  1.873984767500571974e-03  54588.001215277777646406 -5.073941611626467784e+05  7.726123093411200182e-01  1.874295246964456478e-03  54588.001273148148356995 -5.073902746728868224e+05  7.819835205798950639e-01  1.874226146744964808e-03  54588.001331018518612836 -5.073863413272026228e+05  7.913547196412918927e-01  1.874173804634685515e-03 </pre>'},
'fileFormat_matrix': { 'name': 'Matrix', 'key': 'fileFormat_matrix', 'description': 'Stores matrices and vectors. Only one triangle is written for symmetric or triangular matrices. The header (the matrix definition) is optional. Therefore a pure text with only numbers in columns are also allowed. This simplifies the handling of external data. Instead of a matrix file also an  instrument  file is allowed. The first column is the time [MJD], the other columns depends on the instrument type.  groops matrix version=20200123 LowerSymmetricMatrix( 4 x 4 )   1.000000000000000000e+00   0.000000000000000000e+00  1.000000000000000000e+00   0.000000000000000000e+00  0.000000000000000000e+00  1.000000000000000000e+00   0.000000000000000000e+00  0.000000000000000000e+00  0.000000000000000000e+00  1.000000000000000000e+00', 'config_table': '', 'display_text': 'Stores matrices and vectors. Only one triangle is written for symmetric or triangular matrices.</p><p>The header (the matrix definition) is optional. Therefore a pure text with only numbers in columns are also allowed. This simplifies the handling of external data.</p><p>Instead of a matrix file also an <a class="groops-file" href="fileFormat_instrument.html">instrument</a> file is allowed. The first column is the time [MJD], the other columns depends on the instrument type.</p><p><pre> groops matrix version=20200123 LowerSymmetricMatrix( 4 x 4 )   1.000000000000000000e+00   0.000000000000000000e+00  1.000000000000000000e+00   0.000000000000000000e+00  0.000000000000000000e+00  1.000000000000000000e+00   0.000000000000000000e+00  0.000000000000000000e+00  0.000000000000000000e+00  1.000000000000000000e+00 </pre></p><p>'},
'fileFormat_meanPolarMotion': { 'name': 'MeanPolarMotion', 'key': 'fileFormat_meanPolarMotion', 'description': 'The mean pole of the Earth rotation is represented by a polynomial in a time interval.  &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="meanPolarMotion" version="20200123">   &lt;meanPolarMotion>     &lt;intervalCount>2&lt;/intervalCount>     &lt;interval>       &lt;timeStart>42778.0000000000000000&lt;/timeStart>       &lt;degree>3&lt;/degree>       &lt;xp>5.59741000000000e-02&lt;/xp>       &lt;xp>1.82430000000000e-03&lt;/xp>       &lt;xp>1.84130000000000e-04&lt;/xp>       &lt;xp>7.02400000000000e-06&lt;/xp>       &lt;yp>3.46346000000000e-01&lt;/yp>       &lt;yp>1.78960000000000e-03&lt;/yp>       &lt;yp>-1.07290000000000e-04&lt;/yp>       &lt;yp>-9.08000000000000e-07&lt;/yp>     &lt;/interval>     &lt;interval>       &lt;timeStart>55197.0000000000000000&lt;/timeStart>       &lt;degree>1&lt;/degree>       &lt;xp>2.35130000000000e-02&lt;/xp>       &lt;xp>7.61410000000000e-03&lt;/xp>       &lt;yp>3.58891000000000e-01&lt;/yp>       &lt;yp>-6.28700000000000e-04&lt;/yp>     &lt;/interval>   &lt;/meanPolarMotion> &lt;/groops>', 'config_table': '', 'display_text': 'The mean pole of the Earth rotation is represented by a polynomial in a time interval.</p><p><pre> &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="meanPolarMotion" version="20200123">   &lt;meanPolarMotion>     &lt;intervalCount>2&lt;/intervalCount>     &lt;interval>       &lt;timeStart>42778.0000000000000000&lt;/timeStart>       &lt;degree>3&lt;/degree>       &lt;xp>5.59741000000000e-02&lt;/xp>       &lt;xp>1.82430000000000e-03&lt;/xp>       &lt;xp>1.84130000000000e-04&lt;/xp>       &lt;xp>7.02400000000000e-06&lt;/xp>       &lt;yp>3.46346000000000e-01&lt;/yp>       &lt;yp>1.78960000000000e-03&lt;/yp>       &lt;yp>-1.07290000000000e-04&lt;/yp>       &lt;yp>-9.08000000000000e-07&lt;/yp>     &lt;/interval>     &lt;interval>       &lt;timeStart>55197.0000000000000000&lt;/timeStart>       &lt;degree>1&lt;/degree>       &lt;xp>2.35130000000000e-02&lt;/xp>       &lt;xp>7.61410000000000e-03&lt;/xp>       &lt;yp>3.58891000000000e-01&lt;/yp>       &lt;yp>-6.28700000000000e-04&lt;/yp>     &lt;/interval>   &lt;/meanPolarMotion> &lt;/groops> </pre>'},
'fileFormat_normalEquation': { 'name': 'NormalEquation', 'key': 'fileFormat_normalEquation', 'description': 'Stores a  system of normal equations    This file format consists of multiple files. The file name  normals.dat.gz  corresponds to the following files:    normals.dat.gz  or  normals.00.00.dat.gz  ...  normals.0n.0n.dat.gz :       the normal matrix   as  matrix ,  normals.rightHandSide.dat.gz :       the right hand side(s)   as  matrix ,  normals.parameterNames.txt :  parameter names ,  normals.info.xml :      u.a. containing the number of observations and the quadratic sum of (reduced) observations  .   A large normal matrix may be splitted into blocks and stored in multiple files. The block row/column number is indicated in the file name. Only the upper blocks of the sysmmetric matrix are considered. Matrix in blocks can be distributed on muliple nodes in parallel mode to efficiently use distributed memory.', 'config_table': '', 'display_text': 'Stores a <a class="groops-ref" href="normalEquationType.html">system of normal equations</a> \\[   \\M N \\hat{\\M x} = \\M n. \\] This file format consists of multiple files. The file name <code>normals.dat.gz</code> corresponds to the following files: <ul>  <li><code>normals.dat.gz</code> or <code>normals.00.00.dat.gz</code> ... <code>normals.0n.0n.dat.gz</code>:       the normal matrix $\\M N$ as <a class="groops-file" href="fileFormat_matrix.html">matrix</a>, </li><li> <code>normals.rightHandSide.dat.gz</code>:       the right hand side(s) $\\M n$ as <a class="groops-file" href="fileFormat_matrix.html">matrix</a>, </li><li> <code>normals.parameterNames.txt</code>: <a class="groops-file" href="fileFormat_parameterName.html">parameter names</a>, </li><li> <code>normals.info.xml</code>:      u.a. containing the number of observations and the quadratic sum of (reduced) observations $\\M l^T\\M P\\M l$. </li></ul>  A large normal matrix may be splitted into blocks and stored in multiple files. The block row/column number is indicated in the file name. Only the upper blocks of the sysmmetric matrix are considered. Matrix in blocks can be distributed on muliple nodes in parallel mode to efficiently use distributed memory.'},
'fileFormat_oceanPoleTide': { 'name': 'OceanPoleTide', 'key': 'fileFormat_oceanPoleTide', 'description': 'Describes the reaction of the ocean mass to the change of the centrifugal potential (polar wobble) in terms spherical harmonics. See also  Iers2OceanPoleTide .', 'config_table': '', 'display_text': 'Describes the reaction of the ocean mass to the change of the centrifugal potential (polar wobble) in terms spherical harmonics.</p><p>See also <a class="groops-program" href="Iers2OceanPoleTide.html">Iers2OceanPoleTide</a>.'},
'fileFormat_parameterName': { 'name': 'ParameterName', 'key': 'fileFormat_parameterName', 'description': 'Name of parameters of a system of  normal equations  or  solution vector . A parameter name is a string  &lt;object>:&lt;type>:&lt;temporal>:&lt;interval>  containg four parts divided by  :     object: Object this parameter refers to, e.g.  graceA ,  G023 ,  earth ,  type: Type of this parameter, e.g.  accBias ,  position.x ,  temporal: Temporal representation of this parameter, e.g.  trend ,  polynomial.degree1 ,  interval: Interval/epoch this parameter represents, e.g.  2017-01-01_00-00-00_2017-01-02_00-00-00 ,  2018-01-01_00-00-00 .   In the documentation a star ( * ) in the name means this part is untouched and useally set by other classes. Times are written as  yyyy-mm-dd_hh-mm-ss  and intervals (if not empty) as  &lt;timeStart>_&lt;timeEnd> . See  ParameterNamesCreate .  groops parameterName version=20200123 # object:type:temporal:interval # =============================       10080 # number of parameters  karr:position.x::2018-06-01_00-00-00_2018-06-02_00-00-00  karr:position.y::2018-06-01_00-00-00_2018-06-02_00-00-00  karr:position.z::2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereWet:spline.n1:2018-06-01_00-00-00_2018-06-01_02-00-00  karr:troposphereWet:spline.n1:2018-06-01_00-00-00_2018-06-01_04-00-00  karr:troposphereWet:spline.n1:2018-06-01_02-00-00_2018-06-01_06-00-00  karr:troposphereWet:spline.n1:2018-06-01_04-00-00_2018-06-01_08-00-00  karr:troposphereWet:spline.n1:2018-06-01_06-00-00_2018-06-01_10-00-00  karr:troposphereWet:spline.n1:2018-06-01_08-00-00_2018-06-01_12-00-00  karr:troposphereWet:spline.n1:2018-06-01_10-00-00_2018-06-01_14-00-00  karr:troposphereWet:spline.n1:2018-06-01_12-00-00_2018-06-01_16-00-00  karr:troposphereWet:spline.n1:2018-06-01_14-00-00_2018-06-01_18-00-00  karr:troposphereWet:spline.n1:2018-06-01_16-00-00_2018-06-01_20-00-00  karr:troposphereWet:spline.n1:2018-06-01_18-00-00_2018-06-01_22-00-00  karr:troposphereWet:spline.n1:2018-06-01_20-00-00_2018-06-02_00-00-00  karr:troposphereWet:spline.n1:2018-06-01_22-00-00_2018-06-02_00-00-00  karr:troposphereGradient.x:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereGradient.y:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereGradient.x:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereGradient.y:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:signalBias01(+1.00L1CG**)::  karr:signalBias02(+1.00L2WG**)::  karr:signalBias03(+1.00L2XG**)::  G01:solarRadiationPressure.ECOM.D0::  G01:solarRadiationPressure.ECOM.DC2::  G01:solarRadiationPressure.ECOM.DS2::  G01:solarRadiationPressure.ECOM.Y0::  G01:solarRadiationPressure.ECOM.B0::  G01:solarRadiationPressure.ECOM.BC1::  G01:solarRadiationPressure.ECOM.BS1::  G01:stochasticPulse.x::2018-06-01_12-00-00  G01:stochasticPulse.y::2018-06-01_12-00-00  G01:stochasticPulse.z::2018-06-01_12-00-00  G01:arc0.position0.x::  G01:arc0.position0.y::  G01:arc0.position0.z::  G01:arc0.velocity0.x::  G01:arc0.velocity0.y::  G01:arc0.velocity0.z::  G01:signalBias01(-1.00C1CG01)::  G01:signalBias02(+1.00L1*G01)::  G01:signalBias03(+1.00L2*G01)::', 'config_table': '', 'display_text': 'Name of parameters of a system of <a class="groops-file" href="fileFormat_normalEquation.html">normal equations</a> or <a class="groops-file" href="fileFormat_matrix.html">solution vector</a>.</p><p>A parameter name is a string <code>&lt;object>:&lt;type>:&lt;temporal>:&lt;interval></code> containg four parts divided by <code>:</code> <ol>  <li>object: Object this parameter refers to, e.g. <code>graceA</code>, <code>G023</code>, <code>earth</code>, </li><li> type: Type of this parameter, e.g. <code>accBias</code>, <code>position.x</code>, </li><li> temporal: Temporal representation of this parameter, e.g. <code>trend</code>, <code>polynomial.degree1</code>, </li><li> interval: Interval/epoch this parameter represents, e.g. <code>2017-01-01_00-00-00_2017-01-02_00-00-00</code>, <code>2018-01-01_00-00-00</code>. </li></ol>  In the documentation a star (<code>*</code>) in the name means this part is untouched and useally set by other classes. Times are written as <code>yyyy-mm-dd_hh-mm-ss</code> and intervals (if not empty) as <code>&lt;timeStart>_&lt;timeEnd></code>.</p><p>See <a class="groops-program" href="ParameterNamesCreate.html">ParameterNamesCreate</a>.</p><p><pre> groops parameterName version=20200123 # object:type:temporal:interval # =============================       10080 # number of parameters  karr:position.x::2018-06-01_00-00-00_2018-06-02_00-00-00  karr:position.y::2018-06-01_00-00-00_2018-06-02_00-00-00  karr:position.z::2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereWet:spline.n1:2018-06-01_00-00-00_2018-06-01_02-00-00  karr:troposphereWet:spline.n1:2018-06-01_00-00-00_2018-06-01_04-00-00  karr:troposphereWet:spline.n1:2018-06-01_02-00-00_2018-06-01_06-00-00  karr:troposphereWet:spline.n1:2018-06-01_04-00-00_2018-06-01_08-00-00  karr:troposphereWet:spline.n1:2018-06-01_06-00-00_2018-06-01_10-00-00  karr:troposphereWet:spline.n1:2018-06-01_08-00-00_2018-06-01_12-00-00  karr:troposphereWet:spline.n1:2018-06-01_10-00-00_2018-06-01_14-00-00  karr:troposphereWet:spline.n1:2018-06-01_12-00-00_2018-06-01_16-00-00  karr:troposphereWet:spline.n1:2018-06-01_14-00-00_2018-06-01_18-00-00  karr:troposphereWet:spline.n1:2018-06-01_16-00-00_2018-06-01_20-00-00  karr:troposphereWet:spline.n1:2018-06-01_18-00-00_2018-06-01_22-00-00  karr:troposphereWet:spline.n1:2018-06-01_20-00-00_2018-06-02_00-00-00  karr:troposphereWet:spline.n1:2018-06-01_22-00-00_2018-06-02_00-00-00  karr:troposphereGradient.x:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereGradient.y:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereGradient.x:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:troposphereGradient.y:spline.n1:2018-06-01_00-00-00_2018-06-02_00-00-00  karr:signalBias01(+1.00L1CG**)::  karr:signalBias02(+1.00L2WG**)::  karr:signalBias03(+1.00L2XG**)::  G01:solarRadiationPressure.ECOM.D0::  G01:solarRadiationPressure.ECOM.DC2::  G01:solarRadiationPressure.ECOM.DS2::  G01:solarRadiationPressure.ECOM.Y0::  G01:solarRadiationPressure.ECOM.B0::  G01:solarRadiationPressure.ECOM.BC1::  G01:solarRadiationPressure.ECOM.BS1::  G01:stochasticPulse.x::2018-06-01_12-00-00  G01:stochasticPulse.y::2018-06-01_12-00-00  G01:stochasticPulse.z::2018-06-01_12-00-00  G01:arc0.position0.x::  G01:arc0.position0.y::  G01:arc0.position0.z::  G01:arc0.velocity0.x::  G01:arc0.velocity0.y::  G01:arc0.velocity0.z::  G01:signalBias01(-1.00C1CG01)::  G01:signalBias02(+1.00L1*G01)::  G01:signalBias03(+1.00L2*G01):: </pre>'},
'fileFormat_platform': { 'name': 'Platform', 'key': 'fileFormat_platform', 'description': 'Defines a platform with a local coordinate frame equipped with instruments. The platform might be a reference station, a low Earth satellite, or a transmitting GNSS satellite and is referenced by a marker name and number. The reference point (marker or center of mass (CoM)) can change in time relative to the local frame. Each equipped instrument is described at least by the following information    name  serial number  coordinates in the local frame  a time interval in which the instrument was active  the orientation for antennas and reflectors.  For GNSS satellites the platform defines the PRN. The different assigned SVNs are defined by the transmitting antennas. Platforms for GNSS stations can be created from station log files with  GnssStationLog2Platform . Platforms for GNSS satellites can be created from an ANTEX file with  GnssAntex2AntennaDefinition . See also  PlatformCreate .', 'config_table': '', 'display_text': 'Defines a platform with a local coordinate frame equipped with instruments. The platform might be a reference station, a low Earth satellite, or a transmitting GNSS satellite and is referenced by a marker name and number. The reference point (marker or center of mass (CoM)) can change in time relative to the local frame.</p><p>Each equipped instrument is described at least by the following information <ul>  <li>name </li><li> serial number </li><li> coordinates in the local frame </li><li> a time interval in which the instrument was active </li><li> the orientation for antennas and reflectors. </li></ul> </p><p>For GNSS satellites the platform defines the PRN. The different assigned SVNs are defined by the transmitting antennas.</p><p>Platforms for GNSS stations can be created from station log files with <a class="groops-program" href="GnssStationLog2Platform.html">GnssStationLog2Platform</a>. Platforms for GNSS satellites can be created from an ANTEX file with <a class="groops-program" href="GnssAntex2AntennaDefinition.html">GnssAntex2AntennaDefinition</a>.</p><p>See also <a class="groops-program" href="PlatformCreate.html">PlatformCreate</a>.</p><p>'},
'fileFormat_polygon': { 'name': 'Polygon', 'key': 'fileFormat_polygon', 'description': 'List of longitude and latitudes to describe borders, e.g. river basins or continents. It is used in   List of longitude and latitudes to describe borders, e.g. river basins or continents. It is used in  .  groops polygon version=20200123           2  # number of polygons           6  # number of points (1. polygon) # longitude [deg]           latitude [deg] # ==================================================  -1.598200000000000216e+02  2.203000000000000114e+01  -1.596200000000000045e+02  2.189999999999999858e+01  -1.593799999999999955e+02  2.189999999999999858e+01  -1.593000000000000114e+02  2.221999999999999886e+01  -1.595800000000000125e+02  2.221999999999999886e+01  -1.598200000000000216e+02  2.203000000000000114e+01           5  # number of points (2. polygon) # longitude [deg]           latitude [deg] # ==================================================  -7.900000000000000000e+01  2.669999999999999929e+01  -7.870000000000000284e+01  2.650000000000000000e+01  -7.823000000000000398e+01  2.667000000000000171e+01  -7.793000000000000682e+01  2.667000000000000171e+01  -7.779999999999999716e+01  2.646999999999999886e+01', 'config_table': '', 'display_text': 'List of longitude and latitudes to describe borders, e.g. river basins or continents. It is used in <a class="groops-class" href="borderType.html#polygon">border:polygon</a>.</p><p><pre> groops polygon version=20200123           2  # number of polygons           6  # number of points (1. polygon) # longitude [deg]           latitude [deg] # ==================================================  -1.598200000000000216e+02  2.203000000000000114e+01  -1.596200000000000045e+02  2.189999999999999858e+01  -1.593799999999999955e+02  2.189999999999999858e+01  -1.593000000000000114e+02  2.221999999999999886e+01  -1.595800000000000125e+02  2.221999999999999886e+01  -1.598200000000000216e+02  2.203000000000000114e+01           5  # number of points (2. polygon) # longitude [deg]           latitude [deg] # ==================================================  -7.900000000000000000e+01  2.669999999999999929e+01  -7.870000000000000284e+01  2.650000000000000000e+01  -7.823000000000000398e+01  2.667000000000000171e+01  -7.793000000000000682e+01  2.667000000000000171e+01  -7.779999999999999716e+01  2.646999999999999886e+01 </pre></p><p>'},
'fileFormat_potentialCoefficients': { 'name': 'PotentialCoefficients', 'key': 'fileFormat_potentialCoefficients', 'description': 'The standard  .gfc  format as defined by the ICGEM is used in ASCII the format. Only the static part is used and temporal variations (e.g. trend) are ignored. To write additional information and temporal variations use  PotentialCoefficients2Icgem .', 'config_table': '', 'display_text': 'The standard <code>.gfc</code> format as defined by the ICGEM is used in ASCII the format. Only the static part is used and temporal variations (e.g. trend) are ignored. To write additional information and temporal variations use <a class="groops-program" href="PotentialCoefficients2Icgem.html">PotentialCoefficients2Icgem</a>.'},
'fileFormat_satelliteModel': { 'name': 'SatelliteModel', 'key': 'fileFormat_satelliteModel', 'description': 'Properties of a satellite to model non-conservative forces (e.g.   Properties of a satellite to model non-conservative forces (e.g.  ). The file may contain surface properties, mass, drag coefficients, and antenna thrust values. See  SatelliteModelCreate  and  SinexMetadata2SatelliteModel .  &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="satelliteModel" version="20190429">    &lt;satelliteCount>1&lt;/satelliteCount>    &lt;satellite>        &lt;satelliteName>GALILEO-2&lt;/satelliteName>        &lt;mass>7.00000000000000e+02&lt;/mass>        &lt;coefficientDrag>0.00000000000000e+00&lt;/coefficientDrag>        &lt;surfaceCount>15&lt;/surfaceCount>        &lt;surface>            &lt;type>0&lt;/type>            &lt;normal>                &lt;x>-1.00000000000000e+00&lt;/x>                &lt;y>0.00000000000000e+00&lt;/y>                &lt;z>0.00000000000000e+00&lt;/z>            &lt;/normal>            &lt;area>4.40000000000000e-01&lt;/area>            &lt;reflexionVisible>0.00000000000000e+00&lt;/reflexionVisible>            &lt;diffusionVisible>7.00000000000000e-02&lt;/diffusionVisible>            &lt;absorptionVisible>9.30000000000000e-01&lt;/absorptionVisible>            &lt;reflexionInfrared>1.00000000000000e-01&lt;/reflexionInfrared>            &lt;diffusionInfrared>1.00000000000000e-01&lt;/diffusionInfrared>            &lt;absorptionInfrared>8.00000000000000e-01&lt;/absorptionInfrared>            &lt;hasThermalReemission>1&lt;/hasThermalReemission>        &lt;/surface>        ...        &lt;modulCount>2&lt;/modulCount>        &lt;modul>            &lt;type>1&lt;/type>            &lt;rotationAxis>                &lt;x>0.00000000000000e+00&lt;/x>                &lt;y>1.00000000000000e+00&lt;/y>                &lt;z>0.00000000000000e+00&lt;/z>            &lt;/rotationAxis>            &lt;normal>                &lt;x>0.00000000000000e+00&lt;/x>                &lt;y>0.00000000000000e+00&lt;/y>                &lt;z>1.00000000000000e+00&lt;/z>            &lt;/normal>            &lt;surface>                &lt;count>4&lt;/count>                &lt;cell>11&lt;/cell>                &lt;cell>12&lt;/cell>                &lt;cell>13&lt;/cell>                &lt;cell>14&lt;/cell>            &lt;/surface>        &lt;/modul>        &lt;modul>            &lt;type>2&lt;/type>            &lt;antennaThrust>                &lt;x>0.00000000000000e+00&lt;/x>                &lt;y>0.00000000000000e+00&lt;/y>                &lt;z>2.65000000000000e+02&lt;/z>            &lt;/antennaThrust>        &lt;/modul>    &lt;/satellite> &lt;/groops>', 'config_table': '', 'display_text': 'Properties of a satellite to model non-conservative forces (e.g. <a class="groops-class" href="miscAccelerationsType.html">miscAccelerations</a>). The file may contain surface properties, mass, drag coefficients, and antenna thrust values.</p><p>See <a class="groops-program" href="SatelliteModelCreate.html">SatelliteModelCreate</a> and <a class="groops-program" href="SinexMetadata2SatelliteModel.html">SinexMetadata2SatelliteModel</a>.</p><p><pre> &lt;?xml version="1.0" encoding="UTF-8"?> &lt;groops type="satelliteModel" version="20190429">    &lt;satelliteCount>1&lt;/satelliteCount>    &lt;satellite>        &lt;satelliteName>GALILEO-2&lt;/satelliteName>        &lt;mass>7.00000000000000e+02&lt;/mass>        &lt;coefficientDrag>0.00000000000000e+00&lt;/coefficientDrag>        &lt;surfaceCount>15&lt;/surfaceCount>        &lt;surface>            &lt;type>0&lt;/type>            &lt;normal>                &lt;x>-1.00000000000000e+00&lt;/x>                &lt;y>0.00000000000000e+00&lt;/y>                &lt;z>0.00000000000000e+00&lt;/z>            &lt;/normal>            &lt;area>4.40000000000000e-01&lt;/area>            &lt;reflexionVisible>0.00000000000000e+00&lt;/reflexionVisible>            &lt;diffusionVisible>7.00000000000000e-02&lt;/diffusionVisible>            &lt;absorptionVisible>9.30000000000000e-01&lt;/absorptionVisible>            &lt;reflexionInfrared>1.00000000000000e-01&lt;/reflexionInfrared>            &lt;diffusionInfrared>1.00000000000000e-01&lt;/diffusionInfrared>            &lt;absorptionInfrared>8.00000000000000e-01&lt;/absorptionInfrared>            &lt;hasThermalReemission>1&lt;/hasThermalReemission>        &lt;/surface>        ...        &lt;modulCount>2&lt;/modulCount>        &lt;modul>            &lt;type>1&lt;/type>            &lt;rotationAxis>                &lt;x>0.00000000000000e+00&lt;/x>                &lt;y>1.00000000000000e+00&lt;/y>                &lt;z>0.00000000000000e+00&lt;/z>            &lt;/rotationAxis>            &lt;normal>                &lt;x>0.00000000000000e+00&lt;/x>                &lt;y>0.00000000000000e+00&lt;/y>                &lt;z>1.00000000000000e+00&lt;/z>            &lt;/normal>            &lt;surface>                &lt;count>4&lt;/count>                &lt;cell>11&lt;/cell>                &lt;cell>12&lt;/cell>                &lt;cell>13&lt;/cell>                &lt;cell>14&lt;/cell>            &lt;/surface>        &lt;/modul>        &lt;modul>            &lt;type>2&lt;/type>            &lt;antennaThrust>                &lt;x>0.00000000000000e+00&lt;/x>                &lt;y>0.00000000000000e+00&lt;/y>                &lt;z>2.65000000000000e+02&lt;/z>            &lt;/antennaThrust>        &lt;/modul>    &lt;/satellite> &lt;/groops> </pre>'},
'fileFormat_stringList': { 'name': 'StringList', 'key': 'fileFormat_stringList', 'description': 'White space separated list of strings. Comments are allowed and all the text from the character \' # \' to the end of the line is ignored. Strings containing white spaces or the \' # \' character must be set in quotes (\' "" \').  # IGSR3 stations abmf abpo ade1 adis ajac albh algo alic alrt amc2 aoml areq arev artu asc1', 'config_table': '', 'display_text': 'White space separated list of strings. Comments are allowed and all the text from the character \'<code>#</code>\' to the end of the line is ignored. Strings containing white spaces or the \'<code>#</code>\' character must be set in quotes (\'<code>""</code>\').</p><p><pre> # IGSR3 stations abmf abpo ade1 adis ajac albh algo alic alrt amc2 aoml areq arev artu asc1 </pre>'},
'fileFormat_stringTable': { 'name': 'StringTable', 'key': 'fileFormat_stringTable', 'description': 'White space separated table of strings in row and columns. Additional columns in a row may represent alternatives, e.g. for core stations in a GNSS network. Comments are allowed and all the text from the character \' # \' to the end of the line is ignored. Strings containing white spaces or the \' # \' character must be set in quotes  (\' "" \').  # core network with alternative stations artu mdvj mdvo nril asc1 sthl bahr bhr1 yibl nama chat chti auck chpi braz ufpr savo ckis nium coco xmis dgar dgav cro1 scub abmf lmmf aoml daej taej suwn osn1 darw kat1 tow2 alic dav1 maw1 drao albh will holb nano fair whit glps guat gode godz usno usn3 goug', 'config_table': '', 'display_text': 'White space separated table of strings in row and columns. Additional columns in a row may represent alternatives, e.g. for core stations in a GNSS network. Comments are allowed and all the text from the character \'<code>#</code>\' to the end of the line is ignored. Strings containing white spaces or the \'<code>#</code>\' character must be set in quotes  (\'<code>""</code>\').</p><p><pre> # core network with alternative stations artu mdvj mdvo nril asc1 sthl bahr bhr1 yibl nama chat chti auck chpi braz ufpr savo ckis nium coco xmis dgar dgav cro1 scub abmf lmmf aoml daej taej suwn osn1 darw kat1 tow2 alic dav1 maw1 drao albh will holb nano fair whit glps guat gode godz usno usn3 goug </pre>'},
'fileFormat_tideGeneratingPotential': { 'name': 'TideGeneratingPotential', 'key': 'fileFormat_tideGeneratingPotential', 'description': 'groops tideGeneratingPotential version=20200123        3606 # Dood.   cos                       sin                      name # ===============================================================  055.563 -3.122600001000726621e-06  0.000000000000000000e+00 ""  055.565  7.719644799947265879e-02  0.000000000000000000e+00 om1  055.573  1.975999999999999959e-07  0.000000000000000000e+00 ""  055.575 -7.535264999889109729e-04  0.000000000000000000e+00 om2  055.654 -4.037500000326006771e-06  0.000000000000000000e+00 ""  055.666  6.590000000000000115e-08  0.000000000000000000e+00 ""  055.753  6.023000000000000398e-07  0.000000000000000000e+00 ""  056.475  7.920000000000000775e-08  0.000000000000000000e+00 ""  056.554 -1.360322439950949897e-02  0.000000000000000000e+00 sa  056.556  7.156881999672112154e-04  0.000000000000000000e+00 ""  056.564  8.641769999583327993e-05  0.000000000000000000e+00 ""', 'config_table': '', 'display_text': '<pre> groops tideGeneratingPotential version=20200123        3606 # Dood.   cos                       sin                      name # ===============================================================  055.563 -3.122600001000726621e-06  0.000000000000000000e+00 ""  055.565  7.719644799947265879e-02  0.000000000000000000e+00 om1  055.573  1.975999999999999959e-07  0.000000000000000000e+00 ""  055.575 -7.535264999889109729e-04  0.000000000000000000e+00 om2  055.654 -4.037500000326006771e-06  0.000000000000000000e+00 ""  055.666  6.590000000000000115e-08  0.000000000000000000e+00 ""  055.753  6.023000000000000398e-07  0.000000000000000000e+00 ""  056.475  7.920000000000000775e-08  0.000000000000000000e+00 ""  056.554 -1.360322439950949897e-02  0.000000000000000000e+00 sa  056.556  7.156881999672112154e-04  0.000000000000000000e+00 ""  056.564  8.641769999583327993e-05  0.000000000000000000e+00 "" </pre></p><p>'},
'fileFormat_timeSplinesCovariance': { 'name': 'TimeSplinesCovariance', 'key': 'fileFormat_timeSplinesCovariance', 'description': 'Stores covariance information for  TimeSplinesGravityField . It can be the variances of the potential coefficients or the full covariance matrix for each temporal nodal point.', 'config_table': '', 'display_text': 'Stores covariance information for <a class="groops-file" href="fileFormat_timeSplinesGravityField.html">TimeSplinesGravityField</a>. It can be the variances of the potential coefficients or the full covariance matrix for each temporal nodal point.'},
'fileFormat_timeSplinesGravityField': { 'name': 'TimeSplinesGravityField', 'key': 'fileFormat_timeSplinesGravityField', 'description': 'Temporal changing gravity field, parametrized as spherical harmonics in the spatial domain and parametrized as basis splines in the time domain (see  basis splines ). It is evaluated with   Temporal changing gravity field, parametrized as spherical harmonics in the spatial domain and parametrized as basis splines in the time domain (see  . See also:  Gravityfield2TimeSplines ,  PotentialCoefficients2BlockMeanTimeSplines .', 'config_table': '', 'display_text': 'Temporal changing gravity field, parametrized as spherical harmonics in the spatial domain and parametrized as basis splines in the time domain (see <a class="groops-ref" href="fundamentals.basisSplines.html">basis splines</a>). It is evaluated with <a class="groops-class" href="gravityfieldType.html#timeSplines">gravityfield:timeSplines</a>.</p><p>See also: <a class="groops-program" href="Gravityfield2TimeSplines.html">Gravityfield2TimeSplines</a>, <a class="groops-program" href="PotentialCoefficients2BlockMeanTimeSplines.html">PotentialCoefficients2BlockMeanTimeSplines</a>.'},
'fileFormat_variationalEquation': { 'name': 'VariationalEquation', 'key': 'fileFormat_variationalEquation', 'description': 'Arcs with reference orbit and state transition matrices. The file contains a reference orbit (position and velocity), the derivatives of the orbit with respect to the satellite state vector for each arc, transformations (rotations) between the satellite, celestial, and terrestrial frame and a satellite macro model (see  SatelliteModel ). The reference orbit can be extracted with  Variational2OrbitAndStarCamera . See also:  PreprocessingVariationalEquation .', 'config_table': '', 'display_text': 'Arcs with reference orbit and state transition matrices.</p><p>The file contains a reference orbit (position and velocity), the derivatives of the orbit with respect to the satellite state vector for each arc, transformations (rotations) between the satellite, celestial, and terrestrial frame and a satellite macro model (see <a class="groops-file" href="fileFormat_satelliteModel.html">SatelliteModel</a>).</p><p>The reference orbit can be extracted with <a class="groops-program" href="Variational2OrbitAndStarCamera.html">Variational2OrbitAndStarCamera</a>.</p><p>See also: <a class="groops-program" href="PreprocessingVariationalEquation.html">PreprocessingVariationalEquation</a>.</p><p>'},
};
